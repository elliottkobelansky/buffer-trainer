import { Texture, Object3D, Raycaster, PerspectiveCamera, Scene, WebGLRenderer } from 'three';
import { M as Move, a as Alg, P as Pause, A as AlgNode, I as IterationDirection } from './Alg-e2a80975.js';
import { P as Parsed } from './parse-ec97687c.js';
import { K as KState, e as KTransformation, a as KPuzzle, w as PuzzleDescriptionString, j as PuzzleGeometry } from './KState-a2f0e651.js';

declare type MillisecondTimestamp = number;
declare type Duration = MillisecondTimestamp;
declare type Timestamp = MillisecondTimestamp;
declare enum Direction {
    Forwards = 1,
    Paused = 0,
    Backwards = -1
}
interface MoveInProgress {
    move: Move;
    direction: Direction;
    fraction: number;
}
declare type PuzzlePosition = {
    state: KState;
    movesInProgress: MoveInProgress[];
};
declare enum BoundaryType {
    Move = "move",
    EntireTimeline = "entire-timeline"
}
interface TimeRange {
    start: MillisecondTimestamp;
    end: MillisecondTimestamp;
}

interface UserVisibleError {
    errors: string[];
}
declare class UserVisibleErrorTracker extends SimpleTwistyPropSource<UserVisibleError> {
    getDefaultValue(): UserVisibleError;
    reset(): void;
    canReuseValue(_v1: UserVisibleError, _v2: UserVisibleError): boolean;
}

declare type InputRecord = {};
declare type InputProps<T extends InputRecord> = {
    [s in keyof T]: TwistyPropParent<T[s]>;
};
interface SourceEventDetail<OutputType> {
    sourceProp: TwistyPropSource<OutputType, any>;
    value: Promise<OutputType>;
    generation: number;
}
declare type SourceEvent<T> = CustomEvent<SourceEventDetail<T>>;
declare type PromiseOrValue<T> = T | Promise<T>;
declare abstract class TwistyPropParent<T> {
    #private;
    abstract get(): Promise<T>;
    canReuse(v1: T, v2: T): boolean;
    canReuseValue(_v1: T, _v2: T): boolean;
    debugGetChildren(): Array<TwistyPropDerived<any, any>>;
    protected addChild(child: TwistyPropDerived<any, any>): void;
    protected removeChild(child: TwistyPropDerived<any, any>): void;
    protected lastSourceGeneration: number;
    protected markStale(sourceEvent: SourceEvent<any>): void;
    /** @deprecated */
    addRawListener(listener: () => void, options?: {
        initial: boolean;
    }): void;
    /** @deprecated */
    removeRawListener(listener: () => void): void;
    addFreshListener(listener: (value: T) => void): void;
    removeFreshListener(listener: (value: T) => void): void;
}
declare abstract class TwistyPropSource<OutputType, InputType = OutputType> extends TwistyPropParent<OutputType> {
    #private;
    abstract getDefaultValue(): PromiseOrValue<OutputType>;
    constructor(initialValue?: PromiseOrValue<InputType>);
    set(input: PromiseOrValue<InputType>): void;
    get(): Promise<OutputType>;
    deriveFromPromiseOrValue(input: PromiseOrValue<InputType>, oldValuePromise: Promise<OutputType>): Promise<OutputType>;
    protected abstract derive(input: InputType, oldValuePromise: Promise<OutputType>): PromiseOrValue<OutputType>;
}
declare abstract class SimpleTwistyPropSource<SimpleType> extends TwistyPropSource<SimpleType> {
    derive(input: SimpleType): PromiseOrValue<SimpleType>;
}
declare const NO_VALUE: unique symbol;
declare type NoValueType = typeof NO_VALUE;
declare abstract class TwistyPropDerived<InputTypes extends InputRecord, OutputType> extends TwistyPropParent<OutputType> {
    #private;
    protected userVisibleErrorTracker?: UserVisibleErrorTracker | undefined;
    constructor(parents: InputProps<InputTypes>, userVisibleErrorTracker?: UserVisibleErrorTracker | undefined);
    get(): Promise<OutputType>;
    protected abstract derive(input: InputTypes): PromiseOrValue<OutputType>;
}

declare type SimpleDirection = Direction.Forwards | Direction.Backwards;
interface PlayingInfo {
    playing: boolean;
    direction: SimpleDirection;
    untilBoundary: BoundaryType;
    loop: boolean;
}
declare class PlayingInfoProp extends TwistyPropSource<PlayingInfo, Partial<PlayingInfo>> {
    getDefaultValue(): Promise<PlayingInfo>;
    derive(newInfo: Partial<PlayingInfo>, oldValuePromise: Promise<PlayingInfo>): Promise<PlayingInfo>;
    canReuseValue(v1: PlayingInfo, v2: PlayingInfo): boolean;
}

declare class ArbitraryStringProp extends SimpleTwistyPropSource<string | null> {
    getDefaultValue(): string | null;
}

declare class URLProp extends TwistyPropSource<URL | null, URL | string | null> {
    getDefaultValue(): URL | null;
    derive(input: URL | string | null): URL | null;
}

declare class AlgIssues {
    readonly warnings: readonly string[];
    readonly errors: readonly string[];
    constructor(issues?: {
        warnings?: string[];
        errors?: string[];
    });
    add(issues?: {
        warnings?: string[];
        errors?: string[];
    }): AlgIssues;
    /** @deprecated */
    log(): void;
}
interface AlgWithIssues {
    alg: Alg;
    issues: AlgIssues;
}
declare class AlgProp extends TwistyPropSource<AlgWithIssues, Alg | string> {
    getDefaultValue(): AlgWithIssues;
    canReuseValue(v1: AlgWithIssues, v2: AlgWithIssues): boolean;
    derive(newAlg: Alg | string): Promise<AlgWithIssues>;
}

declare type AlgTransformationPropInputs = {
    setupAlg: AlgWithIssues;
    kpuzzle: KPuzzle;
};
declare class AlgTransformationProp extends TwistyPropDerived<AlgTransformationPropInputs, KTransformation> {
    derive(input: AlgTransformationPropInputs): KTransformation;
}

declare type AnimatedLeafAlgNode = Move | Pause;

interface CurrentMove {
    move: Move;
    direction: Direction;
    fraction: number;
    startTimestamp: MillisecondTimestamp;
    endTimestamp: MillisecondTimestamp;
}
interface CurrentMoveInfo {
    stateIndex: number;
    currentMoves: CurrentMove[];
    movesFinishing: CurrentMove[];
    movesFinished: CurrentMove[];
    movesStarting: CurrentMove[];
    latestStart: number;
    earliestEnd: number;
}
interface AlgIndexer {
    getAnimLeaf(index: number): AnimatedLeafAlgNode | null;
    indexToMoveStartTimestamp(index: number): Timestamp;
    stateAtIndex(index: number, startSTate?: KState): KState;
    transformationAtIndex(index: number): KTransformation;
    numAnimatedLeaves(): number;
    timestampToIndex(timestamp: Timestamp): number;
    algDuration(): Duration;
    moveDuration(index: number): number;
    timestampToPosition?: (timestamp: Timestamp, startState?: KState) => PuzzlePosition;
    currentMoveInfo?: (timestamp: Timestamp) => CurrentMoveInfo;
}

declare const setupToLocations: {
    start: boolean;
    end: boolean;
};
declare type SetupToLocation = keyof typeof setupToLocations;
declare class SetupAnchorProp extends SimpleTwistyPropSource<SetupToLocation> {
    getDefaultValue(): SetupToLocation;
}

interface AnchorTransformationPropInputs {
    setupTransformation: KTransformation | null;
    setupAnchor: SetupToLocation;
    setupAlgTransformation: KTransformation;
    indexer: AlgIndexer;
}
declare class AnchorTransformationProp extends TwistyPropDerived<AnchorTransformationPropInputs, KTransformation> {
    derive(inputs: AnchorTransformationPropInputs): KTransformation;
}

interface CatchUpMove {
    move: Move | null;
    amount: number;
}
declare class CatchUpMoveProp extends SimpleTwistyPropSource<CatchUpMove> {
    getDefaultValue(): CatchUpMove;
    canReuseValue(v1: CatchUpMove, v2: CatchUpMove): boolean;
}

interface CurrentLeavesSimplifiedPropInputs {
    currentMoveInfo: CurrentMoveInfo;
}
interface CurrentLeavesSimplified {
    stateIndex: number;
    movesFinishing: Move[];
    movesFinished: Move[];
}
declare class CurrentLeavesSimplifiedProp extends TwistyPropDerived<CurrentLeavesSimplifiedPropInputs, CurrentLeavesSimplified> {
    derive(inputs: CurrentLeavesSimplifiedPropInputs): CurrentLeavesSimplified;
    canReuse(v1: CurrentLeavesSimplified, v2: CurrentLeavesSimplified): boolean;
}

declare const smartTimestamps: {
    start: boolean;
    end: boolean;
    anchor: boolean;
    "opposite-anchor": boolean;
};
declare type TimestampRequest = MillisecondTimestamp | keyof typeof smartTimestamps;
declare class TimestampRequestProp extends SimpleTwistyPropSource<TimestampRequest> {
    getDefaultValue(): TimestampRequest;
    set(v: TimestampRequest): void;
    validInput(v: TimestampRequest): boolean;
}

interface DetailedTimelineInfoInputs {
    timestampRequest: TimestampRequest;
    timeRange: TimeRange;
    setupAnchor: SetupToLocation;
}
interface DetailedTimelineInfo {
    timestamp: MillisecondTimestamp;
    timeRange: TimeRange;
    atStart: boolean;
    atEnd: boolean;
}
declare class DetailedTimelineInfoProp extends TwistyPropDerived<DetailedTimelineInfoInputs, DetailedTimelineInfo> {
    #private;
    derive(inputs: DetailedTimelineInfoInputs): DetailedTimelineInfo;
    canReuse(v1: DetailedTimelineInfo, v2: DetailedTimelineInfo): boolean;
}

interface PositionPropInputs {
    indexer: AlgIndexer;
    detailedTimelineInfo: DetailedTimelineInfo;
    catchUpMove: CatchUpMove;
}
declare class CurrentMoveInfoProp extends TwistyPropDerived<PositionPropInputs, CurrentMoveInfo> {
    derive(inputs: PositionPropInputs): CurrentMoveInfo;
}

interface CurrentTransformationPropInputs {
    anchoredStart: KTransformation;
    currentLeavesSimplified: CurrentLeavesSimplified;
    indexer: AlgIndexer;
}
declare class CurrentStateProp extends TwistyPropDerived<CurrentTransformationPropInputs, KState> {
    derive(inputs: CurrentTransformationPropInputs): KState;
}

declare const visualizationFormats: {
    "3D": boolean;
    "2D": boolean;
    "experimental-2D-LL": boolean;
    PG3D: boolean;
};
declare type VisualizationFormat = keyof typeof visualizationFormats;
declare type VisualizationFormatWithAuto = VisualizationFormat | "auto";
declare class VisualizationFormatProp extends SimpleTwistyPropSource<VisualizationFormatWithAuto> {
    getDefaultValue(): VisualizationFormatWithAuto;
}

declare type VisualizationStrategyPropInputs = {
    visualizationRequest: VisualizationFormatWithAuto;
    puzzleID: PuzzleID;
};
declare type VisualizationStrategy = "Cube3D" | "2D" | "experimental-2D-LL" | "PG3D";
declare class VisualizationStrategyProp extends TwistyPropDerived<VisualizationStrategyPropInputs, VisualizationStrategy> {
    derive(inputs: VisualizationStrategyPropInputs): VisualizationStrategy;
}

declare const puzzleIDs: {
    "3x3x3": boolean;
    custom: boolean;
    "2x2x2": boolean;
    "4x4x4": boolean;
    "5x5x5": boolean;
    "6x6x6": boolean;
    "7x7x7": boolean;
    "40x40x40": boolean;
    megaminx: boolean;
    pyraminx: boolean;
    square1: boolean;
    clock: boolean;
    skewb: boolean;
    fto: boolean;
    gigaminx: boolean;
    master_tetraminx: boolean;
    kilominx: boolean;
    redi_cube: boolean;
};
declare type PuzzleID = keyof typeof puzzleIDs;
declare class PuzzleIDRequestProp extends SimpleTwistyPropSource<PuzzleID | NoValueType> {
    getDefaultValue(): PuzzleID | NoValueType;
}

declare const indexerStrategyNames: {
    auto: boolean;
    simple: boolean;
    tree: boolean;
    simultaneous: boolean;
};
declare type IndexerStrategyName = keyof typeof indexerStrategyNames;
declare class IndexerConstructorRequestProp extends SimpleTwistyPropSource<IndexerStrategyName> {
    getDefaultValue(): IndexerStrategyName;
}

declare type IndexerConstructor = new (kpuzzle: KPuzzle, alg: Alg) => AlgIndexer;
interface IndexerConstructorPropInputs {
    puzzle: PuzzleID;
    alg: AlgWithIssues;
    visualizationStrategy: VisualizationStrategy;
    indexerConstructorRequest: IndexerStrategyName;
}
declare class IndexerConstructorProp extends TwistyPropDerived<IndexerConstructorPropInputs, IndexerConstructor> {
    derive(inputs: IndexerConstructorPropInputs): IndexerConstructor;
}

declare type IndexerPropInputs = {
    indexerConstructor: IndexerConstructor;
    algWithIssues: AlgWithIssues;
    kpuzzle: KPuzzle;
};
declare class IndexerProp extends TwistyPropDerived<IndexerPropInputs, AlgIndexer> {
    derive(input: IndexerPropInputs): AlgIndexer;
}

interface LegacyPositionPropInputs {
    currentMoveInfo: CurrentMoveInfo;
    state: KState;
}
declare class LegacyPositionProp extends TwistyPropDerived<LegacyPositionPropInputs, PuzzlePosition> {
    derive(inputs: LegacyPositionPropInputs): PuzzlePosition;
}

interface NaiveMoveCountPropInputs {
    alg: AlgWithIssues;
}
declare class NaiveMoveCountProp extends TwistyPropDerived<NaiveMoveCountPropInputs, number | null> {
    derive(inputs: NaiveMoveCountPropInputs): number | null;
}

declare class PuzzleAlgProp extends TwistyPropDerived<{
    algWithIssues: AlgWithIssues;
    kpuzzle: KPuzzle;
}, AlgWithIssues> {
    derive(inputs: {
        algWithIssues: AlgWithIssues;
        kpuzzle: KPuzzle;
    }): Promise<AlgWithIssues>;
}

declare class SetupTransformationProp extends SimpleTwistyPropSource<KTransformation | null> {
    getDefaultValue(): KTransformation | null;
}

declare class KPuzzleProp extends TwistyPropDerived<{
    puzzleLoader: PuzzleLoader;
}, KPuzzle> {
    derive(inputs: {
        puzzleLoader: PuzzleLoader;
    }): Promise<KPuzzle>;
}

declare class PGPuzzleDescriptionStringProp extends SimpleTwistyPropSource<PuzzleDescriptionString | NoValueType> {
    getDefaultValue(): PuzzleDescriptionString | NoValueType;
}

declare class PuzzleIDProp extends TwistyPropDerived<{
    puzzleLoader: PuzzleLoader;
}, PuzzleID> {
    derive(inputs: {
        puzzleLoader: PuzzleLoader;
    }): Promise<PuzzleID>;
}

interface PuzzleLoaderPropInputs {
    puzzleIDRequest: PuzzleID | NoValueType;
    puzzleDescriptionRequest: PuzzleDescriptionString | NoValueType;
}
declare class PuzzleLoaderProp extends TwistyPropDerived<PuzzleLoaderPropInputs, PuzzleLoader> {
    derive(inputs: PuzzleLoaderPropInputs): PuzzleLoader;
}

declare let HTMLElementShim: typeof HTMLElement;

declare class CSSSource {
    private sourceText;
    constructor(sourceText: string);
    getAsString(): string;
}
declare class ManagedCustomElement extends HTMLElementShim {
    #private;
    readonly shadow: ShadowRoot;
    readonly contentWrapper: HTMLDivElement;
    constructor(options?: {
        mode: "open" | "closed";
    });
    addCSS(cssSource: CSSSource): HTMLStyleElement;
    removeCSS(cssSource: CSSSource): void;
    addElement<T extends Node>(element: T): T;
    prependElement<T extends Node>(element: T): void;
    removeElement<T extends Node>(element: T): T;
}

declare const viewerLinkPages: {
    twizzle: boolean;
    "experimental-twizzle-explorer": boolean;
    none: boolean;
};
declare type ViewerLinkPage = keyof typeof viewerLinkPages;
declare type ViewerLinkPageWithAuto = ViewerLinkPage | "auto";
declare class ViewerLinkProp extends SimpleTwistyPropSource<ViewerLinkPageWithAuto> {
    getDefaultValue(): ViewerLinkPageWithAuto;
}

declare const buttonIcons: string[];
declare type ButtonIcon = typeof buttonIcons[number];
interface ButtonAppearance {
    enabled: boolean;
    icon: ButtonIcon;
    title: string;
    hidden?: boolean;
}
declare type ButtonAppearances = Record<ButtonCommand, ButtonAppearance>;
interface ButtonAppearancePropInputs {
    coarseTimelineInfo: CoarseTimelineInfo;
    viewerLink: ViewerLinkPageWithAuto;
}
declare class ButtonAppearanceProp extends TwistyPropDerived<ButtonAppearancePropInputs, ButtonAppearances> {
    derive(inputs: ButtonAppearancePropInputs): ButtonAppearances;
}

declare class TwistyPlayerController {
    private model;
    animationController: TwistyAnimationController;
    constructor(model: TwistyPlayerModel, delegate: TwistyAnimationControllerDelegate);
    jumpToStart(options?: {
        flash: boolean;
    }): void;
    jumpToEnd(options?: {
        flash: boolean;
    }): void;
    togglePlay(play?: boolean): void;
    visitTwizzleLink(): Promise<void>;
}

declare const buttonCommands: {
    fullscreen: boolean;
    "jump-to-start": boolean;
    "play-step-backwards": boolean;
    "play-pause": boolean;
    "play-step": boolean;
    "jump-to-end": boolean;
    "twizzle-link": boolean;
};
declare type ButtonCommand = keyof typeof buttonCommands;
declare class TwistyButtons extends ManagedCustomElement {
    #private;
    model?: TwistyPlayerModel | undefined;
    controller?: TwistyPlayerController | undefined;
    private fullscreenElement?;
    buttons: Record<ButtonCommand, TwistyButton> | null;
    constructor(model?: TwistyPlayerModel | undefined, controller?: TwistyPlayerController | undefined, fullscreenElement?: HTMLElement | undefined);
    connectedCallback(): void;
    onFullscreenButton(): Promise<void>;
    update(buttonAppearances: ButtonAppearances): Promise<void>;
}
declare class TwistyButton extends ManagedCustomElement {
    #private;
    htmlButton: HTMLButtonElement;
    connectedCallback(): void;
    setIcon(iconName: ButtonIcon): void;
}

interface CoarseTimelineInfoInputs {
    playingInfo: PlayingInfo;
    detailedTimelineInfo: DetailedTimelineInfo;
}
interface CoarseTimelineInfo {
    playing: boolean;
    atStart: boolean;
    atEnd: boolean;
}
declare class CoarseTimelineInfoProp extends TwistyPropDerived<CoarseTimelineInfoInputs, CoarseTimelineInfo> {
    derive(inputs: CoarseTimelineInfoInputs): CoarseTimelineInfo;
    canReuseValue(v1: CoarseTimelineInfo, v2: CoarseTimelineInfo): boolean;
}

declare class TempoScaleProp extends TwistyPropSource<number, number> {
    getDefaultValue(): number;
    derive(v: number): number;
}

declare const backViewLayouts: {
    none: boolean;
    "side-by-side": boolean;
    "top-right": boolean;
};
declare type BackViewLayout = keyof typeof backViewLayouts;
declare type BackViewLayoutWithAuto = BackViewLayout | "auto";
declare class BackViewProp extends SimpleTwistyPropSource<BackViewLayoutWithAuto> {
    getDefaultValue(): BackViewLayoutWithAuto;
}

declare const controlsLocations: {
    "bottom-row": boolean;
    none: boolean;
};
declare type ControlsLocation = keyof typeof controlsLocations;
declare type ControlPanelThemeWithAuto = ControlsLocation | "auto";
declare class ControlPanelProp extends SimpleTwistyPropSource<ControlPanelThemeWithAuto> {
    getDefaultValue(): ControlPanelThemeWithAuto;
}

declare class TimeRangeProp extends TwistyPropDerived<{
    indexer: AlgIndexer;
}, TimeRange> {
    derive(inputs: {
        indexer: AlgIndexer;
    }): TimeRange;
}

declare type FoundationDisplay = "auto" | "opaque" | "none";
declare class FoundationDisplayProp extends SimpleTwistyPropSource<FoundationDisplay> {
    getDefaultValue(): FoundationDisplay;
}

declare const hintFaceletStyles: {
    floating: boolean;
    none: boolean;
};
declare type HintFaceletStyle = keyof typeof hintFaceletStyles;
declare type HintFaceletStyleWithAuto = HintFaceletStyle | "auto";
declare class HintFaceletProp extends SimpleTwistyPropSource<HintFaceletStyleWithAuto> {
    getDefaultValue(): HintFaceletStyleWithAuto;
}

declare type SpritePropInputs = {
    spriteURL: URL | null;
};
declare class SpriteProp extends TwistyPropDerived<SpritePropInputs, Texture | null> {
    derive(inputs: SpritePropInputs): Promise<Texture | null>;
}

declare const experimentalStickerings: Record<string, {
    groups?: Partial<Record<PuzzleID, string>>;
}>;

declare type FaceletMeshAppearance = "regular" | "dim" | "oriented" | "ignored" | "invisible";
declare type FaceletAppearance = {
    appearance: FaceletMeshAppearance;
    hintAppearance?: FaceletMeshAppearance;
};
declare type PieceAppearance = {
    facelets: (FaceletMeshAppearance | FaceletAppearance | null)[];
};
declare type OrbitAppearance = {
    pieces: (PieceAppearance | null)[];
};
declare type PuzzleAppearance = {
    name?: string;
    orbits: Record<string, OrbitAppearance>;
};

interface PuzzleLoader {
    id: string;
    fullName: string;
    inventedBy?: string[];
    inventionYear?: number;
    /** @deprecated */
    def?: never;
    kpuzzle: () => Promise<KPuzzle>;
    svg: () => Promise<string>;
    llSVG?: () => Promise<string>;
    pg?: () => Promise<PuzzleGeometry>;
    appearance?: (stickering: ExperimentalStickering) => Promise<PuzzleAppearance>;
    stickerings?: () => Promise<ExperimentalStickering[]>;
}

declare type ExperimentalStickering = keyof typeof experimentalStickerings;
declare class StickeringProp extends SimpleTwistyPropSource<ExperimentalStickering> {
    getDefaultValue(): ExperimentalStickering;
}

declare const dragInputModes: {
    auto: boolean;
    none: boolean;
};
declare type DragInputMode = keyof typeof dragInputModes;
declare class DragInputProp extends SimpleTwistyPropSource<DragInputMode> {
    getDefaultValue(): DragInputMode;
}

declare const movePressInputNames: {
    auto: boolean;
    none: boolean;
    basic: boolean;
};
declare type MovePressInput = keyof typeof movePressInputNames;
declare class MovePressInputProp extends SimpleTwistyPropSource<MovePressInput> {
    getDefaultValue(): MovePressInput;
}

declare const backgroundThemes: {
    checkered: boolean;
    none: boolean;
};
declare type BackgroundTheme = keyof typeof backgroundThemes;
declare type BackgroundThemeWithAuto = BackgroundTheme | "auto";
declare class BackgroundProp extends SimpleTwistyPropSource<BackgroundThemeWithAuto> {
    getDefaultValue(): BackgroundThemeWithAuto;
}

declare type CoordinateDegrees = number;
interface OrbitCoordinates {
    latitude: CoordinateDegrees;
    longitude: CoordinateDegrees;
    distance: number;
}
declare type OrbitCoordinatesRequest = Partial<OrbitCoordinates> | "auto";
declare class OrbitCoordinatesRequestProp extends TwistyPropSource<OrbitCoordinatesRequest, Partial<OrbitCoordinates> | "auto"> {
    getDefaultValue(): OrbitCoordinatesRequest;
    canReuseValue(v1: OrbitCoordinates, v2: OrbitCoordinates): boolean;
    derive(newCoordinates: Partial<OrbitCoordinates> | "auto", oldValuePromise: Promise<OrbitCoordinatesRequest>): Promise<OrbitCoordinatesRequest>;
}

declare class LatitudeLimitProp extends SimpleTwistyPropSource<CoordinateDegrees> {
    getDefaultValue(): CoordinateDegrees;
}

interface OrbitCoordinatesPropInputs {
    orbitCoordinatesRequest: OrbitCoordinatesRequest;
    latitudeLimit: CoordinateDegrees;
    puzzleID: PuzzleID;
    strategy: VisualizationStrategy;
}
declare class OrbitCoordinatesProp extends TwistyPropDerived<OrbitCoordinatesPropInputs, OrbitCoordinates> {
    canReuseValue(v1: OrbitCoordinates, v2: OrbitCoordinates): boolean;
    derive(inputs: OrbitCoordinatesPropInputs): Promise<OrbitCoordinates>;
}

declare class TwistySceneModel {
    twistyPlayerModel: TwistyPlayerModel;
    background: BackgroundProp;
    dragInput: DragInputProp;
    foundationDisplay: FoundationDisplayProp;
    foundationStickerSpriteURL: URLProp;
    hintFacelet: HintFaceletProp;
    hintStickerSpriteURL: URLProp;
    latitudeLimit: LatitudeLimitProp;
    movePressInput: MovePressInputProp;
    orbitCoordinatesRequest: OrbitCoordinatesRequestProp;
    stickering: StickeringProp;
    foundationStickerSprite: SpriteProp;
    hintStickerSprite: SpriteProp;
    orbitCoordinates: OrbitCoordinatesProp;
    constructor(twistyPlayerModel: TwistyPlayerModel);
}

declare class TwistyPlayerModel {
    userVisibleErrorTracker: UserVisibleErrorTracker;
    alg: AlgProp;
    backView: BackViewProp;
    controlPanel: ControlPanelProp;
    catchUpMove: CatchUpMoveProp;
    indexerConstructorRequest: IndexerConstructorRequestProp;
    playingInfo: PlayingInfoProp;
    puzzleDescriptionRequest: PGPuzzleDescriptionStringProp;
    puzzleIDRequest: PuzzleIDRequestProp;
    setupAnchor: SetupAnchorProp;
    setupAlg: AlgProp;
    setupTransformation: SetupTransformationProp;
    tempoScale: TempoScaleProp;
    timestampRequest: TimestampRequestProp;
    viewerLink: ViewerLinkProp;
    visualizationFormat: VisualizationFormatProp;
    title: ArbitraryStringProp;
    videoURL: URLProp;
    competitionID: ArbitraryStringProp;
    puzzleLoader: PuzzleLoaderProp;
    kpuzzle: KPuzzleProp;
    puzzleID: PuzzleIDProp;
    puzzleAlg: PuzzleAlgProp;
    puzzleSetupAlg: PuzzleAlgProp;
    visualizationStrategy: VisualizationStrategyProp;
    indexerConstructor: IndexerConstructorProp;
    moveCount: NaiveMoveCountProp;
    setupAlgTransformation: AlgTransformationProp;
    indexer: IndexerProp;
    anchorTransformation: AnchorTransformationProp;
    timeRange: TimeRangeProp;
    detailedTimelineInfo: DetailedTimelineInfoProp;
    coarseTimelineInfo: CoarseTimelineInfoProp;
    currentMoveInfo: CurrentMoveInfoProp;
    buttonAppearance: ButtonAppearanceProp;
    currentLeavesSimplified: CurrentLeavesSimplifiedProp;
    currentState: CurrentStateProp;
    legacyPosition: LegacyPositionProp;
    twistySceneModel: TwistySceneModel;
    twizzleLink(): Promise<string>;
    experimentalAddMove(flexibleMove: Move | string, options?: {
        coalesce?: boolean;
        mod?: number;
    }): void;
    /** @deprecated */
    get playingInfoProp(): PlayingInfoProp;
}

interface TwistyAnimationControllerDelegate {
    flash(): void;
}
declare class TwistyAnimationController {
    #private;
    private delegate;
    private playing;
    private direction;
    private catchUpHelper;
    private model;
    private lastDatestamp;
    private lastTimestampPromise;
    private scheduler;
    constructor(model: TwistyPlayerModel, delegate: TwistyAnimationControllerDelegate);
    onPlayingProp(playingInfo: PlayingInfo): Promise<void>;
    onCatchUpMoveProp(catchUpMove: CatchUpMove): Promise<void>;
    jumpToStart(options?: {
        flash: boolean;
    }): void;
    jumpToEnd(options?: {
        flash: boolean;
    }): void;
    playPause(): void;
    play(options?: {
        direction?: SimpleDirection;
        untilBoundary?: BoundaryType;
        autoSkipToOtherEndIfStartingAtBoundary?: boolean;
        loop?: boolean;
    }): Promise<void>;
    pause(): void;
    animFrame(frameDatestamp: MillisecondTimestamp): Promise<void>;
}

/**
 * @author mrdoob / http://mrdoob.com/
 * ESM conversion by Lucas Garron, 2021-12-21
 */
declare class Stats {
    mode: number;
    dom: HTMLDivElement;
    constructor();
    addPanel(panel: StatsPanel): StatsPanel;
    showPanel(id: number): void;
    beginTime: number;
    prevTime: number;
    frames: number;
    fpsPanel: StatsPanel;
    msPanel: StatsPanel;
    memPanel: StatsPanel | null;
    REVISION: number;
    begin(): void;
    end(): number;
    update(): void;
}
declare class StatsPanel {
    private name;
    private fg;
    private bg;
    min: number;
    max: number;
    dom: HTMLCanvasElement;
    context: CanvasRenderingContext2D;
    constructor(name: string, fg: string, bg: string);
    update(value: number, maxValue: number): void;
}

interface Schedulable {
    scheduleRender(): void;
}

interface DragMovementInfo {
    attachedInfo: Record<any, any>;
    movementX: number;
    movementY: number;
    elapsedMs: number;
}
interface PressInfo {
    normalizedX: number;
    normalizedY: number;
    rightClick: boolean;
    keys: {
        altKey: boolean;
        ctrlOrMetaKey: boolean;
        shiftKey: boolean;
    };
}
declare class DragTracker extends EventTarget {
    #private;
    readonly target: HTMLElement;
    constructor(target: HTMLElement);
    start(): void;
    stop(): void;
    addTargetListener(eventType: string, listener: (e: MouseEvent) => any): void;
    private onPointerDown;
    private onPointerMove;
    private onPointerUp;
}

interface Twisty3DPuzzle extends Object3D {
    onPositionChange(position: PuzzlePosition): void;
}

declare class Twisty3DPuzzleWrapper extends EventTarget implements Schedulable {
    #private;
    private model;
    schedulable: Schedulable;
    private puzzleLoader;
    private visualizationStrategy;
    constructor(model: TwistyPlayerModel, schedulable: Schedulable, puzzleLoader: PuzzleLoader, visualizationStrategy: VisualizationStrategy);
    disconnect(): void;
    scheduleRender(): void;
    twisty3DPuzzle(): Promise<Twisty3DPuzzle>;
    raycastMove(raycasterPromise: Promise<Raycaster>, transformations: {
        invert: boolean;
        depth?: "secondSlice" | "rotation" | "none";
    }): Promise<void>;
}

declare class Twisty3DSceneWrapper extends ManagedCustomElement implements Schedulable {
    #private;
    model?: TwistyPlayerModel | undefined;
    disconnect(): void;
    constructor(model?: TwistyPlayerModel | undefined);
    connectedCallback(): Promise<void>;
    setBackView(backView: BackViewLayout): void;
    onBackView(backView: BackViewLayout): void;
    onPress(e: CustomEvent<{
        pressInfo: PressInfo;
        cameraPromise: Promise<PerspectiveCamera>;
    }>): Promise<void>;
    scene(): Promise<Scene>;
    addVantage(vantage: Twisty3DVantage): void;
    removeVantage(vantage: Twisty3DVantage): void;
    experimentalVantages(): Iterable<Twisty3DVantage>;
    scheduleRender(): void;
    setCurrentTwisty3DPuzzleWrapper(scene: Scene, twisty3DPuzzleWrapper: Twisty3DPuzzleWrapper): Promise<void>;
    /** @deprecated */
    experimentalTwisty3DPuzzleWrapper(): Promise<Twisty3DPuzzleWrapper>;
    onPuzzle(inputs: [
        puzzleLoader: PuzzleLoader,
        visualizationStrategy: VisualizationStrategy
    ]): Promise<void>;
}

declare class TwistyOrbitControls {
    private model;
    private mirror;
    private canvas;
    private dragTracker;
    /** @deprecated */
    experimentalInertia: boolean;
    private onMovementBound;
    experimentalHasBeenMoved: boolean;
    constructor(model: TwistyPlayerModel, mirror: boolean, canvas: HTMLCanvasElement, dragTracker: DragTracker);
    temperMovement(f: number): number;
    onMove(e: CustomEvent<DragMovementInfo>): void;
    onMovement(movementX: number, movementY: number): {
        temperedX: number;
        temperedY: number;
    };
    onUp(e: CustomEvent<DragMovementInfo>): void;
}

declare function debugShowRenderStats(enable: boolean): void;
declare function experimentalForceNewRendererSharing(share: boolean | null): void;
declare class Twisty3DVantage extends ManagedCustomElement {
    #private;
    private model?;
    private options?;
    scene: Twisty3DSceneWrapper | null;
    stats: Stats | null;
    private rendererIsShared;
    loadingElement: HTMLDivElement | null;
    constructor(model?: TwistyPlayerModel | undefined, scene?: Twisty3DSceneWrapper, options?: {
        backView?: boolean | undefined;
    } | undefined);
    connectedCallback(): Promise<void>;
    clearCanvas(): Promise<void>;
    renderer(): Promise<WebGLRenderer>;
    canvasInfo(): Promise<{
        canvas: HTMLCanvasElement;
        context: CanvasRenderingContext2D;
    }>;
    camera(): Promise<PerspectiveCamera>;
    orbitControls(): Promise<TwistyOrbitControls>;
    addListener<T>(prop: TwistyPropParent<T>, listener: (value: T) => void): void;
    disconnect(): void;
    experimentalNextRenderFinishedCallback(callback: () => void): void;
    render(): Promise<void>;
    scheduleRender(): void;
}

declare abstract class TwistyPlayerSettable extends ManagedCustomElement {
    experimentalModel: TwistyPlayerModel;
    set alg(newAlg: Alg | string);
    get alg(): never;
    set experimentalSetupAlg(newSetup: Alg | string);
    get experimentalSetupAlg(): never;
    set experimentalSetupAnchor(anchor: SetupToLocation);
    get experimentalSetupAnchor(): never;
    set puzzle(puzzleID: PuzzleID);
    get puzzle(): never;
    set experimentalPuzzleDescription(puzzleDescription: PuzzleDescriptionString);
    get experimentalPuzzleDescription(): never;
    set timestamp(timestamp: TimestampRequest);
    get timestamp(): never;
    set hintFacelets(hintFaceletStyle: HintFaceletStyleWithAuto);
    get hintFacelets(): never;
    set experimentalStickering(stickering: ExperimentalStickering);
    get experimentalStickering(): never;
    set backView(backView: BackViewLayoutWithAuto);
    get backView(): never;
    set background(backgroundTheme: BackgroundThemeWithAuto);
    get background(): never;
    set controlPanel(newControlPanel: ControlPanelThemeWithAuto);
    get controlPanel(): never;
    set visualization(visualizationFormat: VisualizationFormatWithAuto);
    get visualization(): never;
    set experimentalTitle(title: string | null);
    get experimentalTitle(): never;
    set experimentalVideoURL(videoURL: string | null);
    get experimentalVideoURL(): never;
    set experimentalCompetitionID(competitionID: string | null);
    get experimentalCompetitionID(): never;
    set viewerLink(viewerLinkPage: ViewerLinkPageWithAuto);
    get viewerLink(): never;
    set experimentalMovePressInput(movePressInput: MovePressInput);
    get experimentalMovePressInput(): never;
    set cameraLatitude(latitude: number);
    get cameraLatitude(): never;
    set cameraLongitude(longitude: number);
    get cameraLongitude(): never;
    set cameraDistance(distance: number);
    get cameraDistance(): never;
    set cameraLatitudeLimit(latitudeLimit: number);
    get cameraLatitudeLimit(): never;
    set indexer(indexer: IndexerStrategyName);
    get indexer(): never;
    set tempoScale(newTempoScale: number);
    get tempoScale(): never;
    set experimentalSprite(url: string | URL);
    get experimentalSprite(): never;
    set experimentalHintSprite(url: string | URL);
    get experimentalHintSprite(): never;
    set experimentalDragInput(dragInputMode: DragInputMode);
    get experimentalDragInput(): never;
    experimentalGet: ExperimentalGetters;
}
declare class ExperimentalGetters {
    private model;
    constructor(model: TwistyPlayerModel);
    alg(): Promise<Alg>;
    setupAlg(): Promise<Alg>;
    puzzleID(): Promise<PuzzleID>;
    timestamp(): Promise<MillisecondTimestamp>;
}

/** @category TwistyPlayer */
interface TwistyPlayerConfig {
    alg?: Alg | string;
    experimentalSetupAlg?: Alg | string;
    experimentalSetupAnchor?: SetupToLocation;
    puzzle?: PuzzleID;
    experimentalPuzzleDescription?: PuzzleDescriptionString;
    visualization?: VisualizationFormatWithAuto;
    hintFacelets?: HintFaceletStyleWithAuto;
    experimentalStickering?: ExperimentalStickering;
    background?: BackViewLayoutWithAuto;
    controlPanel?: ControlPanelThemeWithAuto;
    backView?: BackViewLayoutWithAuto;
    viewerLink?: ViewerLinkPageWithAuto;
    experimentalMovePressInput?: MovePressInput;
    experimentalDragInput?: DragInputMode;
    experimentalTitle?: string | null;
    experimentalVideoURL?: string;
    experimentalCompetitionID?: string;
    cameraLatitude?: number;
    cameraLongitude?: number;
    cameraDistance?: number;
    cameraLatitudeLimit?: number;
    tempoScale?: number;
    experimentalSprite?: string | null;
    experimentalHintSprite?: string | null;
}
/**
 * TwistyPlayer is the heart of `cubing.js`. It can be used to display a puzzle on a web page like this:
 *
 *     <script src="path/to/cubing/twisty" type="module"></script>
 *     <twisty-player alg="R U R'"></twisty-player>
 *
 * You can also construct it directly in JavaScript:
 *
 *     import { TwistyPlayer } from "cubing/twisty";
 *     const twistyPlayer = new TwistyPlayer({alg: "R U R'"});
 *     // Once the page has loaded, you can do this:
 *     document.body.appendChild(twistyPlayer);
 *
 * See {@link https://js.cubing.net/cubing/} for more examples.
 *
 * @category TwistyPlayer
 */
declare class TwistyPlayer extends TwistyPlayerSettable implements TwistyAnimationControllerDelegate {
    #private;
    controller: TwistyPlayerController;
    buttons: TwistyButtons;
    experimentalCanvasClickCallback: (...args: any) => void;
    constructor(config?: TwistyPlayerConfig);
    connectedCallback(): Promise<void>;
    /** @deprecated */
    experimentalSetFlashLevel(newLevel: "auto" | "none"): void;
    flash(): void;
    experimentalCurrentVantages(): Promise<Iterable<Twisty3DVantage>>;
    experimentalCurrentCanvases(): Promise<HTMLCanvasElement[]>;
    /** @deprecated */
    experimentalCurrentThreeJSPuzzleObject(puzzleChangeCallback?: () => void): Promise<Object3D>;
    jumpToStart(options?: {
        flash: boolean;
    }): void;
    jumpToEnd(options?: {
        flash: boolean;
    }): void;
    play(): void;
    pause(): void;
    togglePlay(play?: boolean): void;
    experimentalAddMove(flexibleMove: Move | string, options?: {
        coalesce?: boolean;
    }): void;
    static get observedAttributes(): string[];
    attributeChangedCallback(attributeName: string, _oldValue: string, newValue: string): void;
    experimentalScreenshot(options?: {
        width: number;
        height: number;
    }): Promise<string>;
    experimentalDownloadScreenshot(filename?: string): Promise<void>;
}
declare global {
    interface HTMLElementTagNameMap {
        "twisty-player": TwistyPlayer;
    }
}

declare class DataDown {
    earliestMoveIndex: number;
    twistyAlgViewer: TwistyAlgViewer;
    direction: IterationDirection;
}
declare class DataUp {
    moveCount: number;
    element: TwistyAlgWrapperElem | TwistyAlgLeafElem;
}
declare class TwistyAlgLeafElem extends ManagedCustomElement {
    algOrAlgNode: Alg | AlgNode;
    constructor(className: string, text: string, dataDown: DataDown, algOrAlgNode: Alg | AlgNode, offsetIntoMove: boolean, clickable: boolean);
    pathToIndex(_index: number): (TwistyAlgWrapperElem | TwistyAlgLeafElem)[];
    setCurrentMove(current: boolean): void;
}
declare class TwistyAlgWrapperElem extends HTMLElementShim {
    algOrAlgNode: Alg | AlgNode;
    private queue;
    constructor(className: string, algOrAlgNode: Alg | AlgNode);
    addString(str: string): void;
    addElem(dataUp: DataUp): number;
    flushQueue(direction?: IterationDirection): void;
    pathToIndex(_index: number): (TwistyAlgWrapperElem | TwistyAlgLeafElem)[];
}
declare class MoveHighlighter {
    moveCharIndexMap: Map<number, TwistyAlgLeafElem>;
    currentElem: TwistyAlgLeafElem | null;
    addMove(charIndex: number, elem: TwistyAlgLeafElem): void;
    set(move: Parsed<Move> | null): void;
}
/** @category Other Custom Elements */
declare class TwistyAlgViewer extends HTMLElementShim {
    #private;
    highlighter: MoveHighlighter;
    lastClickTimestamp: number | null;
    constructor(options?: {
        twistyPlayer?: TwistyPlayer;
    });
    protected connectedCallback(): void;
    private setAlg;
    get twistyPlayer(): TwistyPlayer | null;
    set twistyPlayer(twistyPlayer: TwistyPlayer | null);
    jumpToIndex(index: number, offsetIntoMove: boolean): Promise<void>;
    protected attributeChangedCallback(attributeName: string, _oldValue: string, newValue: string): Promise<void>;
    static get observedAttributes(): string[];
}
declare global {
    interface HTMLElementTagNameMap {
        "twisty-alg-viewer": TwistyAlgViewer;
    }
}

declare type AnimatedLeafAlgNodeInfo = {
    leaf: Parsed<AnimatedLeafAlgNode>;
    idx: number;
};
declare type OrderedLeafTokens = AnimatedLeafAlgNodeInfo[];

declare class TwistyAlgEditorValueProp extends SimpleTwistyPropSource<string> {
    getDefaultValue(): string;
}
interface AlgEditorAlgWithIssuesPropInput {
    value: string;
}
declare class AlgEditorAlgWithIssuesProp extends TwistyPropDerived<AlgEditorAlgWithIssuesPropInput, AlgWithIssues> {
    derive(input: AlgEditorAlgWithIssuesPropInput): AlgWithIssues;
}
interface SelectionInfoPropInput {
    selectionStart: number;
    selectionEnd: number;
}
interface SelectionInfo extends SelectionInfoPropInput {
    endChangedMostRecently: boolean;
}
declare class TwistyAlgEditorSelectionProp extends TwistyPropSource<SelectionInfo, SelectionInfoPropInput> {
    getDefaultValue(): {
        selectionStart: number;
        selectionEnd: number;
        endChangedMostRecently: boolean;
    };
    derive(input: SelectionInfoPropInput, oldValue: Promise<SelectionInfo>): Promise<SelectionInfo>;
}
interface TargetCharPropInputs {
    selectionInfo: SelectionInfo;
}
declare class TargetCharProp extends TwistyPropDerived<TargetCharPropInputs, number> {
    derive(inputs: TargetCharPropInputs): number;
}
interface LeafTokensPropInputs {
    algWithIssues: AlgWithIssues;
}
declare class LeafTokensProp extends TwistyPropDerived<LeafTokensPropInputs, OrderedLeafTokens> {
    derive(inputs: LeafTokensPropInputs): OrderedLeafTokens;
}
interface LeafToHighlightPropInputs {
    targetChar: number;
    leafTokens: OrderedLeafTokens;
}
declare type HighlightWhere = "before" | "start" | "inside" | "end" | "after";
interface HighlightInfo {
    leafInfo: AnimatedLeafAlgNodeInfo;
    where: HighlightWhere;
}
declare class LeafToHighlightProp extends TwistyPropDerived<LeafToHighlightPropInputs, HighlightInfo | null> {
    derive(inputs: LeafToHighlightPropInputs): HighlightInfo | null;
}
declare class TwistyAlgEditorModel {
    valueProp: TwistyAlgEditorValueProp;
    selectionProp: TwistyAlgEditorSelectionProp;
    targetCharProp: TargetCharProp;
    algEditorAlgWithIssues: AlgEditorAlgWithIssuesProp;
    leafTokensProp: LeafTokensProp;
    leafToHighlight: LeafToHighlightProp;
}

/**
 * Warning: the current implementation of <twisty-alg-editor> is *not good*,
 * but it is *good enough*. The important parts is that:
 *
 * - The editor can be used in apps without much effort.
 * - The editor handles alg validation and move highlighting *okay* when not
 *   connected to a `<twisty-player>`.
 * - The editor stays in sync if it's connected to a `<twisty-player>`.
 *
 * The current implementation still has some race conditions and edge cases. A
 * proper rewrite with a better model would be very welcome.
 */

declare type TwistyPlayerAlgProp = "alg" | "setupAlg";
/** @category Other Custom Elements */
declare class TwistyAlgEditor extends ManagedCustomElement {
    #private;
    model: TwistyAlgEditorModel;
    debugNeverRequestTimestamp: boolean;
    constructor(options?: {
        twistyPlayer?: TwistyPlayer;
        twistyPlayerProp?: TwistyPlayerAlgProp;
    });
    set algString(s: string);
    get algString(): string;
    set placeholder(placeholderText: string);
    onInput(): void;
    onSelectionChange(): Promise<void>;
    onBlur(): Promise<void>;
    setAlgIssueClassForPuzzle(issues: "none" | "warning" | "error"): void;
    highlightLeaf(leaf: Parsed<Move | Pause> | null): void;
    get twistyPlayer(): TwistyPlayer | null;
    set twistyPlayer(twistyPlayer: TwistyPlayer | null);
    protected attributeChangedCallback(attributeName: string, _oldValue: string, newValue: string): void;
    static get observedAttributes(): string[];
}
declare global {
    interface HTMLElementTagNameMap {
        "twisty-alg-editor": TwistyAlgEditor;
    }
}

/** @category Other Custom Elements */
declare class TwizzleLink extends ManagedCustomElement {
    #private;
    twistyPlayer: TwistyPlayer | null;
    a: HTMLAnchorElement | null;
    constructor();
    fallback(): void;
    connectedCallback(): Promise<void>;
    addHeading(text: string): HTMLElement;
}
declare global {
    interface HTMLElementTagNameMap {
        "twizzle-link": TwizzleLink;
    }
}

export { AlgIndexer as A, BackViewLayout as B, Duration as D, ExperimentalStickering as E, MillisecondTimestamp as M, NO_VALUE as N, PuzzleID as P, Timestamp as T, VisualizationFormat as V, PuzzleLoader as a, PuzzleAppearance as b, TwistyPlayer as c, TwistyAlgViewer as d, TwistyAlgEditor as e, TwistyPlayerConfig as f, experimentalForceNewRendererSharing as g, backViewLayouts as h, TwizzleLink as i, debugShowRenderStats as j };
