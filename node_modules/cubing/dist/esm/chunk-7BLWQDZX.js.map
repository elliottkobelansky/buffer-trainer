{
  "version": 3,
  "sources": ["../../src/cubing/twisty/model/PromiseFreshener.ts", "../../src/cubing/twisty/model/props/TwistyProp.ts", "../../src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts", "../../src/cubing/twisty/views/3D/TAU.ts", "../../src/cubing/twisty/heavy-code-imports/3d.ts"],
  "sourcesContent": ["// TODO: Pick a much better name.\nexport class PromiseFreshener<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  // TODO: reject instead? Drop?\n  async queue(\n    p: Promise<T>,\n  ): Promise<{ fresh: false } | { fresh: true; result: T }> {\n    const idx = ++this.#latestAssignedIdx;\n    const result = await p;\n    if (idx > this.#latestResolvedIdx) {\n      this.#latestResolvedIdx = idx;\n      return {\n        fresh: true,\n        result: result,\n      };\n    } else {\n      return { fresh: false };\n    }\n  }\n}\n\n// This will silenty drop a queued Promise (i.e. not resolve it) if a\n// newer queued one already resolved first. This is useful for classes that want\n// to know the \"latest\" state of something without jumping back to an older\n// value by accident.\n// TODO: Remove this because it's too easy to misuse?\nexport class StaleDropper<T> {\n  #latestAssignedIdx = 0;\n  #latestResolvedIdx = 0;\n\n  queue(p: Promise<T>): Promise<T> {\n    // This is a very rare case where we *do* want to drop a Promise sometimes.\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      try {\n        const idx = ++this.#latestAssignedIdx;\n        const result = await p;\n        if (idx > this.#latestResolvedIdx) {\n          this.#latestResolvedIdx = idx;\n          resolve(result);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n}\n", "import { from } from \"../../../vendor/p-lazy/p-lazy\";\nimport { StaleDropper } from \"../PromiseFreshener\";\nimport type { UserVisibleErrorTracker } from \"../UserVisibleErrorTracker\";\n\n/*eslint @typescript-eslint/ban-types:off */\ntype InputRecord = {};\n\nexport type InputProps<T extends InputRecord> = {\n  [s in keyof T]: TwistyPropParent<T[s]>;\n};\n\ntype InputPromises<T extends InputRecord> = {\n  [s in keyof T]: Promise<T[s]>;\n};\n\ninterface SourceEventDetail<OutputType> {\n  sourceProp: TwistyPropSource<OutputType, any>;\n  value: Promise<OutputType>; // TODO: remove?\n  generation: number;\n}\n\ntype SourceEvent<T> = CustomEvent<SourceEventDetail<T>>;\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\n// Values of T must be immutable.\nlet globalSourceGeneration = 0; // This is incremented before being used, so 1 will be the first active value.\nexport abstract class TwistyPropParent<T> {\n  public abstract get(): Promise<T>;\n\n  // Don't overwrite this. Overwrite `canReuseValue` instead.\n  canReuse(v1: T, v2: T): boolean {\n    return v1 === v2 || this.canReuseValue(v1, v2);\n  }\n\n  // Overwrite with a cheap semantic comparison when possible.\n  // Note that this is not called if `v1 === v2` (in which case the value is automatically reused).\n  canReuseValue(_v1: T, _v2: T): boolean {\n    return false;\n  }\n\n  debugGetChildren(): Array<TwistyPropDerived<any, any>> {\n    return Array.from(this.#children.values());\n  }\n\n  // Propagation\n\n  #children: Set<TwistyPropDerived<any, any>> = new Set();\n  protected addChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.add(child);\n  }\n\n  protected removeChild(child: TwistyPropDerived<any, any>): void {\n    this.#children.delete(child);\n  }\n\n  protected lastSourceGeneration: number = 0;\n  // Synchronously marks all descendants as stale. This doesn't actually\n  // literally mark as stale, but it updates the last source generation, which\n  // is used to tell if a cahced result is stale.\n  protected markStale(sourceEvent: SourceEvent<any>): void {\n    if (sourceEvent.detail.generation !== globalSourceGeneration) {\n      // The full stale propagation is synchronous, so there should not be a new one yet.\n      throw new Error(\"A TwistyProp was marked stale too late!\");\n    }\n    if (this.lastSourceGeneration === sourceEvent.detail.generation) {\n      // Already propagated.\n      return;\n    }\n    this.lastSourceGeneration = sourceEvent.detail.generation;\n    for (const child of this.#children) {\n      child.markStale(sourceEvent);\n    }\n    // We schedule sending out events *after* the (synchronous) propagation has happened, in\n    // case one of the listeners updates a source again.\n    this.#scheduleRawDispatch();\n  }\n\n  #rawListeners: Set<() => void> = new Set();\n  /** @deprecated */\n  addRawListener(listener: () => void, options?: { initial: boolean }): void {\n    this.#rawListeners.add(listener);\n    if (options?.initial) {\n      listener(); // TODO: wrap in a try?\n    }\n  }\n\n  /** @deprecated */\n  removeRawListener(listener: () => void): void {\n    this.#rawListeners.delete(listener);\n  }\n\n  /** @deprecated */\n  #scheduleRawDispatch(): void {\n    if (!this.#rawDispatchPending) {\n      this.#rawDispatchPending = true;\n      setTimeout(() => this.#dispatchRawListeners(), 0);\n    }\n  }\n\n  #rawDispatchPending: boolean = false;\n  #dispatchRawListeners(): void {\n    if (!this.#rawDispatchPending) {\n      throw new Error(\"Invalid dispatch state!\");\n    }\n    for (const listener of this.#rawListeners) {\n      listener(); // TODO: wrap in a try?\n    }\n    this.#rawDispatchPending = false;\n  }\n\n  #freshListeners: Map<(value: T) => void, () => void> = new Map();\n  // TODO: Pick a better name.\n  addFreshListener(listener: (value: T) => void): void {\n    const staleDropper: StaleDropper<T> = new StaleDropper<T>();\n    let lastResult: T | null = null;\n    const callback = async () => {\n      const result = await staleDropper.queue(this.get());\n      if (lastResult !== null && this.canReuse(lastResult, result)) {\n        return;\n      }\n      lastResult = result;\n      listener(result);\n    };\n    this.#freshListeners.set(listener, callback);\n    this.addRawListener(callback, { initial: true });\n  }\n\n  removeFreshListener(listener: (value: T) => void): void {\n    this.removeRawListener(this.#freshListeners.get(listener)!); // TODO: throw a custom error?\n    this.#freshListeners.delete(listener);\n  }\n}\n\nexport abstract class TwistyPropSource<\n  OutputType,\n  InputType = OutputType,\n> extends TwistyPropParent<OutputType> {\n  #value: Promise<OutputType>;\n\n  public abstract getDefaultValue(): PromiseOrValue<OutputType>;\n\n  constructor(initialValue?: PromiseOrValue<InputType>) {\n    super();\n    this.#value = from(() => this.getDefaultValue());\n    if (initialValue) {\n      this.#value = this.deriveFromPromiseOrValue(initialValue, this.#value);\n    }\n  }\n\n  set(input: PromiseOrValue<InputType>): void {\n    this.#value = this.deriveFromPromiseOrValue(input, this.#value);\n\n    const sourceEventDetail: SourceEventDetail<OutputType> = {\n      sourceProp: this,\n      value: this.#value,\n      generation: ++globalSourceGeneration,\n    };\n    this.markStale(\n      new CustomEvent<SourceEventDetail<OutputType>>(\"stale\", {\n        detail: sourceEventDetail,\n      }),\n    );\n  }\n\n  async get(): Promise<OutputType> {\n    return this.#value;\n  }\n\n  async deriveFromPromiseOrValue(\n    input: PromiseOrValue<InputType>,\n    oldValuePromise: Promise<OutputType>,\n  ): Promise<OutputType> {\n    return this.derive(await input, oldValuePromise);\n  }\n\n  // TODO: add an indirect layer to cache the derivation?\n  protected abstract derive(\n    input: InputType,\n    oldValuePromise: Promise<OutputType>,\n  ): PromiseOrValue<OutputType>;\n}\n\nexport abstract class SimpleTwistyPropSource<\n  SimpleType,\n> extends TwistyPropSource<SimpleType> {\n  derive(input: SimpleType): PromiseOrValue<SimpleType> {\n    return input;\n  }\n}\n\n// TODO: Can we support `null` as a valid output value without loosening type\n// safety?\nexport const NO_VALUE = Symbol(\"no value\");\nexport type NoValueType = typeof NO_VALUE;\n\nexport abstract class TwistyPropDerived<\n  InputTypes extends InputRecord,\n  OutputType,\n> extends TwistyPropParent<OutputType> {\n  // cachedInputs:\n  #parents: InputProps<InputTypes>;\n\n  constructor(\n    parents: InputProps<InputTypes>,\n    protected userVisibleErrorTracker?: UserVisibleErrorTracker,\n  ) {\n    super();\n    this.#parents = parents;\n    for (const parent of Object.values(parents)) {\n      (\n        parent as TwistyPropDerived<InputProps<InputTypes>, OutputType>\n      ).addChild(this);\n    }\n  }\n\n  #cachedLastSuccessfulCalculation: {\n    inputs: InputTypes;\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  #cachedLatestGenerationCalculation: {\n    output: Promise<OutputType>;\n    generation: number;\n  } | null = null;\n\n  public async get(): Promise<OutputType> {\n    const generation = this.lastSourceGeneration;\n\n    if (this.#cachedLatestGenerationCalculation?.generation === generation) {\n      return this.#cachedLatestGenerationCalculation.output;\n    }\n\n    const latestGenerationCalculation = {\n      generation,\n      output: this.#cacheDerive(\n        this.#getParents(),\n        generation,\n        this.#cachedLastSuccessfulCalculation,\n      ),\n    };\n    this.#cachedLatestGenerationCalculation = latestGenerationCalculation;\n\n    this.userVisibleErrorTracker?.reset();\n    return latestGenerationCalculation.output;\n  }\n\n  async #getParents(): Promise<InputTypes> {\n    const inputValuePromises: InputPromises<InputRecord> = {} as any; // TODO\n    for (const [key, parent] of Object.entries(this.#parents)) {\n      (inputValuePromises as Record<string, Promise<unknown>>)[key] = (\n        parent as TwistyPropParent<unknown>\n      ).get();\n    }\n\n    const inputs: InputTypes = {} as any; // TODO\n    for (const key in this.#parents) {\n      inputs[key] = (await (\n        inputValuePromises as Record<string, Promise<unknown>>\n      )[key]) as any;\n    }\n    return inputs;\n  }\n\n  async #cacheDerive(\n    inputsPromise: PromiseOrValue<InputTypes>,\n    generation: number,\n    cachedLatestGenerationCalculation: {\n      inputs: InputTypes;\n      output: Promise<OutputType>;\n      generation: number;\n    } | null = null,\n  ): Promise<OutputType> {\n    const inputs = await inputsPromise;\n\n    const cache = (output: OutputType): OutputType => {\n      this.#cachedLastSuccessfulCalculation = {\n        inputs,\n        output: Promise.resolve(output),\n        generation,\n      };\n      return output;\n    };\n\n    if (!cachedLatestGenerationCalculation) {\n      return cache(await this.derive(inputs));\n    }\n\n    const cachedInputs = cachedLatestGenerationCalculation.inputs;\n    for (const key in this.#parents) {\n      const parent = this.#parents[key];\n      if (!parent.canReuse(inputs[key], cachedInputs[key])) {\n        return cache(await this.derive(inputs));\n      }\n    }\n\n    return cachedLatestGenerationCalculation.output;\n  }\n\n  protected abstract derive(input: InputTypes): PromiseOrValue<OutputType>;\n}\n\nexport class FreshListenerManager {\n  #disconnectionFunctions: (() => void)[] = [];\n\n  addListener<T>(\n    prop: TwistyPropParent<T>,\n    listener: (value: T) => void,\n  ): void {\n    let disconnected = false;\n    const wrappedListener = (value: T) => {\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      listener(value);\n    };\n\n    prop.addFreshListener(wrappedListener);\n\n    this.#disconnectionFunctions.push(() => {\n      prop.removeFreshListener(wrappedListener);\n      disconnected = true;\n    });\n  }\n\n  // TODO: Figure out the signature to let us do overloads\n  /** @deprecated */\n  addMultiListener3<U, V, W>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>, TwistyPropParent<W>],\n    listener: (values: [U, V, W]) => void,\n  ): void {\n    this.addMultiListener(props as any, listener as any); // TODO\n  }\n  addMultiListener<U, V>(\n    props: [TwistyPropParent<U>, TwistyPropParent<V>],\n    listener: (values: [U, V]) => void,\n  ) {\n    let disconnected = false;\n\n    // We're going to get one initial call per prop. We'll ignore all but one.\n    let initialIgnoresLeft = props.length - 1;\n    const wrappedListener = async (_: any) => {\n      if (initialIgnoresLeft > 0) {\n        initialIgnoresLeft--;\n        return;\n      }\n      if (disconnected) {\n        // TODO\n        // console.warn(\"Should be disconnected!\");\n        return;\n      }\n      // We rely on `TwistyProp` caching to give us the full set of latest\n      // values efficiently.\n      const promises = (props as TwistyPropParent<any>[]).map((prop) =>\n        prop.get(),\n      );\n      const values = await Promise.all(promises);\n      listener(values as any); // TODO: fix up types\n    };\n\n    for (const prop of props) {\n      prop.addFreshListener(wrappedListener);\n    }\n\n    this.#disconnectionFunctions.push(() => {\n      for (const prop of props) {\n        prop.removeFreshListener(wrappedListener);\n      }\n      disconnected = true;\n    });\n  }\n\n  disconnect(): void {\n    for (const disconnectionFunction of this.#disconnectionFunctions) {\n      disconnectionFunction();\n    }\n  }\n}\n", "import { SimpleTwistyPropSource } from \"../../TwistyProp\";\n\n// TODO: turn these maps into lists?\nexport const hintFaceletStyles = {\n  floating: true, // default\n  none: true,\n};\nexport type HintFaceletStyle = keyof typeof hintFaceletStyles;\nexport type HintFaceletStyleWithAuto = HintFaceletStyle | \"auto\";\n\nexport class HintFaceletProp extends SimpleTwistyPropSource<HintFaceletStyleWithAuto> {\n  getDefaultValue(): HintFaceletStyleWithAuto {\n    return \"auto\";\n  }\n}\n", "export const TAU = Math.PI * 2;\nexport const DEGREES_PER_RADIAN = 360 / TAU;\n", "import { from } from \"../../vendor/p-lazy/p-lazy\";\n\n// TODO can we remove the cached proxy?\n\n// In theory we can, but we've run into situations where imports are not properly cached.\nlet cachedConstructorProxy: Promise<\n  typeof import(\"./dynamic-entries/twisty-dynamic-3d\")\n> | null = null;\n\nexport async function proxy3D(): Promise<\n  typeof import(\"./dynamic-entries/twisty-dynamic-3d\")\n> {\n  return (cachedConstructorProxy ??= import(\n    \"./dynamic-entries/twisty-dynamic-3d\"\n  ));\n}\n\nexport const THREEJS: Promise<typeof import(\"three\")> = from(\n  async () => (await proxy3D()).T3I,\n);\n"],
  "mappings": "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",
  "names": []
}
