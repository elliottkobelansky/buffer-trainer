import {
  randomUIntBelowFactory
} from "./chunk-V55YSWJY.js";
import {
  exposeAPI
} from "./chunk-RHC3DIN3.js";
import {
  node_adapter_default
} from "./chunk-ALBEW4DJ.js";
import {
  Alg
} from "./chunk-GXZIBFSN.js";

// src/cubing/search/inside/solve/puzzles/clock.ts
var pins = ["UR", "DR", "DL", "UL"];
var backMoves = ["U", "R", "D", "L", "ALL"];
var frontMoves = pins.concat(backMoves);
var randomUIntBelowPromise = randomUIntBelowFactory();
async function randomClockScrambleString() {
  const randomUIntBelow = await randomUIntBelowPromise;
  let filteringMoveCount = 0;
  async function randomSuffix(randomUIntBelow2) {
    const amount = randomUIntBelow2(12);
    if (amount !== 0) {
      filteringMoveCount++;
    }
    if (amount <= 6) {
      return `${amount}+`;
    } else {
      return `${12 - amount}-`;
    }
  }
  const moves = [];
  async function side(families) {
    for (const family of families) {
      moves.push(`${family}${await randomSuffix(randomUIntBelow)}`);
    }
  }
  await side(frontMoves);
  moves.push("y2");
  await side(backMoves);
  if (filteringMoveCount < 2) {
    return randomClockScrambleString();
  }
  for (const pin of pins) {
    if (randomUIntBelow(2) === 0) {
      moves.push(pin);
    }
  }
  return moves.join(" ");
}

// src/cubing/search/inside/solve/puzzles/wca-minx.ts
var randomUIntBelowPromise2 = randomUIntBelowFactory();
var suffixes = ["++", "--"];
async function randomMegaminxScrambleString() {
  const randomUIntBelow = await randomUIntBelowPromise2;
  function rdPair() {
    return `R${suffixes[randomUIntBelow(2)]} D${suffixes[randomUIntBelow(2)]}`;
  }
  function randomU() {
    return `U${["", "'"][randomUIntBelow(2)]}`;
  }
  function row() {
    const chunks2 = [];
    for (let i = 0; i < 5; i++) {
      chunks2.push(rdPair());
    }
    chunks2.push(randomU());
    return chunks2.join(" ");
  }
  const chunks = [];
  for (let i = 0; i < 6; i++) {
    chunks.push(row());
  }
  return chunks.join("\n");
}

// src/cubing/vendor/comlink-everywhere/outside/index.ts
import { wrap } from "comlink";
var worker_threads_mangled = "node:w-orker-_threa-ds";
var worker_threads_unmangled = () => worker_threads_mangled.replace(/-/g, "");
var useNodeWorkarounds = typeof globalThis.Worker === "undefined" && typeof globalThis.WorkerNavigator === "undefined";
async function nodeWorker(source, options) {
  const { Worker: NodeWorker } = await import(
    /* @vite-ignore */
    worker_threads_unmangled()
  );
  const worker = new NodeWorker(source, options);
  worker.unref();
  return node_adapter_default(worker);
}
async function constructWorker(source, options) {
  let worker;
  if (useNodeWorkarounds) {
    return nodeWorker(source, { eval: options?.eval });
  } else {
    if (options?.eval) {
      const blob = new Blob([source], {
        type: "application/javascript"
      });
      source = URL.createObjectURL(blob);
    }
    worker = new globalThis.Worker(source, {
      type: options ? options.type : void 0
    });
  }
  return worker;
}

// src/cubing/search/inside/search-worker-ts-entry-path-getter.ts
exposeAPI.expose = false;
async function getWorkerEntryFileURL() {
  return (await import("./search-worker-ts-entry-J3TDBCMV.js")).WORKER_ENTRY_FILE_URL;
}

// src/cubing/search/instantiator.ts
var MODULE_WORKER_TIMEOUT_MILLISECONDS = 5e3;
var forceStringWorker = false;
function setForceStringWorker(force) {
  forceStringWorker = force;
}
var disableStringWorker = false;
function setDisableStringWorker(disable) {
  disableStringWorker = disable;
}
async function instantiateModuleWorker() {
  return new Promise(async (resolve, reject) => {
    const timeoutID = setTimeout(() => {
      reject(new Error("module instantiation timeout"));
    }, MODULE_WORKER_TIMEOUT_MILLISECONDS);
    try {
      const workerEntryFileURL = await getWorkerEntryFileURL();
      if (!workerEntryFileURL) {
        reject(new Error("Could not get worker entry file URL."));
      }
      let url;
      if (globalThis.Worker) {
        const importSrc = `import "${workerEntryFileURL}";`;
        const blob = new Blob([importSrc], {
          type: "text/javascript"
        });
        url = URL.createObjectURL(blob);
      } else {
        url = new URL(workerEntryFileURL);
      }
      const worker = await constructWorker(url, {
        type: "module"
      });
      const onError = (e) => {
        if (e.message?.startsWith("SyntaxError")) {
          reject(e);
        }
      };
      const onFirstMessage = (messageData) => {
        if (messageData === "comlink-exposed") {
          clearTimeout(timeoutID);
          resolve(wrap(worker));
        } else {
          reject(new Error("wrong module instantiation message " + messageData));
        }
      };
      if (worker.nodeWorker) {
        worker.nodeWorker.once("message", onFirstMessage);
      } else {
        worker.addEventListener("error", onError, {
          once: true
        });
        worker.addEventListener("message", (e) => onFirstMessage(e.data), {
          once: true
        });
      }
    } catch (e) {
      reject(e);
    }
  });
}
async function instantiateClassicWorker() {
  const { workerSource } = await import("./search-worker-inside-generated-string-T43JGYSP.js");
  const worker = await constructWorker(workerSource, { eval: true });
  return wrap(worker);
}
async function instantiateWorker() {
  if (forceStringWorker) {
    console.warn("Using the `forceStringWorker` workaround for search worker instantiation. This will require downloading significantly more code than necessary, but the functionality will be the same.");
    return instantiateClassicWorker();
  }
  try {
    return await instantiateModuleWorker();
  } catch (e) {
    const commonErrorPrefix = "Could not instantiate module worker (this may happen in Firefox, with `bundle-global`, or when using Parcel).";
    if (disableStringWorker) {
      console.error(`${commonErrorPrefix} Fallback to string worker is disabled.`, e);
      throw new Error(`Module worker instantiation failed.`);
    }
    console.warn(`${commonErrorPrefix} Falling back to string worker.`, e);
    return instantiateClassicWorker();
  }
}

// src/cubing/search/outside.ts
var cachedWorkerInstance = null;
async function getCachedWorkerInstance() {
  return await (cachedWorkerInstance ?? (cachedWorkerInstance = instantiateWorker()));
}
async function randomScrambleForEvent(eventID) {
  switch (eventID) {
    case "clock":
      return Alg.fromString(await randomClockScrambleString());
    case "minx":
      return Alg.fromString(await randomMegaminxScrambleString());
  }
  const prom = _randomScrambleStringForEvent(eventID);
  const wat = await prom;
  return Alg.fromString(wat);
}
async function _randomScrambleStringForEvent(eventID) {
  const cwi = await getCachedWorkerInstance();
  return cwi.randomScrambleStringForEvent(eventID);
}
async function experimentalSolve3x3x3IgnoringCenters(state) {
  const cwi = await getCachedWorkerInstance();
  return Alg.fromString(await cwi.solve333ToString(state.stateData));
}
async function experimentalSolve2x2x2(state) {
  const cwi = await getCachedWorkerInstance();
  return Alg.fromString(await cwi.solve222ToString(state.stateData));
}
async function solveSkewb(state) {
  const cwi = await getCachedWorkerInstance();
  return Alg.fromString(await cwi.solveSkewbToString(state.stateData));
}
async function solvePyraminx(state) {
  const cwi = await getCachedWorkerInstance();
  return Alg.fromString(await cwi.solvePyraminxToString(state.stateData));
}
async function solveMegaminx(state) {
  const cwi = await getCachedWorkerInstance();
  return Alg.fromString(await cwi.solveMegaminxToString(state.stateData));
}
function setDebug(options) {
  const { logPerf, scramblePrefetchLevel } = options;
  if (typeof logPerf !== "undefined") {
    getCachedWorkerInstance().then((cwi) => cwi.setDebugMeasurePerf(logPerf));
  }
  if (typeof scramblePrefetchLevel !== "undefined") {
    getCachedWorkerInstance().then((cwi) => cwi.setScramblePrefetchLevel(scramblePrefetchLevel));
  }
  if ("forceStringWorker" in options) {
    setForceStringWorker(!!options.forceStringWorker);
  }
  if ("disableStringWorker" in options) {
    setDisableStringWorker(!!options.disableStringWorker);
  }
}

export {
  randomScrambleForEvent,
  experimentalSolve3x3x3IgnoringCenters,
  experimentalSolve2x2x2,
  solveSkewb,
  solvePyraminx,
  solveMegaminx,
  setDebug
};
//# sourceMappingURL=chunk-4V4RM3YJ.js.map
