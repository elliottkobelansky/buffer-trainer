{
  "version": 3,
  "sources": ["../../src/cubing/search/inside/solve/parseSGS.ts"],
  "sourcesContent": ["import { Alg } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\n\ninterface PieceReference {\n  orbitName: string;\n  permutationIdx: number;\n}\n\nexport interface SGSAction {\n  alg: Alg;\n  transformation: KTransformation;\n}\n\nexport interface SGSCachedData {\n  ordering: {\n    pieceOrdering: PieceReference[];\n    lookup: Record<string, SGSAction>;\n  }[];\n}\n\nexport function parseSGS(kpuzzle: KPuzzle, sgs: string): SGSCachedData {\n  const subgroupSizes: number[] = [];\n  const sgsActions: SGSAction[] = [];\n  for (const line of sgs.split(\"\\n\")) {\n    const lineTokens = line.split(\" \");\n    if (line.startsWith(\"SetOrder \")) {\n      // ignore\n    } else if (line.startsWith(\"Alg \")) {\n      const alg = Alg.fromString(line.substring(4));\n      sgsActions.push({\n        alg: alg,\n        transformation: kpuzzle.algToTransformation(alg),\n      });\n    } else if (line.startsWith(\"SubgroupSizes \")) {\n      for (let j = 1; j < lineTokens.length; j++) {\n        subgroupSizes.push(parseInt(lineTokens[j]));\n      }\n    }\n  }\n\n  const sgsCachedData: SGSCachedData = {\n    ordering: new Array(subgroupSizes.length),\n  };\n  const subgroupAlgOffsets: number[] = [];\n  let sum = 0;\n  subgroupAlgOffsets.push(0);\n  const emptyAlg = Alg.fromString(\"\");\n  const identity = kpuzzle.identityTransformation();\n  for (let i = 0; i < subgroupSizes.length; i++) {\n    sum += subgroupSizes[i];\n    subgroupAlgOffsets.push(sum);\n    sgsActions.splice(sum - 1, 0, { alg: emptyAlg, transformation: identity });\n  }\n  if (sgsActions.length !== sum) {\n    throw Error(\n      `Bad sgs; expected ${sum - subgroupSizes.length} algs but saw ${\n        sgsActions.length - subgroupSizes.length\n      }`,\n    );\n  }\n  const processedPieces: Record<string, boolean[]> = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition = kpuzzle.definition.orbits[orbitName];\n    processedPieces[orbitName] = new Array(orbitDefinition.numPieces).fill(\n      false,\n    );\n  }\n  for (let i = subgroupSizes.length - 1; i >= 0; i--) {\n    const pieceOrdering: PieceReference[] = [];\n    for (let j = subgroupAlgOffsets[i]; j < subgroupAlgOffsets[i + 1]; j++) {\n      const transformation = sgsActions[j].transformation;\n      for (const orbitName in kpuzzle.definition.orbits) {\n        const orbitDefinition = kpuzzle.definition.orbits[orbitName];\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientation[idx] !== 0\n          ) {\n            if (!processedPieces[orbitName][idx]) {\n              pieceOrdering.push({ orbitName: orbitName, permutationIdx: idx });\n              processedPieces[orbitName][idx] = true;\n            }\n          }\n        }\n      }\n    }\n    const lookup: Record<string, SGSAction> = {};\n    for (let j = subgroupAlgOffsets[i]; j < subgroupAlgOffsets[i + 1]; j++) {\n      const transformation = sgsActions[j].transformation.invert();\n      let key = \"\";\n      for (let k = 0; k < pieceOrdering.length; k++) {\n        const loc = pieceOrdering[k];\n        key = `${key} ${\n          transformation.transformationData[loc.orbitName].permutation[\n            loc.permutationIdx\n          ]\n        } ${\n          transformation.transformationData[loc.orbitName].orientation[\n            loc.permutationIdx\n          ]\n        }`;\n      }\n      lookup[key] = sgsActions[j];\n      sgsActions[j].alg = sgsActions[j].alg.invert();\n      sgsActions[j].transformation = sgsActions[j].transformation.invert();\n    }\n    sgsCachedData.ordering[i] = {\n      pieceOrdering: pieceOrdering,\n      lookup: lookup,\n    };\n  }\n  return sgsCachedData;\n}\n"],
  "mappings": ";;;;;AAoBO,kBAAkB,SAAkB,KAA4B;AACrE,QAAM,gBAA0B,CAAC;AACjC,QAAM,aAA0B,CAAC;AACjC,aAAW,QAAQ,IAAI,MAAM,IAAI,GAAG;AAClC,UAAM,aAAa,KAAK,MAAM,GAAG;AACjC,QAAI,KAAK,WAAW,WAAW,GAAG;AAAA,IAElC,WAAW,KAAK,WAAW,MAAM,GAAG;AAClC,YAAM,MAAM,IAAI,WAAW,KAAK,UAAU,CAAC,CAAC;AAC5C,iBAAW,KAAK;AAAA,QACd;AAAA,QACA,gBAAgB,QAAQ,oBAAoB,GAAG;AAAA,MACjD,CAAC;AAAA,IACH,WAAW,KAAK,WAAW,gBAAgB,GAAG;AAC5C,eAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,sBAAc,KAAK,SAAS,WAAW,EAAE,CAAC;AAAA,MAC5C;AAAA,IACF;AAAA,EACF;AAEA,QAAM,gBAA+B;AAAA,IACnC,UAAU,IAAI,MAAM,cAAc,MAAM;AAAA,EAC1C;AACA,QAAM,qBAA+B,CAAC;AACtC,MAAI,MAAM;AACV,qBAAmB,KAAK,CAAC;AACzB,QAAM,WAAW,IAAI,WAAW,EAAE;AAClC,QAAM,WAAW,QAAQ,uBAAuB;AAChD,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,WAAO,cAAc;AACrB,uBAAmB,KAAK,GAAG;AAC3B,eAAW,OAAO,MAAM,GAAG,GAAG,EAAE,KAAK,UAAU,gBAAgB,SAAS,CAAC;AAAA,EAC3E;AACA,MAAI,WAAW,WAAW,KAAK;AAC7B,UAAM,MACJ,qBAAqB,MAAM,cAAc,uBACvC,WAAW,SAAS,cAAc,QAEtC;AAAA,EACF;AACA,QAAM,kBAA6C,CAAC;AACpD,aAAW,aAAa,QAAQ,WAAW,QAAQ;AACjD,UAAM,kBAAkB,QAAQ,WAAW,OAAO;AAClD,oBAAgB,aAAa,IAAI,MAAM,gBAAgB,SAAS,EAAE,KAChE,KACF;AAAA,EACF;AACA,WAAS,IAAI,cAAc,SAAS,GAAG,KAAK,GAAG,KAAK;AAClD,UAAM,gBAAkC,CAAC;AACzC,aAAS,IAAI,mBAAmB,IAAI,IAAI,mBAAmB,IAAI,IAAI,KAAK;AACtE,YAAM,iBAAiB,WAAW,GAAG;AACrC,iBAAW,aAAa,QAAQ,WAAW,QAAQ;AACjD,cAAM,kBAAkB,QAAQ,WAAW,OAAO;AAClD,iBAAS,MAAM,GAAG,MAAM,gBAAgB,WAAW,OAAO;AACxD,cACE,eAAe,mBAAmB,WAAW,YAAY,SACvD,OACF,eAAe,mBAAmB,WAAW,YAAY,SAAS,GAClE;AACA,gBAAI,CAAC,gBAAgB,WAAW,MAAM;AACpC,4BAAc,KAAK,EAAE,WAAsB,gBAAgB,IAAI,CAAC;AAChE,8BAAgB,WAAW,OAAO;AAAA,YACpC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,UAAM,SAAoC,CAAC;AAC3C,aAAS,IAAI,mBAAmB,IAAI,IAAI,mBAAmB,IAAI,IAAI,KAAK;AACtE,YAAM,iBAAiB,WAAW,GAAG,eAAe,OAAO;AAC3D,UAAI,MAAM;AACV,eAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,cAAM,MAAM,cAAc;AAC1B,cAAM,GAAG,OACP,eAAe,mBAAmB,IAAI,WAAW,YAC/C,IAAI,mBAGN,eAAe,mBAAmB,IAAI,WAAW,YAC/C,IAAI;AAAA,MAGV;AACA,aAAO,OAAO,WAAW;AACzB,iBAAW,GAAG,MAAM,WAAW,GAAG,IAAI,OAAO;AAC7C,iBAAW,GAAG,iBAAiB,WAAW,GAAG,eAAe,OAAO;AAAA,IACrE;AACA,kBAAc,SAAS,KAAK;AAAA,MAC1B;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;",
  "names": []
}
