import {
  from
} from "./chunk-GVPTO3OF.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper
} from "./chunk-MGJA5U5O.js";

// src/cubing/twisty/model/PromiseFreshener.ts
var _latestAssignedIdx, _latestResolvedIdx;
var PromiseFreshener = class {
  constructor() {
    __privateAdd(this, _latestAssignedIdx, 0);
    __privateAdd(this, _latestResolvedIdx, 0);
  }
  async queue(p) {
    const idx = ++__privateWrapper(this, _latestAssignedIdx)._;
    const result = await p;
    if (idx > __privateGet(this, _latestResolvedIdx)) {
      __privateSet(this, _latestResolvedIdx, idx);
      return {
        fresh: true,
        result
      };
    } else {
      return { fresh: false };
    }
  }
};
_latestAssignedIdx = new WeakMap();
_latestResolvedIdx = new WeakMap();
var _latestAssignedIdx2, _latestResolvedIdx2;
var StaleDropper = class {
  constructor() {
    __privateAdd(this, _latestAssignedIdx2, 0);
    __privateAdd(this, _latestResolvedIdx2, 0);
  }
  queue(p) {
    return new Promise(async (resolve, reject) => {
      try {
        const idx = ++__privateWrapper(this, _latestAssignedIdx2)._;
        const result = await p;
        if (idx > __privateGet(this, _latestResolvedIdx2)) {
          __privateSet(this, _latestResolvedIdx2, idx);
          resolve(result);
        }
      } catch (e) {
        reject(e);
      }
    });
  }
};
_latestAssignedIdx2 = new WeakMap();
_latestResolvedIdx2 = new WeakMap();

// src/cubing/twisty/model/props/TwistyProp.ts
var globalSourceGeneration = 0;
var _children, _rawListeners, _scheduleRawDispatch, scheduleRawDispatch_fn, _rawDispatchPending, _dispatchRawListeners, dispatchRawListeners_fn, _freshListeners;
var TwistyPropParent = class {
  constructor() {
    __privateAdd(this, _scheduleRawDispatch);
    __privateAdd(this, _dispatchRawListeners);
    __privateAdd(this, _children, /* @__PURE__ */ new Set());
    this.lastSourceGeneration = 0;
    __privateAdd(this, _rawListeners, /* @__PURE__ */ new Set());
    __privateAdd(this, _rawDispatchPending, false);
    __privateAdd(this, _freshListeners, /* @__PURE__ */ new Map());
  }
  canReuse(v1, v2) {
    return v1 === v2 || this.canReuseValue(v1, v2);
  }
  canReuseValue(_v1, _v2) {
    return false;
  }
  debugGetChildren() {
    return Array.from(__privateGet(this, _children).values());
  }
  addChild(child) {
    __privateGet(this, _children).add(child);
  }
  removeChild(child) {
    __privateGet(this, _children).delete(child);
  }
  markStale(sourceEvent) {
    if (sourceEvent.detail.generation !== globalSourceGeneration) {
      throw new Error("A TwistyProp was marked stale too late!");
    }
    if (this.lastSourceGeneration === sourceEvent.detail.generation) {
      return;
    }
    this.lastSourceGeneration = sourceEvent.detail.generation;
    for (const child of __privateGet(this, _children)) {
      child.markStale(sourceEvent);
    }
    __privateMethod(this, _scheduleRawDispatch, scheduleRawDispatch_fn).call(this);
  }
  addRawListener(listener, options) {
    __privateGet(this, _rawListeners).add(listener);
    if (options?.initial) {
      listener();
    }
  }
  removeRawListener(listener) {
    __privateGet(this, _rawListeners).delete(listener);
  }
  addFreshListener(listener) {
    const staleDropper = new StaleDropper();
    let lastResult = null;
    const callback = async () => {
      const result = await staleDropper.queue(this.get());
      if (lastResult !== null && this.canReuse(lastResult, result)) {
        return;
      }
      lastResult = result;
      listener(result);
    };
    __privateGet(this, _freshListeners).set(listener, callback);
    this.addRawListener(callback, { initial: true });
  }
  removeFreshListener(listener) {
    this.removeRawListener(__privateGet(this, _freshListeners).get(listener));
    __privateGet(this, _freshListeners).delete(listener);
  }
};
_children = new WeakMap();
_rawListeners = new WeakMap();
_scheduleRawDispatch = new WeakSet();
scheduleRawDispatch_fn = function() {
  if (!__privateGet(this, _rawDispatchPending)) {
    __privateSet(this, _rawDispatchPending, true);
    setTimeout(() => __privateMethod(this, _dispatchRawListeners, dispatchRawListeners_fn).call(this), 0);
  }
};
_rawDispatchPending = new WeakMap();
_dispatchRawListeners = new WeakSet();
dispatchRawListeners_fn = function() {
  if (!__privateGet(this, _rawDispatchPending)) {
    throw new Error("Invalid dispatch state!");
  }
  for (const listener of __privateGet(this, _rawListeners)) {
    listener();
  }
  __privateSet(this, _rawDispatchPending, false);
};
_freshListeners = new WeakMap();
var _value;
var TwistyPropSource = class extends TwistyPropParent {
  constructor(initialValue) {
    super();
    __privateAdd(this, _value, void 0);
    __privateSet(this, _value, from(() => this.getDefaultValue()));
    if (initialValue) {
      __privateSet(this, _value, this.deriveFromPromiseOrValue(initialValue, __privateGet(this, _value)));
    }
  }
  set(input) {
    __privateSet(this, _value, this.deriveFromPromiseOrValue(input, __privateGet(this, _value)));
    const sourceEventDetail = {
      sourceProp: this,
      value: __privateGet(this, _value),
      generation: ++globalSourceGeneration
    };
    this.markStale(new CustomEvent("stale", {
      detail: sourceEventDetail
    }));
  }
  async get() {
    return __privateGet(this, _value);
  }
  async deriveFromPromiseOrValue(input, oldValuePromise) {
    return this.derive(await input, oldValuePromise);
  }
};
_value = new WeakMap();
var SimpleTwistyPropSource = class extends TwistyPropSource {
  derive(input) {
    return input;
  }
};
var NO_VALUE = Symbol("no value");
var _parents, _cachedLastSuccessfulCalculation, _cachedLatestGenerationCalculation, _getParents, getParents_fn, _cacheDerive, cacheDerive_fn;
var TwistyPropDerived = class extends TwistyPropParent {
  constructor(parents, userVisibleErrorTracker) {
    super();
    this.userVisibleErrorTracker = userVisibleErrorTracker;
    __privateAdd(this, _getParents);
    __privateAdd(this, _cacheDerive);
    __privateAdd(this, _parents, void 0);
    __privateAdd(this, _cachedLastSuccessfulCalculation, null);
    __privateAdd(this, _cachedLatestGenerationCalculation, null);
    __privateSet(this, _parents, parents);
    for (const parent of Object.values(parents)) {
      parent.addChild(this);
    }
  }
  async get() {
    const generation = this.lastSourceGeneration;
    if (__privateGet(this, _cachedLatestGenerationCalculation)?.generation === generation) {
      return __privateGet(this, _cachedLatestGenerationCalculation).output;
    }
    const latestGenerationCalculation = {
      generation,
      output: __privateMethod(this, _cacheDerive, cacheDerive_fn).call(this, __privateMethod(this, _getParents, getParents_fn).call(this), generation, __privateGet(this, _cachedLastSuccessfulCalculation))
    };
    __privateSet(this, _cachedLatestGenerationCalculation, latestGenerationCalculation);
    this.userVisibleErrorTracker?.reset();
    return latestGenerationCalculation.output;
  }
};
_parents = new WeakMap();
_cachedLastSuccessfulCalculation = new WeakMap();
_cachedLatestGenerationCalculation = new WeakMap();
_getParents = new WeakSet();
getParents_fn = async function() {
  const inputValuePromises = {};
  for (const [key, parent] of Object.entries(__privateGet(this, _parents))) {
    inputValuePromises[key] = parent.get();
  }
  const inputs = {};
  for (const key in __privateGet(this, _parents)) {
    inputs[key] = await inputValuePromises[key];
  }
  return inputs;
};
_cacheDerive = new WeakSet();
cacheDerive_fn = async function(inputsPromise, generation, cachedLatestGenerationCalculation = null) {
  const inputs = await inputsPromise;
  const cache = (output) => {
    __privateSet(this, _cachedLastSuccessfulCalculation, {
      inputs,
      output: Promise.resolve(output),
      generation
    });
    return output;
  };
  if (!cachedLatestGenerationCalculation) {
    return cache(await this.derive(inputs));
  }
  const cachedInputs = cachedLatestGenerationCalculation.inputs;
  for (const key in __privateGet(this, _parents)) {
    const parent = __privateGet(this, _parents)[key];
    if (!parent.canReuse(inputs[key], cachedInputs[key])) {
      return cache(await this.derive(inputs));
    }
  }
  return cachedLatestGenerationCalculation.output;
};
var _disconnectionFunctions;
var FreshListenerManager = class {
  constructor() {
    __privateAdd(this, _disconnectionFunctions, []);
  }
  addListener(prop, listener) {
    let disconnected = false;
    const wrappedListener = (value) => {
      if (disconnected) {
        return;
      }
      listener(value);
    };
    prop.addFreshListener(wrappedListener);
    __privateGet(this, _disconnectionFunctions).push(() => {
      prop.removeFreshListener(wrappedListener);
      disconnected = true;
    });
  }
  addMultiListener3(props, listener) {
    this.addMultiListener(props, listener);
  }
  addMultiListener(props, listener) {
    let disconnected = false;
    let initialIgnoresLeft = props.length - 1;
    const wrappedListener = async (_) => {
      if (initialIgnoresLeft > 0) {
        initialIgnoresLeft--;
        return;
      }
      if (disconnected) {
        return;
      }
      const promises = props.map((prop) => prop.get());
      const values = await Promise.all(promises);
      listener(values);
    };
    for (const prop of props) {
      prop.addFreshListener(wrappedListener);
    }
    __privateGet(this, _disconnectionFunctions).push(() => {
      for (const prop of props) {
        prop.removeFreshListener(wrappedListener);
      }
      disconnected = true;
    });
  }
  disconnect() {
    for (const disconnectionFunction of __privateGet(this, _disconnectionFunctions)) {
      disconnectionFunction();
    }
  }
};
_disconnectionFunctions = new WeakMap();

// src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts
var hintFaceletStyles = {
  floating: true,
  none: true
};
var HintFaceletProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/views/3D/TAU.ts
var TAU = Math.PI * 2;
var DEGREES_PER_RADIAN = 360 / TAU;

// src/cubing/twisty/heavy-code-imports/3d.ts
var cachedConstructorProxy = null;
async function proxy3D() {
  return cachedConstructorProxy ?? (cachedConstructorProxy = import("./twisty-dynamic-3d-UQJETF7O.js"));
}
var THREEJS = from(async () => (await proxy3D()).T3I);

export {
  StaleDropper,
  TwistyPropSource,
  SimpleTwistyPropSource,
  NO_VALUE,
  TwistyPropDerived,
  FreshListenerManager,
  hintFaceletStyles,
  HintFaceletProp,
  TAU,
  DEGREES_PER_RADIAN,
  proxy3D,
  THREEJS
};
//# sourceMappingURL=chunk-7BLWQDZX.js.map
