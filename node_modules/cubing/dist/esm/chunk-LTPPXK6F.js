import {
  KPuzzle,
  KState
} from "./chunk-UP6RBLG2.js";
import {
  Alg
} from "./chunk-GXZIBFSN.js";

// src/cubing/puzzles/stickerings/appearance.ts
function getFaceletAppearance(appearance, orbitName, pieceIdx, faceletIdx, hint) {
  const orbitAppearance = appearance.orbits[orbitName];
  const pieceAppearance = orbitAppearance.pieces[pieceIdx];
  if (pieceAppearance === null) {
    return regular;
  }
  const faceletAppearance = pieceAppearance.facelets[faceletIdx];
  if (faceletAppearance === null) {
    return regular;
  }
  if (typeof faceletAppearance === "string") {
    return faceletAppearance;
  }
  if (hint) {
    return faceletAppearance.hintAppearance ?? faceletAppearance.appearance;
  }
  return faceletAppearance.appearance;
}
var PieceAnnotation = class {
  constructor(kpuzzle, defaultValue) {
    this.stickerings = /* @__PURE__ */ new Map();
    for (const [orbitName, orbitDef] of Object.entries(kpuzzle.definition.orbits)) {
      this.stickerings.set(orbitName, new Array(orbitDef.numPieces).fill(defaultValue));
    }
  }
};
var regular = "regular";
var ignored = "ignored";
var oriented = "oriented";
var invisible = "invisible";
var dim = "dim";
var r = {
  facelets: [regular, regular, regular, regular, regular]
};
var i = {
  facelets: [ignored, ignored, ignored, ignored, ignored]
};
var o = {
  facelets: [oriented, oriented, oriented, oriented, oriented]
};
var invisiblePiece = {
  facelets: [invisible, invisible, invisible, invisible]
};
var riiii = {
  facelets: [regular, ignored, ignored, ignored, ignored]
};
var drrrr = {
  facelets: [dim, regular, regular, regular, regular]
};
var d = {
  facelets: [dim, dim, dim, dim, dim]
};
var diiii = {
  facelets: [dim, ignored, ignored, ignored, ignored]
};
var oiiii = {
  facelets: [oriented, ignored, ignored, ignored, ignored]
};
function getPieceAppearance(pieceStickering) {
  switch (pieceStickering) {
    case "Regular" /* Regular */:
      return r;
    case "Dim" /* Dim */:
      return d;
    case "Ignored" /* Ignored */:
      return i;
    case "OrientationStickers" /* OrientationStickers */:
      return o;
    case "Invisible" /* Invisible */:
      return invisiblePiece;
    case "IgnoreNonPrimary" /* IgnoreNonPrimary */:
      return riiii;
    case "PermuteNonPrimary" /* PermuteNonPrimary */:
      return drrrr;
    case "Ignoriented" /* Ignoriented */:
      return diiii;
    case "OrientationWithoutPermutation" /* OrientationWithoutPermutation */:
      return oiiii;
  }
}
var PuzzleStickering = class extends PieceAnnotation {
  constructor(kpuzzle) {
    super(kpuzzle, "Regular" /* Regular */);
  }
  set(pieceSet, pieceStickering) {
    for (const [orbitName, pieces] of this.stickerings.entries()) {
      for (let i2 = 0; i2 < pieces.length; i2++) {
        if (pieceSet.stickerings.get(orbitName)[i2]) {
          pieces[i2] = pieceStickering;
        }
      }
    }
    return this;
  }
  toAppearance() {
    const appearance = { orbits: {} };
    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {
      const pieces = [];
      const orbitAppearance = {
        pieces
      };
      appearance.orbits[orbitName] = orbitAppearance;
      for (const pieceStickering of pieceStickerings) {
        pieces.push(getPieceAppearance(pieceStickering));
      }
    }
    return appearance;
  }
};
var StickeringManager = class {
  constructor(kpuzzle) {
    this.kpuzzle = kpuzzle;
  }
  and(pieceSets) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      pieceLoop:
        for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
          newPieceSet.stickerings.get(orbitName)[i2] = true;
          for (const pieceSet of pieceSets) {
            if (!pieceSet.stickerings.get(orbitName)[i2]) {
              newPieceSet.stickerings.get(orbitName)[i2] = false;
              continue pieceLoop;
            }
          }
        }
    }
    return newPieceSet;
  }
  or(pieceSets) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      pieceLoop:
        for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
          newPieceSet.stickerings.get(orbitName)[i2] = false;
          for (const pieceSet of pieceSets) {
            if (pieceSet.stickerings.get(orbitName)[i2]) {
              newPieceSet.stickerings.get(orbitName)[i2] = true;
              continue pieceLoop;
            }
          }
        }
    }
    return newPieceSet;
  }
  not(pieceSet) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
        newPieceSet.stickerings.get(orbitName)[i2] = !pieceSet.stickerings.get(orbitName)[i2];
      }
    }
    return newPieceSet;
  }
  all() {
    return this.and(this.moves([]));
  }
  move(moveSource) {
    const transformation = this.kpuzzle.moveToTransformation(moveSource);
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
        if (transformation.transformationData[orbitName].permutation[i2] !== i2 || transformation.transformationData[orbitName].orientation[i2] !== 0) {
          newPieceSet.stickerings.get(orbitName)[i2] = true;
        }
      }
    }
    return newPieceSet;
  }
  moves(moveSources) {
    return moveSources.map((moveSource) => this.move(moveSource));
  }
  orbits(orbitNames) {
    const pieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const orbitName of orbitNames) {
      pieceSet.stickerings.get(orbitName).fill(true);
    }
    return pieceSet;
  }
};

// src/cubing/puzzles/stickerings/puzzle-stickerings.ts
var experimentalStickerings = {
  "full": { groups: { "3x3x3": "Stickering" } },
  "OLL": { groups: { "3x3x3": "Last Layer" } },
  "PLL": { groups: { "3x3x3": "Last Layer" } },
  "LL": { groups: { "3x3x3": "Last Layer" } },
  "COLL": { groups: { "3x3x3": "Last Layer" } },
  "OCLL": { groups: { "3x3x3": "Last Layer" } },
  "CLL": { groups: { "3x3x3": "Last Layer" } },
  "ELL": { groups: { "3x3x3": "Last Layer" } },
  "ZBLL": { groups: { "3x3x3": "Last Layer" } },
  "LS": { groups: { "3x3x3": "Last Slot" } },
  "ELS": { groups: { "3x3x3": "Last Slot" } },
  "CLS": { groups: { "3x3x3": "Last Slot" } },
  "ZBLS": { groups: { "3x3x3": "Last Slot" } },
  "VLS": { groups: { "3x3x3": "Last Slot" } },
  "WVLS": { groups: { "3x3x3": "Last Slot" } },
  "F2L": { groups: { "3x3x3": "CFOP (Fridrich)" } },
  "Daisy": { groups: { "3x3x3": "CFOP (Fridrich)" } },
  "Cross": { groups: { "3x3x3": "CFOP (Fridrich)" } },
  "EO": { groups: { "3x3x3": "ZZ" } },
  "EOline": { groups: { "3x3x3": "ZZ" } },
  "EOcross": { groups: { "3x3x3": "ZZ" } },
  "CMLL": { groups: { "3x3x3": "Roux" } },
  "L10P": { groups: { "3x3x3": "Roux" } },
  "L6E": { groups: { "3x3x3": "Roux" } },
  "L6EO": { groups: { "3x3x3": "Roux" } },
  "2x2x2": { groups: { "3x3x3": "Petrus" } },
  "2x2x3": { groups: { "3x3x3": "Petrus" } },
  "Void Cube": { groups: { "3x3x3": "Miscellaneous" } },
  "invisible": { groups: { "3x3x3": "Miscellaneous" } },
  "picture": { groups: { "3x3x3": "Miscellaneous" } },
  "centers-only": { groups: { "3x3x3": "Miscellaneous" } },
  "experimental-centers-U": {},
  "experimental-centers-U-D": {},
  "experimental-centers-U-L-D": {},
  "experimental-centers-U-L-B-D": {},
  "experimental-centers": {},
  "experimental-fto-fc": { groups: { fto: "Bencisco" } },
  "experimental-fto-f2t": { groups: { fto: "Bencisco" } },
  "experimental-fto-sc": { groups: { fto: "Bencisco" } },
  "experimental-fto-l2c": { groups: { fto: "Bencisco" } },
  "experimental-fto-lbt": { groups: { fto: "Bencisco" } },
  "experimental-fto-l3t": { groups: { fto: "Bencisco" } }
};

// src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts
var cube3x3x3KPuzzleDefinition = {
  name: "3x3x3",
  orbits: {
    EDGES: { numPieces: 12, numOrientations: 2 },
    CORNERS: { numPieces: 8, numOrientations: 3 },
    CENTERS: { numPieces: 6, numOrientations: 4 }
  },
  startStateData: {
    EDGES: {
      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    CORNERS: {
      pieces: [0, 1, 2, 3, 4, 5, 6, 7],
      orientation: [0, 0, 0, 0, 0, 0, 0, 0]
    },
    CENTERS: {
      pieces: [0, 1, 2, 3, 4, 5],
      orientation: [0, 0, 0, 0, 0, 0]
    }
  },
  moves: {
    U: {
      EDGES: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [1, 0, 0, 0, 0, 0]
      }
    },
    y: {
      EDGES: {
        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 7, 4, 5, 6],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 2, 3, 4, 1, 5],
        orientation: [1, 0, 0, 0, 0, 3]
      }
    },
    x: {
      EDGES: {
        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 3, 5, 7, 6, 2, 1],
        orientation: [2, 1, 2, 1, 1, 2, 1, 2]
      },
      CENTERS: {
        permutation: [2, 1, 5, 3, 0, 4],
        orientation: [0, 3, 0, 1, 2, 2]
      }
    },
    L: {
      EDGES: {
        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 6, 2, 4, 3, 5, 7],
        orientation: [0, 0, 2, 1, 0, 2, 1, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 1, 0, 0, 0, 0]
      }
    },
    F: {
      EDGES: {
        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],
        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0]
      },
      CORNERS: {
        permutation: [3, 1, 2, 5, 0, 4, 6, 7],
        orientation: [1, 0, 0, 2, 2, 1, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 1, 0, 0, 0]
      }
    },
    R: {
      EDGES: {
        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 2, 3, 7, 5, 6, 1],
        orientation: [2, 1, 0, 0, 1, 0, 0, 2]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 1, 0, 0]
      }
    },
    B: {
      EDGES: {
        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],
        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1]
      },
      CORNERS: {
        permutation: [0, 7, 1, 3, 4, 5, 2, 6],
        orientation: [0, 2, 1, 0, 0, 0, 2, 1]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 0, 1, 0]
      }
    },
    D: {
      EDGES: {
        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 5, 6, 7, 4],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 0, 0, 1]
      }
    },
    z: {
      EDGES: {
        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],
        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [3, 2, 6, 5, 0, 4, 7, 1],
        orientation: [1, 2, 1, 2, 2, 1, 2, 1]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 1, 1, 3, 1]
      }
    },
    M: {
      EDGES: {
        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [4, 1, 0, 3, 5, 2],
        orientation: [2, 0, 0, 0, 2, 0]
      }
    },
    E: {
      EDGES: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 4, 1, 2, 3, 5],
        orientation: [0, 0, 0, 0, 0, 0]
      }
    },
    S: {
      EDGES: {
        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],
        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 0, 1, 0, 1]
      }
    },
    u: {
      EDGES: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 2, 3, 4, 1, 5],
        orientation: [1, 0, 0, 0, 0, 0]
      }
    },
    l: {
      EDGES: {
        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 6, 2, 4, 3, 5, 7],
        orientation: [0, 0, 2, 1, 0, 2, 1, 0]
      },
      CENTERS: {
        permutation: [4, 1, 0, 3, 5, 2],
        orientation: [2, 1, 0, 0, 2, 0]
      }
    },
    f: {
      EDGES: {
        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],
        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0]
      },
      CORNERS: {
        permutation: [3, 1, 2, 5, 0, 4, 6, 7],
        orientation: [1, 0, 0, 2, 2, 1, 0, 0]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 1, 1, 0, 1]
      }
    },
    r: {
      EDGES: {
        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 2, 3, 7, 5, 6, 1],
        orientation: [2, 1, 0, 0, 1, 0, 0, 2]
      },
      CENTERS: {
        permutation: [2, 1, 5, 3, 0, 4],
        orientation: [0, 0, 0, 1, 2, 2]
      }
    },
    b: {
      EDGES: {
        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],
        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1]
      },
      CORNERS: {
        permutation: [0, 7, 1, 3, 4, 5, 2, 6],
        orientation: [0, 2, 1, 0, 0, 0, 2, 1]
      },
      CENTERS: {
        permutation: [3, 0, 2, 5, 4, 1],
        orientation: [3, 3, 0, 3, 1, 3]
      }
    },
    d: {
      EDGES: {
        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 5, 6, 7, 4],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 4, 1, 2, 3, 5],
        orientation: [0, 0, 0, 0, 0, 1]
      }
    }
  }
};
cube3x3x3KPuzzleDefinition.moves["Uw"] = cube3x3x3KPuzzleDefinition.moves["u"];
cube3x3x3KPuzzleDefinition.moves["Lw"] = cube3x3x3KPuzzleDefinition.moves["l"];
cube3x3x3KPuzzleDefinition.moves["Fw"] = cube3x3x3KPuzzleDefinition.moves["f"];
cube3x3x3KPuzzleDefinition.moves["Rw"] = cube3x3x3KPuzzleDefinition.moves["r"];
cube3x3x3KPuzzleDefinition.moves["Bw"] = cube3x3x3KPuzzleDefinition.moves["b"];
cube3x3x3KPuzzleDefinition.moves["Dw"] = cube3x3x3KPuzzleDefinition.moves["d"];
cube3x3x3KPuzzleDefinition.moves["Rv"] = cube3x3x3KPuzzleDefinition.moves["x"];
cube3x3x3KPuzzleDefinition.moves["Uv"] = cube3x3x3KPuzzleDefinition.moves["y"];
cube3x3x3KPuzzleDefinition.moves["Fv"] = cube3x3x3KPuzzleDefinition.moves["z"];
cube3x3x3KPuzzleDefinition.moves["Lv"] = {
  EDGES: {
    permutation: [2, 10, 6, 11, 0, 8, 4, 9, 1, 3, 5, 7],
    orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
  },
  CORNERS: {
    permutation: [1, 7, 6, 2, 0, 3, 5, 4],
    orientation: [2, 1, 2, 1, 1, 2, 1, 2]
  },
  CENTERS: {
    permutation: [4, 1, 0, 3, 5, 2],
    orientation: [2, 1, 0, 3, 2, 0]
  }
};
cube3x3x3KPuzzleDefinition.moves["Dv"] = {
  EDGES: {
    permutation: [3, 0, 1, 2, 7, 4, 5, 6, 9, 11, 8, 10],
    orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
  },
  CORNERS: {
    permutation: [3, 0, 1, 2, 5, 6, 7, 4],
    orientation: [0, 0, 0, 0, 0, 0, 0, 0]
  },
  CENTERS: {
    permutation: [0, 4, 1, 2, 3, 5],
    orientation: [3, 0, 0, 0, 0, 1]
  }
};
cube3x3x3KPuzzleDefinition.moves["Bv"] = {
  EDGES: {
    permutation: [8, 5, 10, 1, 9, 7, 11, 3, 4, 0, 6, 2],
    orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
  },
  CORNERS: {
    permutation: [4, 7, 1, 0, 5, 3, 2, 6],
    orientation: [1, 2, 1, 2, 2, 1, 2, 1]
  },
  CENTERS: {
    permutation: [3, 0, 2, 5, 4, 1],
    orientation: [3, 3, 3, 3, 1, 3]
  }
};

// src/cubing/puzzles/customPGPuzzleLoader.ts
async function descAsyncGetPuzzleGeometry(desc) {
  const puzzleGeometry = await import("./puzzle-geometry/index.js");
  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {
    allMoves: true,
    orientCenters: true,
    addRotations: true
  });
}
async function asyncGetKPuzzle(desc) {
  const pg = await descAsyncGetPuzzleGeometry(desc);
  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);
  kpuzzleDefinition.name = `description: ${desc}`;
  const puzzleGeometry = await import("./puzzle-geometry/index.js");
  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
  return new KPuzzle(kpuzzleDefinition, {
    experimentalPGNotation: pgNotation
  });
}
var nextCustomID = 1;
function customPGPuzzleLoader(desc, info) {
  const customID = nextCustomID++;
  let cachedKPuzzle = null;
  const puzzleLoader = {
    id: `custom-${customID}`,
    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,
    kpuzzle: async () => {
      return cachedKPuzzle ?? (cachedKPuzzle = asyncGetKPuzzle(desc));
    },
    svg: async () => {
      const pg = await descAsyncGetPuzzleGeometry(desc);
      return pg.generatesvg();
    },
    pg: async () => {
      return descAsyncGetPuzzleGeometry(desc);
    }
  };
  if (info?.inventedBy) {
    puzzleLoader.inventedBy = info.inventedBy;
  }
  if (info?.inventionYear) {
    puzzleLoader.inventionYear = info.inventionYear;
  }
  return puzzleLoader;
}

// src/cubing/puzzles/cubing-private/index.ts
var experimental3x3x3KPuzzle = new KPuzzle(cube3x3x3KPuzzleDefinition);
cube3x3x3KPuzzleDefinition.experimentalIsStateSolved = experimentalIs3x3x3Solved;

// src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts
function puzzleOrientation3x3x3Idx(state) {
  const idxU = state.stateData["CENTERS"].pieces[0];
  const idxD = state.stateData["CENTERS"].pieces[5];
  const unadjustedIdxL = state.stateData["CENTERS"].pieces[1];
  let idxL = unadjustedIdxL;
  if (idxU < unadjustedIdxL) {
    idxL--;
  }
  if (idxD < unadjustedIdxL) {
    idxL--;
  }
  return [idxU, idxL];
}
var puzzleOrientationCacheRaw = new Array(6).fill(0).map(() => {
  return new Array(6);
});
var puzzleOrientationCacheInitialized = false;
function puzzleOrientation3x3x3Cache() {
  if (!puzzleOrientationCacheInitialized) {
    {
      const uAlgs = ["", "z", "x", "z'", "x'", "x2"].map((s) => Alg.fromString(s));
      const yAlg = new Alg("y");
      for (const uAlg of uAlgs) {
        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);
        for (let i2 = 0; i2 < 4; i2++) {
          transformation = transformation.applyAlg(yAlg);
          const [idxU, idxL] = puzzleOrientation3x3x3Idx(transformation.toKState());
          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();
        }
      }
    }
  }
  return puzzleOrientationCacheRaw;
}
function normalize3x3x3Orientation(state) {
  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);
  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];
  return state.applyTransformation(orientationTransformation);
}
function experimentalIs3x3x3Solved(state, options) {
  if (options.ignorePuzzleOrientation) {
    state = normalize3x3x3Orientation(state);
  }
  if (options.ignoreCenterOrientation) {
    state = new KState(state.kpuzzle, {
      EDGES: state.stateData.EDGES,
      CORNERS: state.stateData.CORNERS,
      CENTERS: {
        pieces: state.stateData.CENTERS.pieces,
        orientation: new Array(6).fill(0)
      }
    });
  }
  return !!state.experimentalToTransformation()?.isIdentityTransformation();
}

export {
  getFaceletAppearance,
  PuzzleStickering,
  StickeringManager,
  experimentalStickerings,
  puzzleOrientation3x3x3Idx,
  puzzleOrientation3x3x3Cache,
  normalize3x3x3Orientation,
  customPGPuzzleLoader,
  experimental3x3x3KPuzzle
};
//# sourceMappingURL=chunk-LTPPXK6F.js.map
