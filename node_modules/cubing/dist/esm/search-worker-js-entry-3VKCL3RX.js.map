{
  "version": 3,
  "sources": ["../../src/cubing/search/inside/solve/tremble.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/sgs-side-events/index.ts", "../../src/cubing/search/inside/solve/puzzles/2x2x2.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/4x4x4/index.ts", "../../src/cubing/search/inside/solve/puzzles/4x4x4.ts", "../../src/cubing/search/inside/solve/puzzles/big-cubes.ts", "../../src/cubing/search/inside/solve/puzzles/5x5x5.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/fto/index.ts", "../../src/cubing/search/inside/solve/puzzles/fto.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/kilominx/index.ts", "../../src/cubing/search/inside/solve/puzzles/kilominx.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/master_tetraminx/index.ts", "../../src/cubing/search/inside/solve/puzzles/master_tetraminx.ts", "../../src/cubing/search/inside/solve/puzzles/megaminx.ts", "../../src/cubing/search/inside/solve/puzzles/pyraminx.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/sgs-unofficial/index.ts", "../../src/cubing/search/inside/solve/puzzles/redi_cube.ts", "../../src/cubing/search/inside/solve/puzzles/skewb.ts", "../../src/cubing/search/inside/solve/puzzles/dynamic/sq1/index.ts", "../../src/cubing/search/inside/solve/puzzles/sq1.ts", "../../src/cubing/search/inside/api.ts", "../../src/cubing/search/inside/search-worker-js-entry.js"],
  "sourcesContent": ["import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\nimport type { KState } from \"../../../kpuzzle/KState\";\nimport { experimentalCountMoves } from \"../../../notation\";\nimport { randomChoiceFactory } from \"../../../vendor/random-uint-below\";\nimport type { SGSAction, SGSCachedData } from \"./parseSGS\";\n\nconst DEFAULT_STAGE1_DEPTH_LIMIT = 2; // Moderately performant default.\n\nconst DOUBLECHECK_PLACED_PIECES = true;\nconst DEBUG = false;\n\n// TODO: Take moves instead of move names?\nfunction calculateMoves(\n  kpuzzle: KPuzzle,\n  moveNames: string[],\n): {\n  move: Move;\n  transformation: KTransformation;\n}[] {\n  const searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[] = [];\n  // const identity = identityTransformation(def); // TODO\n  // TODO: Make it easy to filter moves.\n  moveNames.forEach(function (moveName) {\n    const rootMove = new Move(moveName);\n    if (rootMove.amount !== 1) {\n      throw new Error(\n        \"SGS cannot handle def moves with an amount other than 1 yet.\",\n      );\n    }\n    let transformation = kpuzzle.identityTransformation();\n    // eslint-disable-next-line no-constant-condition\n    for (let i = 1; true; i++) {\n      transformation = transformation.applyMove(rootMove);\n      if (transformation.isIdentityTransformation()) {\n        break;\n      }\n      searchMoves.push({\n        move: rootMove.modified({ amount: i }),\n        transformation,\n      });\n    }\n  });\n  return searchMoves;\n}\n\n// function badRandomMoves(moves: string[], ksp: KSolvePuzzle): KSolvePuzzleState {\n//   // var sum = 0;\n//   var scramble = \"\";\n//   for (var i = 0; i < 1000; i++) {\n//     scramble = scramble + \" \" + moves[Math.floor(moves.length * Math.random())];\n//   }\n//   // var sol = \"\";\n//   const indexer = new TreeAlgIndexer(ksp, Alg.fromString(scramble));\n//   return indexer.transformAtIndex(indexer.numMoves()) as any; // TODO\n// }\n\nexport class TrembleSolver {\n  private searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[];\n\n  constructor(\n    private kpuzzle: KPuzzle,\n    private sgs: SGSCachedData,\n    trembleMoveNames?: string[],\n  ) {\n    this.searchMoves = calculateMoves(\n      this.kpuzzle,\n      trembleMoveNames ?? Object.keys(this.kpuzzle.definition.moves),\n    );\n  }\n\n  // public badRandomMoves(): KSolvePuzzleState {\n  //   return badRandomMoves(this.moves, this.ksp);\n  // }\n\n  public async solve(\n    state: KState,\n    stage1DepthLimit: number = DEFAULT_STAGE1_DEPTH_LIMIT,\n    quantumMoveOrder?: (quantumMove: QuantumMove) => number,\n  ): Promise<Alg> {\n    const transformation = state.experimentalToTransformation();\n    if (!transformation) {\n      throw new Error(\n        \"distinguishable pieces are not supported in tremble solver yt\",\n      );\n    }\n    let bestAlg: Alg | null = null;\n    let bestLen = 1000000;\n    const recur = (\n      recursiveTransformation: KTransformation, // TODO: Support KStatq1\n      togo: number,\n      sofar: Alg,\n    ) => {\n      // console.log(\"recur\");\n      if (togo === 0) {\n        const sgsAlg = this.sgsPhaseSolve(recursiveTransformation, bestLen);\n        if (!sgsAlg) {\n          return;\n        }\n        // console.log(\"sgs done!\", sofar.toString(), \"|\", sgsAlg.toString());\n        const newAlg = sofar\n          .concat(sgsAlg)\n          .simplify({ collapseMoves: true, quantumMoveOrder });\n\n        const len = experimentalCountMoves(newAlg);\n        if (bestAlg === null || len < bestLen) {\n          if (DEBUG) {\n            console.log(`New best (${len} moves): ${newAlg.toString()}`);\n            console.log(`Tremble moves are: ${sofar.toString()}`);\n          }\n          bestAlg = newAlg;\n          bestLen = len;\n        }\n        return;\n      }\n      for (const searchMove of this.searchMoves) {\n        recur(\n          recursiveTransformation.applyTransformation(\n            searchMove.transformation,\n          ),\n          togo - 1,\n          sofar.concat([searchMove.move]),\n        );\n      }\n    };\n    for (let d = 0; d <= stage1DepthLimit; d++) {\n      recur(transformation, d, new Alg());\n    }\n    if (bestAlg === null) {\n      throw new Error(\"SGS search failed.\");\n    }\n    return bestAlg;\n  }\n\n  private sgsPhaseSolve(\n    initialTransformation: KTransformation, // TODO: Handle KState\n    bestLenSofar: number,\n  ): Alg | null {\n    // const pieceNames = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\n    // function loggo(s: string) {\n    //   // console.warn(s);\n    //   // document.body.appendChild(document.createElement(\"div\")).textContent = s;\n    // }\n\n    // console.log(\"sgsPhaseSolve\");\n    const algBuilder = new AlgBuilder();\n    let transformation = initialTransformation;\n    for (const step of this.sgs.ordering) {\n      const cubieSeq = step.pieceOrdering;\n      let key = \"\";\n      const inverseTransformation = transformation.invert();\n      for (let i = 0; i < cubieSeq.length; i++) {\n        const loc = cubieSeq[i];\n        const orbitName = loc.orbitName;\n        const idx = loc.permutationIdx;\n        key += ` ${inverseTransformation.transformationData[orbitName].permutation[idx]} ${inverseTransformation.transformationData[orbitName].orientation[idx]}`;\n      }\n      // console.log(key, step.lookup);\n      const info = step.lookup[key];\n      if (!info) {\n        throw new Error(\"Missing algorithm in sgs or esgs?\");\n      }\n      algBuilder.experimentalPushAlg(info.alg);\n      if (algBuilder.experimentalNumAlgNodes() >= bestLenSofar) {\n        return null;\n      }\n      transformation = transformation.applyTransformation(info.transformation);\n      if (DOUBLECHECK_PLACED_PIECES) {\n        for (let i = 0; i < cubieSeq.length; i++) {\n          const location = cubieSeq[i];\n          const orbitName = location.orbitName;\n          const idx = location.permutationIdx;\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientation[idx] !== 0\n          ) {\n            throw new Error(\"bad SGS :-(\");\n          }\n        }\n      }\n    }\n    return algBuilder.toAlg();\n  }\n}\n\nexport async function randomStateFromSGS(\n  kpuzzle: KPuzzle,\n  sgs: SGSCachedData,\n): Promise<KState> {\n  const randomChoice = await randomChoiceFactory<SGSAction>(); // TODO: make this sync by putting the factory into a TLA\n\n  let transformation = kpuzzle.identityTransformation();\n  for (const step of sgs.ordering) {\n    const sgsAction = randomChoice(Object.values(step.lookup));\n    transformation = transformation.applyTransformation(\n      sgsAction.transformation,\n    );\n  }\n  return transformation.toKState();\n}\n", "import { from } from \"../../../../../../vendor/p-lazy/p-lazy\";\n\nexport const searchDynamicSideEvents = from<\n  typeof import(\"./search-dynamic-sgs-side-events\")\n>(() => import(\"./search-dynamic-sgs-side-events\"));\n", "import type { Alg } from \"../../../../alg\";\nimport type { KPuzzle } from \"../../../../kpuzzle\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { puzzles } from \"../../../../puzzles\";\nimport {\n  randomPermute,\n  randomUIntBelowFactory,\n} from \"../../../../vendor/random-uint-below\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\n// Empirical ly determined depth:\n// - \u224811 moves on average (as opposed to >13 moves for depth 2),\n// - in close to 40ms(on a MacBook Pro).\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgsCachedData: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedData222();\n      return new TrembleSolver(\n        await puzzles[\"2x2x2\"].kpuzzle(),\n        sgsCachedData,\n        \"URFLBD\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitialize222(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: fix def consistency.\nexport async function solve222(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(state, TREMBLE_DEPTH, () => 4); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\n// TODO: factor out and test.\nasync function mutatingRandomizeOrbit(\n  kpuzzle: KPuzzle,\n  orbitName: string,\n  state: KState,\n  options?: { orientationSum?: number },\n): Promise<void> {\n  const randomUIntBelow = await randomUIntBelowFactory();\n  await randomPermute(state.stateData[orbitName].pieces);\n\n  const orbitDef = kpuzzle.definition.orbits[orbitName];\n  const ori = state.stateData[orbitName].orientation;\n\n  let sum = 0;\n  for (let i = 0; i < orbitDef.numPieces; i++) {\n    const o = randomUIntBelow(orbitDef.numOrientations);\n    ori[i] = o;\n    sum += o;\n  }\n\n  // console.log(\"aaaa\", options && \"orientationSum\" in options);\n  if (options && \"orientationSum\" in options) {\n    // console.log(\"sfdsf\", options!.orientationSum),\n    ori[0] =\n      (((ori[0] + options.orientationSum! - sum) % orbitDef.numOrientations) +\n        orbitDef.numOrientations) %\n      orbitDef.numOrientations;\n  }\n}\n\n// TODO: Use SGS?\nexport async function random222State(): Promise<KState> {\n  const kpuzzle = await puzzles[\"2x2x2\"].kpuzzle();\n  const stateCopy: KState = new KState(\n    kpuzzle,\n    JSON.parse(JSON.stringify(kpuzzle.startState().stateData)),\n  ); // TODO\n  await mutatingRandomizeOrbit(kpuzzle, \"CORNERS\", stateCopy, {\n    orientationSum: 0,\n  });\n  return stateCopy;\n}\n\nexport async function random222Scramble(): Promise<Alg> {\n  return await solve222(await random222State());\n}\n", "import { from } from \"../../../../../../vendor/p-lazy/p-lazy\";\n\nexport const dynamic4x4x4Solver = from<\n  typeof import(\"./search-dynamic-solve-4x4x4\")\n>(() => import(\"./search-dynamic-solve-4x4x4\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { dynamic4x4x4Solver } from \"./dynamic/4x4x4\";\n\nconst randomSuffixes = [\n  [null, \"x\", \"x2\", \"x'\", \"z\", \"z'\"],\n  [null, \"y\", \"y2\", \"y'\"],\n];\n\nexport async function initialize444(): Promise<void> {\n  return (await dynamic4x4x4Solver).initialize();\n}\n\nexport async function random444Scramble(): Promise<Alg> {\n  return (await dynamic4x4x4Solver).random444Scramble();\n}\n\nexport async function random444OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random444Scramble(), randomSuffixes);\n}\n", "import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../../alg\";\nimport {\n  randomChoiceFactory,\n  randomUIntBelowFactory,\n} from \"../../../../vendor/random-uint-below\";\n\nfunction numMoves(n: number): number {\n  switch (n) {\n    case 5:\n      return 60;\n    case 6:\n      return 80;\n    default:\n      return 100;\n  }\n}\n\nconst axesFaces = [\n  [\"U\", \"D\"],\n  [\"L\", \"R\"],\n  [\"F\", \"B\"],\n];\nconst axesMovesCache: Map<number, QuantumMove[][]> = new Map();\nfunction cachedAxesMoves(n: number): QuantumMove[][] {\n  const existing = axesMovesCache.get(n);\n  if (existing) {\n    return existing;\n  }\n  const axesMoves = [];\n  for (const faces of axesFaces) {\n    const axisMoveFamilies: QuantumMove[] = [];\n    axesMoves.push(axisMoveFamilies);\n\n    for (const face of faces) {\n      axisMoveFamilies.push(new QuantumMove(face));\n      if (n > 3) {\n        axisMoveFamilies.push(new QuantumMove(`${face}w`));\n      }\n      for (let i = 3; i <= n / 2; i++) {\n        axisMoveFamilies.push(new QuantumMove(`${face}w`, i));\n      }\n    }\n  }\n  axesMovesCache.set(n, axesMoves);\n  return axesMoves;\n}\n\n// TODO: Document this algorithm and compare to TNoodle.\nexport async function bigCubeRandomMoves(n: number): Promise<Alg> {\n  const randomUintBelow = await randomUIntBelowFactory();\n  const randomChoice = await randomChoiceFactory<QuantumMove>();\n  const randomNumChoice = randomChoice as any as (arr: Array<number>) => number; // TODO: Avoid needing multiple instantiations or recasting.\n\n  const axesMoves = cachedAxesMoves(n);\n\n  const cachedNumMoves = numMoves(n);\n  const algBuilder = new AlgBuilder();\n  let currentAxisIdx = 0;\n  const currentAxisQuantumMoves = new Set();\n  while (algBuilder.experimentalNumAlgNodes() < cachedNumMoves) {\n    const newAxisIdx = randomUintBelow(3);\n    if (newAxisIdx !== currentAxisIdx) {\n      currentAxisQuantumMoves.clear();\n    }\n    currentAxisIdx = newAxisIdx;\n\n    const quantumMove = randomChoice(axesMoves[currentAxisIdx]);\n    const quantumMoveStr = quantumMove.toString();\n    if (currentAxisQuantumMoves.has(quantumMoveStr)) {\n      // Skip duplicates and resample with replacement.\n      continue;\n    }\n    currentAxisQuantumMoves.add(quantumMoveStr);\n    algBuilder.push(new Move(quantumMove, randomNumChoice([1, 2, -1])));\n  }\n\n  return algBuilder.toAlg();\n}\n", "import type { Alg } from \"../../../../alg\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { bigCubeRandomMoves } from \"./big-cubes\";\n\nconst randomSuffixes = [\n  [null, \"3Rw\", \"3Rw2\", \"3Rw'\", \"3Fw\", \"3Fw'\"],\n  [null, \"3Dw\", \"3Dw2\", \"3Dw'\"],\n];\n\nexport async function oriented555RandomMoves(): Promise<Alg> {\n  return addOrientationSuffix(await bigCubeRandomMoves(5), randomSuffixes);\n}\n", "import { from } from \"../../../../../../vendor/p-lazy/p-lazy\";\n\nexport const dynamicFTOSolver = from<\n  typeof import(\"./search-dynamic-solve-fto\")\n>(() => import(\"./search-dynamic-solve-fto\"));\n", "import { Alg } from \"../../../../alg\";\nimport type { KState } from \"../../../../kpuzzle/KState\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { from } from \"../../../../vendor/p-lazy/p-lazy\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { dynamicFTOSolver } from \"./dynamic/fto\";\n\nconst dynamic = from<\n  typeof import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\")\n>(() => import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\"));\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (await dynamic).sgsDataFTO();\n      return new TrembleSolver(await puzzles[\"fto\"].kpuzzle(), json, [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"L\",\n        \"D\",\n        \"B\",\n        \"BR\",\n        \"BL\",\n      ]);\n    })())\n  );\n}\n\nexport async function preInitializeFTO(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveFTO(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    state,\n    TREMBLE_DEPTH,\n    () => 3, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomFTOScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(await (await dynamicFTOSolver).randomFTOScrambleString());\n}\n", "import { from } from \"../../../../../../vendor/p-lazy/p-lazy\";\n\nexport const dynamicKilominxSolver = from<\n  typeof import(\"./search-dynamic-solve-kilominx\")\n>(() => import(\"./search-dynamic-solve-kilominx\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicKilominxSolver } from \"./dynamic/kilominx\";\n\nexport async function randomKilominxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamicKilominxSolver).getRandomKilominxScramble();\n}\n", "import { from } from \"../../../../../../vendor/p-lazy/p-lazy\";\n\nexport const dynamicMasterTetraminxSolver = from<\n  typeof import(\"./search-dynamic-solve-master_tetraminx\")\n>(() => import(\"./search-dynamic-solve-master_tetraminx\"));\n", "import { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicMasterTetraminxSolver } from \"./dynamic/master_tetraminx\";\n\nexport async function randomMasterTetraminxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(\n    await (\n      await dynamicMasterTetraminxSolver\n    ).randomMasterTetraminxScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KStateData } from \"../../../../kpuzzle\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 2;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedSGSDataMegaminx();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n        json,\n        [\"U\", \"R\", \"F\", \"L\", \"BR\", \"BL\", \"FR\", \"FL\", \"DR\", \"DL\", \"B\", \"D\"],\n      );\n    })())\n  );\n}\n\nexport async function preInitializeMegaminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveMegaminx(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const stateDataWithoutMO: KStateData = JSON.parse(\n    JSON.stringify(state.stateData),\n  );\n  stateDataWithoutMO.CENTERS.orientation = new Array(12).fill(0);\n  const stateWithoutMO = new KState(\n    await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n    stateDataWithoutMO,\n  );\n  const alg = await trembleSolver.solve(\n    stateWithoutMO,\n    TREMBLE_DEPTH,\n    () => 5, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KState } from \"../../../../kpuzzle/KState\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomStateFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataPyraminx();\n      return new TrembleSolver(\n        await puzzles.pyraminx.kpuzzle(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializePyraminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solvePyraminx(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(state, TREMBLE_DEPTH, () => 3); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\nexport async function randomPyraminxStateFixedOrientation(): Promise<KState> {\n  mustBeInsideWorker();\n  // Note: this sets all center orientations to 0.\n  return randomStateFromSGS(\n    await puzzles.pyraminx.kpuzzle(),\n    await (await searchDynamicSideEvents).sgsDataPyraminxFixedOrientation(),\n  );\n}\n\nexport async function randomPyraminxScrambleFixedOrientation(): Promise<Alg> {\n  return solvePyraminx(await randomPyraminxStateFixedOrientation());\n}\n", "import { from } from \"../../../../../../vendor/p-lazy/p-lazy\";\n\nexport const searchDynamicUnofficial = from<\n  typeof import(\"./search-dynamic-sgs-unofficial\")\n>(() => import(\"./search-dynamic-sgs-unofficial\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { searchDynamicUnofficial } from \"./dynamic/sgs-unofficial\";\n\nexport async function randomRediCubeScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return (await searchDynamicUnofficial).getRandomRediCubeScramble();\n}\n", "import type { Alg, QuantumMove } from \"../../../../alg\";\nimport { KState } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomStateFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataSkewb();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializeSkewb(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nfunction resetCenterOrientation(state: KState): KState {\n  return new KState(state.kpuzzle, {\n    CORNERS: state.stateData.CORNERS,\n    CENTERS: {\n      pieces: state.stateData.CENTERS.pieces,\n      orientation: new Array(6).fill(0),\n    },\n  });\n}\n\n// TODO: fix def consistency.\nexport async function solveSkewb(state: KState): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    resetCenterOrientation(state),\n    TREMBLE_DEPTH,\n    (quantumMove: QuantumMove) => (quantumMove.family === \"y\" ? 4 : 3), // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomSkewbFixedCornerState(): Promise<KState> {\n  // Note: this sets all center orientations to 0.\n  return randomStateFromSGS(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    await (await searchDynamicSideEvents).sgsDataSkewbFixedCorner(),\n  );\n}\n\nexport async function randomSkewbFixedCornerScramble(): Promise<Alg> {\n  return solveSkewb(await randomSkewbFixedCornerState());\n}\n", "import { from } from \"../../../../../../vendor/p-lazy/p-lazy\";\n\nexport const dynamicSq1Solver = from<\n  typeof import(\"./search-dynamic-solve-sq1\")\n>(() => import(\"./search-dynamic-solve-sq1\"));\n", "import { Alg } from \"../../../../alg\";\nimport { dynamicSq1Solver } from \"./dynamic/sq1\";\n\nexport async function getRandomSquare1Scramble(): Promise<Alg> {\n  return Alg.fromString(\n    await (await dynamicSq1Solver).getRandomSquare1ScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../alg\";\nimport type { KStateData } from \"../../kpuzzle\";\nimport { KState } from \"../../kpuzzle\";\nimport { puzzles } from \"../../puzzles\";\nimport { setIsInsideWorker } from \"./inside-worker\";\nimport {\n  preInitialize222,\n  random222Scramble,\n  solve222,\n} from \"./solve/puzzles/2x2x2\";\nimport {\n  initialize333,\n  random333FewestMovesScramble,\n  random333OrientedScramble,\n  random333Scramble,\n  solve333,\n} from \"./solve/puzzles/3x3x3\";\nimport {\n  initialize444,\n  random444OrientedScramble,\n  random444Scramble,\n} from \"./solve/puzzles/4x4x4\";\nimport { oriented555RandomMoves } from \"./solve/puzzles/5x5x5\";\nimport { bigCubeRandomMoves } from \"./solve/puzzles/big-cubes\";\nimport { randomFTOScramble } from \"./solve/puzzles/fto\";\nimport { randomKilominxScramble } from \"./solve/puzzles/kilominx\";\nimport { randomMasterTetraminxScramble } from \"./solve/puzzles/master_tetraminx\";\nimport { solveMegaminx } from \"./solve/puzzles/megaminx\";\nimport {\n  randomPyraminxScrambleFixedOrientation,\n  solvePyraminx,\n} from \"./solve/puzzles/pyraminx\";\nimport { randomRediCubeScramble } from \"./solve/puzzles/redi_cube\";\nimport {\n  randomSkewbFixedCornerScramble,\n  solveSkewb,\n} from \"./solve/puzzles/skewb\";\nimport { getRandomSquare1Scramble } from \"./solve/puzzles/sq1\";\n\nconst IDLE_PREFETCH_TIMEOUT_MS = 1000;\n\nsetIsInsideWorker(true);\n\nlet DEBUG_MEASURE_PERF = true;\nexport function setDebugMeasurePerf(newDebugMeasurePerf: boolean): void {\n  DEBUG_MEASURE_PERF = newDebugMeasurePerf;\n}\n\nfunction now() {\n  return (typeof performance === \"undefined\" ? Date : performance).now();\n}\n\nasync function measurePerf<T>(\n  name: string,\n  f: () => T | Promise<T>,\n  options?: { isPrefetch?: boolean },\n): Promise<T> {\n  if (!DEBUG_MEASURE_PERF) {\n    return f();\n  }\n\n  const start = now();\n  const result = f();\n  if ((result as any)?.then) {\n    await result;\n  }\n  const end = now();\n  console.warn(\n    `${name}${options?.isPrefetch ? \" (prefetched)\" : \"\"}: ${Math.round(\n      end - start,\n    )}ms`,\n  );\n  return result;\n}\n\nconst prefetchPromises: Map<string, Promise<Alg>> = new Map();\n// This would just be a number, except `node` is extremely silly and returns an object instead.\n// https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\nlet queuedPrefetchTimeoutID: ReturnType<typeof setTimeout> | null = null;\n\nasync function randomScrambleForEvent(\n  eventID: string,\n  options?: { isPrefetch?: boolean },\n): Promise<Alg> {\n  switch (eventID) {\n    case \"222\":\n      return measurePerf(\"random222Scramble\", random222Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333\":\n    case \"333oh\":\n    case \"333ft\":\n      return measurePerf(\"random333Scramble\", random333Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333fm\":\n      return measurePerf(\n        \"random333FewestMovesScramble\",\n        random333FewestMovesScramble,\n      );\n    case \"333bf\":\n    case \"333mb\":\n      return measurePerf(\n        \"random333OrientedScramble\",\n        random333OrientedScramble,\n      );\n    case \"444\":\n      return measurePerf(\"random444Scramble\", random444Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"444bf\":\n      return measurePerf(\n        \"random444OrientedScramble\",\n        random444OrientedScramble,\n      );\n    case \"555\":\n      return measurePerf(\n        \"bigCubeScramble(5)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 5),\n      );\n    case \"555bf\":\n      return measurePerf(\"oriented555RandomMoves\", oriented555RandomMoves);\n    case \"666\":\n      return measurePerf(\n        \"bigCubeScramble(6)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 6),\n      );\n    case \"777\":\n      return measurePerf(\n        \"bigCubeScramble(7)\",\n        bigCubeRandomMoves.bind(bigCubeRandomMoves, 7),\n      );\n    case \"skewb\":\n      return measurePerf(\n        \"randomSkewbFixedCornerScramble\",\n        randomSkewbFixedCornerScramble,\n      );\n    case \"pyram\":\n      return measurePerf(\n        \"randomPyraminxScrambleFixedOrientation\",\n        randomPyraminxScrambleFixedOrientation,\n      );\n    case \"sq1\":\n      return measurePerf(\"getRandomSquare1Scramble\", getRandomSquare1Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"fto\":\n      return measurePerf(\"randomFTOScramble\", randomFTOScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"master_tetraminx\":\n      return measurePerf(\n        \"randomMasterTetraminxScramble\",\n        randomMasterTetraminxScramble,\n      );\n    case \"kilominx\":\n      return measurePerf(\"randomKilominxScramble\", randomKilominxScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"redi_cube\":\n      return measurePerf(\"randomRediCubeScramble\", randomRediCubeScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    default:\n      throw new Error(`unsupported event: ${eventID}`);\n  }\n}\n\nexport enum PrefetchLevel {\n  Auto = \"auto\",\n  None = \"none\",\n  Immediate = \"immediate\",\n}\n\nlet currentPrefetchLevel = PrefetchLevel.Auto;\n\nexport const insideAPI = {\n  initialize: async (eventID: string) => {\n    switch (eventID) {\n      case \"222\":\n        return measurePerf(\"preInitialize222\", preInitialize222);\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"initialize333\", initialize333);\n      case \"444\":\n        return measurePerf(\"initialize444\", initialize444);\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  },\n\n  setScramblePrefetchLevel(prefetchLevel: PrefetchLevel) {\n    currentPrefetchLevel = prefetchLevel;\n  },\n\n  randomScrambleForEvent: async (eventID: string): Promise<Alg> => {\n    let promise = prefetchPromises.get(eventID);\n    if (promise) {\n      prefetchPromises.delete(eventID);\n    } else {\n      promise = randomScrambleForEvent(eventID);\n    }\n    if (currentPrefetchLevel !== PrefetchLevel.None) {\n      promise.then(() => {\n        // `queuedPrefetch` could be 0, but:\n        // > Passing an invalid ID to clearTimeout() silently does nothing; no exception is thrown.\n        // https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout#notes\n        if (queuedPrefetchTimeoutID) {\n          clearTimeout(queuedPrefetchTimeoutID);\n        }\n        queuedPrefetchTimeoutID = setTimeout(\n          () => {\n            prefetchPromises.set(\n              eventID,\n              randomScrambleForEvent(eventID, {\n                isPrefetch: true,\n              }),\n            );\n          },\n          currentPrefetchLevel === PrefetchLevel.Immediate\n            ? 0\n            : IDLE_PREFETCH_TIMEOUT_MS,\n        );\n      });\n    }\n    return promise;\n  },\n\n  randomScrambleStringForEvent: async (eventID: string): Promise<string> => {\n    return (await insideAPI.randomScrambleForEvent(eventID)).toString();\n  },\n\n  solve333ToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"3x3x3\"].kpuzzle(), stateData);\n    return (await solve333(state)).toString();\n  },\n\n  solve222ToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"2x2x2\"].kpuzzle(), stateData);\n    return (await solve222(state)).toString();\n  },\n\n  solveSkewbToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"skewb\"].kpuzzle(), stateData);\n    return (await solveSkewb(state)).toString();\n  },\n\n  solvePyraminxToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"pyraminx\"].kpuzzle(), stateData);\n    return (await solvePyraminx(state)).toString();\n  },\n\n  solveMegaminxToString: async (stateData: KStateData): Promise<string> => {\n    const state = new KState(await puzzles[\"megaminx\"].kpuzzle(), stateData);\n    return (await solveMegaminx(state)).toString();\n  },\n\n  setDebugMeasurePerf: async (measure: boolean): Promise<void> => {\n    setDebugMeasurePerf(measure);\n  },\n};\n\nexport type WorkerInsideAPI = typeof insideAPI;\n", "import { expose } from \"../../vendor/comlink-everywhere/inside\";\nimport { insideAPI } from \"./api\";\n\nexpose(insideAPI);\n"],
  "mappings": "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",
  "names": []
}
