{
  "version": 3,
  "sources": ["../../src/cubing/alg/common.ts", "../../src/cubing/alg/iteration.ts", "../../src/cubing/alg/limits.ts", "../../src/cubing/alg/AlgBuilder.ts", "../../src/cubing/alg/debug.ts", "../../src/cubing/alg/alg-nodes/containers/Commutator.ts", "../../src/cubing/alg/alg-nodes/containers/Conjugate.ts", "../../src/cubing/alg/alg-nodes/leaves/LineComment.ts", "../../src/cubing/alg/alg-nodes/leaves/Newline.ts", "../../src/cubing/alg/alg-nodes/leaves/Pause.ts", "../../src/cubing/alg/parse.ts", "../../src/cubing/alg/warnOnce.ts", "../../src/cubing/alg/alg-nodes/QuantumWithAmount.ts", "../../src/cubing/alg/alg-nodes/leaves/Move.ts", "../../src/cubing/alg/alg-nodes/containers/Grouping.ts", "../../src/cubing/alg/is.ts", "../../src/cubing/alg/traversal.ts", "../../src/cubing/alg/Alg.ts", "../../src/cubing/alg/example.ts", "../../src/cubing/alg/keyboard.ts", "../../src/cubing/alg/url.ts", "../../src/cubing/alg/operation.ts"],
  "sourcesContent": ["import type { Alg } from \"./Alg\";\nimport type { IterationDirection } from \"./iteration\";\nimport type { AlgLeafNode, AlgNode } from \"./alg-nodes/AlgNode\";\n\nlet writeAlgDebugField = false;\nexport function setAlgDebugField(debug: boolean): void {\n  writeAlgDebugField = debug;\n}\n\nexport abstract class Comparable {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  is(c: any): boolean {\n    return this instanceof c;\n  }\n\n  as<T>(c: new (...args: any) => T): T | null {\n    return this instanceof c ? this : null;\n  }\n\n  abstract isIdentical(other: Comparable): boolean;\n}\n\nexport interface Repeatable extends Comparable {\n  experimentalExpand(\n    iterDir?: IterationDirection,\n    depth?: number,\n  ): Generator<AlgLeafNode>;\n}\n\n// Common to `Alg` or `AlgNode` classes.\nexport abstract class AlgCommon<T extends Alg | AlgNode>\n  extends Comparable\n  implements Repeatable\n{\n  constructor() {\n    super();\n    if (writeAlgDebugField) {\n      Object.defineProperty(this, \"_debugStr\", {\n        get: () => {\n          return this.toString();\n        },\n      });\n    }\n  }\n\n  get log(): (message?: any) => void {\n    // By returning a (bound) version of `console.log`, we ensure that DevTools\n    // logs the call site instead of this function.\n    return console.log.bind(console, this, this.toString()) as (\n      message?: any,\n    ) => void;\n  }\n\n  abstract toString(): string;\n\n  abstract invert(): T;\n\n  abstract experimentalExpand(\n    iterDir: IterationDirection,\n  ): Generator<AlgLeafNode>;\n}\n", "export enum IterationDirection {\n  Forwards = 1,\n  Backwards = -1,\n}\n\nexport function toggleDirection(\n  iterationDirection: IterationDirection,\n  flip: boolean = true,\n): IterationDirection {\n  if (!flip) {\n    return iterationDirection;\n  }\n  switch (iterationDirection) {\n    case IterationDirection.Forwards:\n      return IterationDirection.Backwards;\n    case IterationDirection.Backwards:\n      return IterationDirection.Forwards;\n  }\n}\n\nexport function direct<T>(\n  g: Iterable<T>,\n  iterDir: IterationDirection,\n): Iterable<T> {\n  return iterDir === IterationDirection.Backwards ? Array.from(g).reverse() : g;\n}\n\nexport function reverse<T>(g: Iterable<T>): Iterable<T> {\n  return Array.from(g).reverse();\n}\n\nexport function* directedGenerator<T>(\n  g: Generator<T>,\n  direction: IterationDirection,\n): Generator<T> {\n  direction === IterationDirection.Backwards\n    ? yield* reverseGenerator(g)\n    : yield* g;\n}\n\nexport function* reverseGenerator<T>(g: Generator<T>): Generator<T> {\n  for (const t of Array.from(g).reverse()) {\n    yield t;\n  }\n}\n", "export const MAX_INT = 0x7fffffff; // 2^31-1, the max value for signed 32-bit ints.\nexport const MAX_INT_DESCRIPTION = \"2^31 - 1\";\nexport const MIN_INT = -0x80000000;\nexport const MIN_INT_DESCRIPTION = \"-2^31\";\n", "import { Alg } from \"./Alg\";\nimport type { AlgNode } from \"./alg-nodes/AlgNode\";\n\n/** @category Alg */\nexport class AlgBuilder {\n  #algNode: AlgNode[] = [];\n\n  push(u: AlgNode): void {\n    this.#algNode.push(u);\n  }\n\n  // TODO: Allow FlexibleAlgSource?\n  /** @deprecated */\n  experimentalPushAlg(alg: Alg): void {\n    // TODO: Optimize?\n    for (const u of alg.childAlgNodes()) {\n      this.push(u);\n    }\n  }\n\n  // TODO: can we guarantee this to be fast in the permanent API?\n  experimentalNumAlgNodes(): number {\n    return this.#algNode.length;\n  }\n\n  // can be called multiple times, even if you push alg nodes inbetween.\n  toAlg(): Alg {\n    return new Alg(this.#algNode);\n  }\n\n  reset(): void {\n    this.#algNode = [];\n  }\n}\n", "type ReportingLevel = \"none\" | \"warn\" | \"error\";\nlet currentReportingLevel = \"warn\";\n\nconst MAX_NUMBER_OF_TIMES_TO_WARN = 10;\nlet numWarned = 0;\n\n// TODO: Avoid creating the string message if it won't be used (e.g. by taking a function?).\nexport function reportTypeMismatch(msg: string): void {\n  switch (currentReportingLevel) {\n    case \"error\":\n      throw new Error(msg);\n    case \"warn\":\n      numWarned++;\n      if (numWarned < MAX_NUMBER_OF_TIMES_TO_WARN) {\n        if (numWarned + 1 === MAX_NUMBER_OF_TIMES_TO_WARN) {\n          console.warn(msg);\n        }\n      }\n      return;\n  }\n}\n\nexport function setAlgPartTypeMismatchReportingLevel(\n  level: ReportingLevel,\n): void {\n  currentReportingLevel = level;\n}\n\nexport const algDebugGlobals: { caratNISSNotationEnabled: boolean } = {\n  caratNISSNotationEnabled: false,\n};\n\nexport function setAlgDebug(options: {\n  caratNISSNotationEnabled?: boolean;\n}): void {\n  if (\"caratNISSNotationEnabled\" in options) {\n    algDebugGlobals.caratNISSNotationEnabled =\n      !!options.caratNISSNotationEnabled;\n  }\n}\n", "import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeafNode } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Commutator extends AlgCommon<Commutator> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsCommutator = other.as(Commutator);\n    return !!(\n      otherAsCommutator?.A.isIdentical(this.A) &&\n      otherAsCommutator?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Commutator {\n    return new Commutator(this.#B, this.#A);\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeafNode> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      if (iterDir === IterationDirection.Forwards) {\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      } else {\n        yield* this.B.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Forwards,\n          depth - 1,\n        );\n        yield* this.B.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n        yield* this.A.experimentalExpand(\n          IterationDirection.Backwards,\n          depth - 1,\n        );\n      }\n    }\n  }\n\n  toString(): string {\n    return `[${this.#A.toString()}, ${this.#B.toString()}]`;\n  }\n}\n", "import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeafNode } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Conjugate extends AlgCommon<Conjugate> {\n  readonly #A: Alg;\n  readonly #B: Alg;\n\n  constructor(aSource: FlexibleAlgSource, bSource: FlexibleAlgSource) {\n    super();\n    this.#A = experimentalEnsureAlg(aSource);\n    this.#B = experimentalEnsureAlg(bSource);\n  }\n\n  get A(): Alg {\n    return this.#A;\n  }\n\n  get B(): Alg {\n    return this.#B;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsConjugate = other.as(Conjugate);\n    return !!(\n      otherAsConjugate?.A.isIdentical(this.A) &&\n      otherAsConjugate?.B.isIdentical(this.B)\n    );\n  }\n\n  invert(): Conjugate {\n    return new Conjugate(this.#A, this.#B.invert());\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth?: number,\n  ): Generator<AlgLeafNode> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.A.experimentalExpand(IterationDirection.Forwards, depth - 1);\n      yield* this.B.experimentalExpand(iterDir, depth - 1);\n      yield* this.A.experimentalExpand(IterationDirection.Backwards, depth - 1);\n    }\n  }\n\n  toString(): string {\n    return `[${this.A}: ${this.B}]`;\n  }\n}\n", "import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeafNode } from \"../AlgNode\";\n\n// TODO: hash\n// TODO: this conflicts with the HTML `LineComment` class\n/** @category Alg Nodes */\nexport class LineComment extends AlgCommon<LineComment> {\n  readonly #text: string;\n\n  constructor(commentText: string) {\n    super();\n    if (commentText.includes(\"\\n\") || commentText.includes(\"\\r\")) {\n      throw new Error(\"LineComment cannot contain newline\");\n    }\n    this.#text = commentText;\n  }\n\n  get text(): string {\n    return this.#text;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsLineComment = other as LineComment;\n    return other.is(LineComment) && this.#text === otherAsLineComment.#text;\n  }\n\n  invert(): LineComment {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeafNode> {\n    yield this;\n  }\n\n  toString(): string {\n    return `//${this.#text}`;\n  }\n\n  // toJSON(): LineCommentJSON {\n  //   return {\n  //     type: \"comment\",\n  //     text: this.#text,\n  //   };\n  // }\n}\n", "import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeafNode } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Newline extends AlgCommon<Newline> {\n  toString(): string {\n    return `\\n`;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Newline);\n  }\n\n  invert(): Newline {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeafNode> {\n    yield this;\n  }\n}\n", "import type { Grouping } from \"..\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport type { AlgLeafNode } from \"../AlgNode\";\n\n/** @category Alg Nodes */\nexport class Pause extends AlgCommon<Pause> {\n  experimentalNISSGrouping?: Grouping; // TODO: tie this to the alg\n\n  toString(): string {\n    return `.`;\n  }\n\n  isIdentical(other: Comparable): boolean {\n    return other.is(Pause);\n  }\n\n  invert(): Pause {\n    return this;\n  }\n\n  *experimentalExpand(\n    _iterDir: IterationDirection = IterationDirection.Forwards,\n    _depth: number = Infinity,\n  ): Generator<AlgLeafNode> {\n    yield this;\n  }\n}\n", "import { Alg } from \"./Alg\";\nimport { AlgBuilder } from \"./AlgBuilder\";\nimport { algDebugGlobals } from \"./debug\";\nimport type { AlgNode } from \"./alg-nodes\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Grouping } from \"./alg-nodes/containers/Grouping\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move, QuantumMove } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\n\ntype StoppingChar = \",\" | \":\" | \"]\" | \")\";\n\nfunction parseIntWithEmptyFallback<T>(n: string, emptyFallback: T): number | T {\n  return n ? parseInt(n) : emptyFallback;\n}\n\nconst AMOUNT_REGEX = /^(\\d+)?('?)/;\nconst MOVE_START_REGEX = /^[_\\dA-Za-z]/; // TODO: Handle slash\nconst QUANTUM_MOVE_REGEX = /^((([1-9]\\d*)-)?([1-9]\\d*))?([_A-Za-z]+)?/;\nconst COMMENT_TEXT_REGEX = /^[^\\n]*/;\nconst SQUARE1_PAIR_START_REGEX = /^(-?\\d+), ?/; // TODO: match up with other whitespace handling?\nconst SQUARE1_PAIR_END_REGEX = /^(-?\\d+)\\)/; // TODO: match up with other whitespace handling?\n\nexport function parseAlg(s: string): Alg {\n  return new AlgParser().parseAlg(s);\n}\n\nexport function parseMove(s: string): Move {\n  return new AlgParser().parseMove(s);\n}\n\nexport function parseQuantumMove(s: string): QuantumMove {\n  return new AlgParser().parseQuantumMove(s);\n}\n\nexport interface ParserIndexed {\n  startCharIndex: number;\n  endCharIndex: number;\n}\n\nexport type Parsed<T extends Alg | AlgNode> = T & ParserIndexed;\n\n// TODO: attach to parser so the end char index can default to `this.#idx`?\nfunction addCharIndices<T extends Alg | AlgNode>(\n  t: T,\n  startCharIndex: number,\n  endCharIndex: number,\n): Parsed<T> {\n  const parsedT = t as ParserIndexed & T;\n  parsedT.startCharIndex = startCharIndex;\n  parsedT.endCharIndex = endCharIndex;\n  return parsedT;\n}\n\nexport function transferCharIndex<T extends Alg | AlgNode>(from: T, to: T): T {\n  if (\"startCharIndex\" in from) {\n    (to as Parsed<T>).startCharIndex = (from as Parsed<T>).startCharIndex;\n  }\n  if (\"endCharIndex\" in from) {\n    (to as Parsed<T>).endCharIndex = (from as Parsed<T>).endCharIndex;\n  }\n  return to;\n}\n\ntype MoveSuffix = \"+\" | \"++\" | \"-\" | \"--\";\n\n// TODO: support recording string locations for moves.\nclass AlgParser {\n  #input: string = \"\";\n  #idx: number = 0;\n  #nissQueue: Grouping[] = [];\n\n  parseAlg(input: string): Parsed<Alg> {\n    this.#input = input;\n    this.#idx = 0;\n    const alg = this.parseAlgWithStopping([]);\n    this.mustBeAtEndOfInput();\n    const algNodes = Array.from(alg.childAlgNodes());\n    if (this.#nissQueue.length > 0) {\n      for (const nissGrouping of this.#nissQueue.reverse()) {\n        algNodes.push(nissGrouping);\n      }\n    }\n    return new Alg(algNodes) as Parsed<Alg>;\n  }\n\n  parseMove(input: string): Parsed<Move> {\n    this.#input = input;\n    this.#idx = 0;\n    const move = this.parseMoveImpl();\n    this.mustBeAtEndOfInput();\n    return move;\n  }\n\n  parseQuantumMove(input: string): QuantumMove {\n    this.#input = input;\n    this.#idx = 0;\n    const quantumMove = this.parseQuantumMoveImpl();\n    this.mustBeAtEndOfInput();\n    return quantumMove;\n  }\n\n  private mustBeAtEndOfInput() {\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"parsing unexpectedly ended early\");\n    }\n  }\n\n  private parseAlgWithStopping(stopBefore: StoppingChar[]): Parsed<Alg> {\n    let algStartIdx = this.#idx;\n    let algEndIdx = this.#idx;\n    const algBuilder = new AlgBuilder();\n\n    // We're \"crowded\" if there was not a space or newline since the last alg node.\n    let crowded = false;\n\n    const mustNotBeCrowded = (idx: number): void => {\n      if (crowded) {\n        throw new Error(\n          `Unexpected character at index ${idx}. Are you missing a space?`,\n        ); // TODO better error message\n      }\n    };\n\n    mainLoop: while (this.#idx < this.#input.length) {\n      const savedCharIndex = this.#idx;\n      if ((stopBefore as string[]).includes(this.#input[this.#idx])) {\n        return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n      }\n      if (this.tryConsumeNext(\" \")) {\n        crowded = false;\n        if (algBuilder.experimentalNumAlgNodes() === 0) {\n          algStartIdx = this.#idx;\n        }\n        continue mainLoop;\n      } else if (MOVE_START_REGEX.test(this.#input[this.#idx])) {\n        mustNotBeCrowded(savedCharIndex);\n        const move = this.parseMoveImpl();\n        algBuilder.push(move);\n        crowded = true;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"(\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const sq1PairStartMatch = this.tryRegex(SQUARE1_PAIR_START_REGEX);\n        if (sq1PairStartMatch) {\n          const topAmountString = sq1PairStartMatch[1];\n          const savedCharIndexD = this.#idx;\n          const sq1PairEndMatch = this.parseRegex(SQUARE1_PAIR_END_REGEX);\n          const uMove = addCharIndices(\n            new Move(new QuantumMove(\"U_SQ_\"), parseInt(topAmountString)),\n            savedCharIndex + 1,\n            savedCharIndex + 1 + topAmountString.length,\n          );\n          const dMove = addCharIndices(\n            new Move(new QuantumMove(\"D_SQ_\"), parseInt(sq1PairEndMatch[1])),\n            savedCharIndexD,\n            this.#idx - 1,\n          );\n          const alg = addCharIndices(\n            new Alg([uMove, dMove]),\n            savedCharIndex + 1,\n            this.#idx - 1,\n          );\n          algBuilder.push(\n            addCharIndices(new Grouping(alg), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          const alg = this.parseAlgWithStopping([\")\"]);\n          this.mustConsumeNext(\")\");\n          const amount = this.parseAmount();\n          algBuilder.push(\n            addCharIndices(\n              new Grouping(alg, amount),\n              savedCharIndex,\n              this.#idx,\n            ),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\"^\")) {\n        if (!algDebugGlobals.caratNISSNotationEnabled) {\n          throw new Error(\n            \"Alg contained a carat but carat NISS notation is not enabled.\",\n          );\n        }\n\n        this.mustConsumeNext(\"(\");\n        const alg = this.parseAlgWithStopping([\")\"]);\n        this.popNext();\n\n        const grouping = new Grouping(alg, -1);\n        const placeholder = new Pause();\n\n        grouping.experimentalNISSPlaceholder = placeholder;\n        placeholder.experimentalNISSGrouping = grouping;\n\n        this.#nissQueue.push(grouping);\n        algBuilder.push(placeholder);\n      } else if (this.tryConsumeNext(\"[\")) {\n        mustNotBeCrowded(savedCharIndex);\n        const A = this.parseAlgWithStopping([\",\", \":\"]);\n        const separator = this.popNext();\n        const B = this.parseAlgWithStopping([\"]\"]);\n        this.mustConsumeNext(\"]\");\n        switch (separator) {\n          case \":\":\n            algBuilder.push(\n              addCharIndices(new Conjugate(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          case \",\":\n            algBuilder.push(\n              addCharIndices(new Commutator(A, B), savedCharIndex, this.#idx),\n            );\n            crowded = true;\n            algEndIdx = this.#idx;\n            continue mainLoop;\n          default:\n            throw new Error(\"unexpected parsing error\");\n        }\n      } else if (this.tryConsumeNext(\"\\n\")) {\n        algBuilder.push(\n          addCharIndices(new Newline(), savedCharIndex, this.#idx),\n        );\n        crowded = false;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else if (this.tryConsumeNext(\"/\")) {\n        if (this.tryConsumeNext(\"/\")) {\n          mustNotBeCrowded(savedCharIndex);\n          const [text] = this.parseRegex(COMMENT_TEXT_REGEX);\n          algBuilder.push(\n            addCharIndices(new LineComment(text), savedCharIndex, this.#idx),\n          );\n          crowded = false;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        } else {\n          // We allow crowding here to account for csTimer scrambles, which don't have a space between a Square-1 tuple and the following slash.\n          algBuilder.push(\n            addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx),\n          );\n          crowded = true;\n          algEndIdx = this.#idx;\n          continue mainLoop;\n        }\n      } else if (this.tryConsumeNext(\".\")) {\n        mustNotBeCrowded(savedCharIndex);\n        algBuilder.push(addCharIndices(new Pause(), savedCharIndex, this.#idx));\n        crowded = true;\n        algEndIdx = this.#idx;\n        continue mainLoop;\n      } else {\n        throw new Error(`Unexpected character: ${this.popNext()}`);\n      }\n    }\n\n    if (this.#idx !== this.#input.length) {\n      throw new Error(\"did not finish parsing?\");\n    }\n    if (stopBefore.length > 0) {\n      throw new Error(\"expected stopping\");\n    }\n    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);\n  }\n\n  private parseQuantumMoveImpl(): QuantumMove {\n    const [, , , outerLayerStr, innerLayerStr, family] =\n      this.parseRegex(QUANTUM_MOVE_REGEX);\n\n    return new QuantumMove(\n      family,\n      parseIntWithEmptyFallback(innerLayerStr, undefined),\n      parseIntWithEmptyFallback(outerLayerStr, undefined),\n    );\n  }\n\n  private parseMoveImpl(): Parsed<Move> {\n    const savedCharIndex = this.#idx;\n\n    if (this.tryConsumeNext(\"/\")) {\n      return addCharIndices(new Move(\"_SLASH_\"), savedCharIndex, this.#idx);\n    }\n\n    let quantumMove = this.parseQuantumMoveImpl();\n    // Only `hadEmptyAbsAmount` is `const`.\n    // eslint-disable-next-line prefer-const\n    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();\n    const suffix = this.parseMoveSuffix();\n\n    if (suffix) {\n      if (amount < 0) {\n        throw new Error(\"uh-oh\");\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && amount !== 1) {\n        // TODO: Handle 1 vs. null\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount other than 1.\",\n        );\n      }\n      if ((suffix === \"++\" || suffix === \"--\") && !hadEmptyAbsAmount) {\n        throw new Error(\n          \"Pochmann ++ or -- moves cannot have an amount written as a number.\",\n        );\n      }\n      if ((suffix === \"+\" || suffix === \"-\") && hadEmptyAbsAmount) {\n        throw new Error(\n          \"Clock dial moves must have an amount written as a natural number followed by + or -.\",\n        );\n      }\n      if (suffix.startsWith(\"+\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"+\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n      }\n      if (suffix.startsWith(\"-\")) {\n        quantumMove = quantumMove.modified({\n          family: `${quantumMove.family}_${\n            suffix === \"-\" ? \"PLUS\" : \"PLUSPLUS\"\n          }_`, // TODO\n        });\n        amount *= -1;\n      }\n    }\n\n    const move = addCharIndices(\n      new Move(quantumMove, amount),\n      savedCharIndex,\n      this.#idx,\n    );\n    return move;\n  }\n\n  private parseMoveSuffix(): MoveSuffix | null {\n    if (this.tryConsumeNext(\"+\")) {\n      if (this.tryConsumeNext(\"+\")) {\n        return \"++\";\n      }\n      return \"+\";\n    }\n    if (this.tryConsumeNext(\"-\")) {\n      if (this.tryConsumeNext(\"-\")) {\n        return \"--\";\n      }\n      return \"-\";\n    }\n    return null;\n  }\n\n  private parseAmountAndTrackEmptyAbsAmount(): [number, boolean] {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return [\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1),\n      !absAmountStr,\n    ];\n  }\n\n  private parseAmount(): number {\n    const savedIdx = this.#idx;\n    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);\n    if (absAmountStr?.startsWith(\"0\") && absAmountStr !== \"0\") {\n      throw new Error(\n        `Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`,\n      );\n    }\n    return (\n      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === \"'\" ? -1 : 1)\n    );\n  }\n\n  private parseRegex(regex: RegExp): RegExpExecArray {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      throw new Error(\"internal parsing error\"); // TODO\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  // TOD: can we avoid this?\n  private tryRegex(regex: RegExp): RegExpExecArray | null {\n    const arr = regex.exec(this.remaining());\n    if (arr === null) {\n      return null;\n    }\n    this.#idx += arr[0].length;\n    return arr;\n  }\n\n  private remaining(): string {\n    return this.#input.slice(this.#idx);\n  }\n\n  private popNext(): string {\n    const next = this.#input[this.#idx];\n    this.#idx++;\n    return next;\n  }\n\n  private tryConsumeNext(expected: string): boolean {\n    if (this.#input[this.#idx] === expected) {\n      this.#idx++;\n      return true;\n    }\n    return false;\n  }\n\n  private mustConsumeNext(expected: string): string {\n    const next = this.popNext();\n    if (next !== expected) {\n      throw new Error(\n        `expected \\`${expected}\\` while parsing, encountered ${next}`,\n      ); // TODO: be more helpful\n    }\n    return next;\n  }\n}\n", "const warned = new Set<string>();\nexport function warnOnce(s: string): void {\n  if (!warned.has(s)) {\n    console.warn(s);\n    warned.add(s);\n  }\n}\n", "import type { Repeatable } from \"../common\";\nimport { IterationDirection, toggleDirection } from \"../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION, MIN_INT } from \"../limits\";\nimport type { AlgLeafNode } from \"./AlgNode\";\n\nexport class QuantumWithAmount<Q extends Repeatable> {\n  readonly quantum: Q;\n  readonly amount: number;\n\n  constructor(quantum: Q, amount: number = 1) {\n    this.quantum = quantum;\n    this.amount = amount;\n\n    if (\n      !Number.isInteger(this.amount) ||\n      this.amount < MIN_INT ||\n      this.amount > MAX_INT\n    ) {\n      throw new Error(\n        `AlgNode amount absolute value must be a non-negative integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n  }\n\n  suffix(): string {\n    let s: string = \"\";\n    // TODO\n    const absAmount = Math.abs(this.amount);\n    if (absAmount !== 1) {\n      s += absAmount;\n    }\n    if (this.amount < 0) {\n      s += \"'\";\n    }\n    return s;\n  }\n\n  isIdentical(other: QuantumWithAmount<Q>): boolean {\n    return (\n      this.quantum.isIdentical(other.quantum) && this.amount === other.amount\n    );\n  }\n\n  // TODO: `Conjugate` and `Commutator` decrement `depth` inside the quantum, `Grouping` has to do it outside the quantum.\n  *experimentalExpand(\n    iterDir: IterationDirection,\n    depth: number,\n  ): Generator<AlgLeafNode> {\n    const absAmount = Math.abs(this.amount);\n    const newIterDir = toggleDirection(iterDir, this.amount < 0);\n    for (let i = 0; i < absAmount; i++) {\n      yield* this.quantum.experimentalExpand(newIterDir, depth);\n    }\n  }\n}\n", "import { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { MAX_INT, MAX_INT_DESCRIPTION } from \"../../limits\";\nimport { parseMove, parseQuantumMove, transferCharIndex } from \"../../parse\";\nimport { warnOnce } from \"../../warnOnce\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { AlgLeafNode } from \"../AlgNode\";\n\ninterface QuantumMoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n}\n\nexport class QuantumMove extends Comparable {\n  readonly #family: string;\n  readonly #innerLayer: number | null;\n  readonly #outerLayer: number | null;\n\n  constructor(\n    family: string,\n    innerLayer?: number | null,\n    outerLayer?: number | null,\n  ) {\n    super();\n    this.#family = family;\n    this.#innerLayer = innerLayer ?? null;\n    this.#outerLayer = outerLayer ?? null;\n    Object.freeze(this);\n\n    if (\n      this.#innerLayer !== null &&\n      (!Number.isInteger(this.#innerLayer) ||\n        this.#innerLayer < 1 ||\n        this.#innerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      (!Number.isInteger(this.#outerLayer) ||\n        this.#outerLayer < 1 ||\n        this.#outerLayer > MAX_INT)\n    ) {\n      throw new Error(\n        `QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`,\n      );\n    }\n\n    if (\n      this.#outerLayer !== null &&\n      this.#innerLayer !== null &&\n      this.#innerLayer <= this.#outerLayer\n    ) {\n      throw new Error(\n        \"QuantumMove outer layer must be smaller than inner layer.\",\n      );\n    }\n\n    if (this.#outerLayer !== null && this.#innerLayer === null) {\n      throw new Error(\n        \"QuantumMove with an outer layer must have an inner layer\",\n      ); // TODO: test\n    }\n  }\n\n  static fromString(s: string): QuantumMove {\n    return parseQuantumMove(s);\n  }\n\n  // TODO: `modify`?\n  modified(modifications: QuantumMoveModifications): QuantumMove {\n    return new QuantumMove(\n      modifications.family ?? this.#family,\n      modifications.innerLayer ?? this.#innerLayer,\n      modifications.outerLayer ?? this.#outerLayer,\n    );\n  }\n\n  isIdentical(other: QuantumMove): boolean {\n    const otherAsQuantumMove = other;\n    return (\n      other.is(QuantumMove) &&\n      this.#family === otherAsQuantumMove.#family &&\n      this.#innerLayer === otherAsQuantumMove.#innerLayer &&\n      this.#outerLayer === otherAsQuantumMove.#outerLayer\n    );\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get family(): string {\n    return this.#family;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get outerLayer(): number | null {\n    return this.#outerLayer;\n  }\n\n  // TODO: provide something more useful on average.\n  /** @deprecated */\n  get innerLayer(): number | null {\n    return this.#innerLayer;\n  }\n\n  experimentalExpand(): Generator<AlgLeafNode> {\n    throw new Error(\n      \"experimentalExpand() cannot be called on a `QuantumMove` directly.\",\n    );\n  }\n\n  toString(): string {\n    let s = this.#family;\n    if (this.#innerLayer !== null) {\n      s = String(this.#innerLayer) + s;\n      if (this.#outerLayer !== null) {\n        s = String(this.#outerLayer) + \"-\" + s;\n      }\n    }\n    return s;\n  }\n}\n\nexport interface MoveModifications {\n  outerLayer?: number;\n  innerLayer?: number;\n  family?: string;\n  amount?: number;\n}\n\n/** @category Alg Nodes */\nexport class Move extends AlgCommon<Move> {\n  readonly #quantumWithAmount: QuantumWithAmount<QuantumMove>;\n\n  constructor(\n    ...args: [QuantumMove] | [QuantumMove, number] | [string] | [string, number]\n  ) {\n    super();\n    if (typeof args[0] === \"string\") {\n      if (args[1] ?? null) {\n        this.#quantumWithAmount = new QuantumWithAmount(\n          QuantumMove.fromString(args[0]),\n          args[1],\n        );\n        return;\n      } else {\n        return Move.fromString(args[0]); // TODO: can we return here?\n      }\n    }\n    this.#quantumWithAmount = new QuantumWithAmount<QuantumMove>(\n      args[0],\n      args[1],\n    );\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsMove = other.as(Move);\n    return (\n      !!otherAsMove &&\n      this.#quantumWithAmount.isIdentical(otherAsMove.#quantumWithAmount)\n    );\n  }\n\n  invert(): Move {\n    // TODO: handle char indices more consistently among alg nodes.\n    return transferCharIndex(\n      this,\n      new Move(this.#quantumWithAmount.quantum, -this.amount),\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n  ): Generator<AlgLeafNode> {\n    if (iterDir === IterationDirection.Forwards) {\n      yield this;\n    } else {\n      yield this.modified({\n        amount: -this.amount,\n      });\n    }\n  }\n\n  get quantum(): QuantumMove {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  // TODO: `modify`?\n  modified(modifications: MoveModifications): Move {\n    // TODO: Avoid creating a new quantum move\n    return new Move(\n      this.#quantumWithAmount.quantum.modified(modifications),\n      modifications.amount ?? this.amount,\n    );\n  }\n\n  static fromString(s: string): Move {\n    return parseMove(s);\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"blockMove\";\n  }\n\n  /** @deprecated */\n  get family(): string {\n    return this.#quantumWithAmount.quantum.family ?? undefined;\n  }\n\n  /** @deprecated */\n  get outerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.outerLayer ?? undefined;\n  }\n\n  /** @deprecated */\n  get innerLayer(): number | undefined {\n    return this.#quantumWithAmount.quantum.innerLayer ?? undefined;\n  }\n\n  toString(): string {\n    if (this.family === \"_SLASH_\") {\n      return \"/\"; // TODO: validate no amount\n    }\n    if (this.family.endsWith(\"_PLUS_\")) {\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -6) +\n        Math.abs(this.amount) +\n        (this.amount < 0 ? \"-\" : \"+\")\n      ); // TODO\n    }\n    if (this.family.endsWith(\"_PLUSPLUS_\")) {\n      const absAmount = Math.abs(this.amount);\n      return (\n        this.#quantumWithAmount.quantum.toString().slice(0, -10) +\n        (absAmount === 1 ? \"\" : absAmount) +\n        (this.amount < 0 ? \"--\" : \"++\")\n      ); // TODO\n    }\n\n    return (\n      this.#quantumWithAmount.quantum.toString() +\n      this.#quantumWithAmount.suffix()\n    );\n  }\n\n  // // TODO: Serialize as a string?\n  // toJSON(): MoveJSON {\n  //   return {\n  //     type: \"move\",\n  //     family: this.family,\n  //     innerLayer: this.innerLayer,\n  //     outerLayer: this.outerLayer,\n  //   };\n  // }\n}\n", "import { Alg, experimentalEnsureAlg, FlexibleAlgSource } from \"../../Alg\";\nimport { AlgCommon, Comparable } from \"../../common\";\nimport { IterationDirection } from \"../../iteration\";\nimport { Move, QuantumMove } from \"../leaves/Move\";\nimport type { Pause } from \"../leaves/Pause\";\nimport { QuantumWithAmount } from \"../QuantumWithAmount\";\nimport type { AlgLeafNode } from \"../AlgNode\";\n\n// This is a workaround for `jest`, which doesn't handle cycles of imports inside `cubing/alg`.\n// We need to lazy-initialize the reusable quantum moves for Square-1, so we create this wrapper for it.\nclass Square1TupleFormatter {\n  quantumU_SQ_: QuantumMove | null = null;\n  quantumD_SQ_: QuantumMove | null = null;\n\n  format(grouping: Grouping): string | null {\n    const amounts = this.tuple(grouping);\n    if (!amounts) {\n      return null;\n    }\n    return `(${amounts.map((move) => move.amount).join(\", \")})`;\n  }\n\n  tuple(grouping: Grouping): [moveU: Move, moveD: Move] | null {\n    this.quantumU_SQ_ ||= new QuantumMove(\"U_SQ_\");\n    this.quantumD_SQ_ ||= new QuantumMove(\"D_SQ_\");\n\n    const quantumAlg = grouping.alg;\n    if (quantumAlg.experimentalNumChildAlgNodes() === 2) {\n      const [U, D] = quantumAlg.childAlgNodes();\n      if (\n        U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) &&\n        D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)\n      ) {\n        if (grouping.amount !== 1) {\n          throw new Error(\n            \"Square-1 tuples cannot have an amount other than 1.\",\n          );\n        }\n        return [U as Move, D as Move]; // TODO: can we reuse the casting from above?\n      }\n    }\n    return null;\n  }\n}\nconst square1TupleFormatterInstance = new Square1TupleFormatter();\n\n/** @category Alg Nodes */\nexport class Grouping extends AlgCommon<Grouping> {\n  readonly #quantumWithAmount: QuantumWithAmount<Alg>;\n  experimentalNISSPlaceholder?: Pause; // TODO: tie this to the alg\n\n  constructor(algSource: FlexibleAlgSource, amount?: number) {\n    super();\n    const alg = experimentalEnsureAlg(algSource);\n    this.#quantumWithAmount = new QuantumWithAmount(alg, amount);\n  }\n\n  isIdentical(other: Comparable): boolean {\n    const otherAsGrouping = other as Grouping;\n    return (\n      other.is(Grouping) &&\n      this.#quantumWithAmount.isIdentical(otherAsGrouping.#quantumWithAmount)\n    );\n  }\n\n  get alg(): Alg {\n    return this.#quantumWithAmount.quantum;\n  }\n\n  get amount(): number {\n    return this.#quantumWithAmount.amount;\n  }\n\n  /** @deprecated */\n  get experimentalRepetitionSuffix(): string {\n    return this.#quantumWithAmount.suffix();\n  }\n\n  invert(): Grouping {\n    return new Grouping(\n      this.#quantumWithAmount.quantum,\n      -this.#quantumWithAmount.amount,\n    );\n  }\n\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeafNode> {\n    depth ??= Infinity;\n    if (depth === 0) {\n      yield iterDir === IterationDirection.Forwards ? this : this.invert();\n    } else {\n      yield* this.#quantumWithAmount.experimentalExpand(iterDir, depth - 1);\n    }\n  }\n\n  static fromString(): Grouping {\n    throw new Error(\"unimplemented\");\n  }\n\n  toString(): string {\n    return (\n      square1TupleFormatterInstance.format(this) ??\n      `(${this.#quantumWithAmount.quantum.toString()})${this.#quantumWithAmount.suffix()}`\n    );\n  }\n\n  experimentalAsSquare1Tuple(): [moveU: Move, moveD: Move] | null {\n    return square1TupleFormatterInstance.tuple(this);\n  }\n\n  // toJSON(): GroupingJSON {\n  //   return {\n  //     type: \"grouping\",\n  //     alg: this.#quanta.quantum.toJSON(),\n  //   };\n  // }\n}\n", "import type { Alg } from \"./Alg\";\nimport {\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n} from \"./alg-nodes\";\n\nexport function experimentalIs(\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  v: any,\n  c:\n    | typeof Alg\n    | typeof Grouping\n    | typeof LineComment\n    | typeof Commutator\n    | typeof Conjugate\n    | typeof Move\n    | typeof Newline\n    | typeof Pause,\n): boolean {\n  return v instanceof c;\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function experimentalIsAlgNode(v: any): boolean {\n  return (\n    experimentalIs(v, Grouping) ||\n    experimentalIs(v, LineComment) ||\n    experimentalIs(v, Commutator) ||\n    experimentalIs(v, Conjugate) ||\n    experimentalIs(v, Move) ||\n    experimentalIs(v, Newline) ||\n    experimentalIs(v, Pause)\n  );\n}\n", "import type { Alg } from \"./Alg\";\nimport { Grouping } from \"./alg-nodes/containers/Grouping\";\nimport type { Comparable } from \"./common\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Move, QuantumMove } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport type { AlgNode } from \"./alg-nodes/AlgNode\";\n\nfunction dispatch<DataDown, DataAlgUp, DataAlgNodeUp>(\n  t: TraversalDownUp<DataDown, DataAlgUp, DataAlgNodeUp>,\n  algNode: AlgNode,\n  dataDown: DataDown,\n): DataAlgNodeUp {\n  // TODO: Can we turn this back into a `switch` or something more efficiently?\n  if (algNode.is(Grouping)) {\n    return t.traverseGrouping(algNode as Grouping, dataDown);\n  }\n  if (algNode.is(Move)) {\n    return t.traverseMove(algNode as Move, dataDown);\n  }\n  if (algNode.is(Commutator)) {\n    return t.traverseCommutator(algNode as Commutator, dataDown);\n  }\n  if (algNode.is(Conjugate)) {\n    return t.traverseConjugate(algNode as Conjugate, dataDown);\n  }\n  if (algNode.is(Pause)) {\n    return t.traversePause(algNode as Pause, dataDown);\n  }\n  if (algNode.is(Newline)) {\n    return t.traverseNewline(algNode as Newline, dataDown);\n  }\n  if (algNode.is(LineComment)) {\n    return t.traverseLineComment(algNode as LineComment, dataDown);\n  }\n  throw new Error(`unknown AlgNode`);\n}\n\nfunction mustBeAlgNode(t: Comparable): AlgNode {\n  if (\n    t.is(Grouping) ||\n    t.is(Move) ||\n    t.is(Commutator) ||\n    t.is(Conjugate) ||\n    t.is(Pause) ||\n    t.is(Newline) ||\n    t.is(LineComment)\n  ) {\n    return t as AlgNode;\n  }\n  throw new Error(\"internal error: expected AlgNode\"); // TODO: Make more helpful, add tests\n}\n\nexport abstract class TraversalDownUp<\n  DataDown,\n  DataAlgUp,\n  DataAlgNodeUp = DataAlgUp,\n> {\n  // Immediate subclasses should overwrite this.\n  public traverseAlgNode(algNode: AlgNode, dataDown: DataDown): DataAlgNodeUp {\n    return dispatch(this, algNode, dataDown);\n  }\n\n  public traverseIntoAlgNode(algNode: AlgNode, dataDown: DataDown): AlgNode {\n    return mustBeAlgNode(this.traverseAlgNode(algNode, dataDown) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg, dataDown: DataDown): DataAlgUp;\n\n  public abstract traverseGrouping(\n    grouping: Grouping,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseMove(move: Move, dataDown: DataDown): DataAlgNodeUp;\n\n  public abstract traverseCommutator(\n    commutator: Commutator,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseConjugate(\n    conjugate: Conjugate,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traversePause(\n    pause: Pause,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n  public abstract traverseNewline(\n    newline: Newline,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n\n  public abstract traverseLineComment(\n    comment: LineComment,\n    dataDown: DataDown,\n  ): DataAlgNodeUp;\n}\n\nexport abstract class TraversalUp<\n  DataAlgUp,\n  DataAlgNodeUp = DataAlgUp,\n> extends TraversalDownUp<undefined, DataAlgUp, DataAlgNodeUp> {\n  public traverseAlgNode(algNode: AlgNode): DataAlgNodeUp {\n    return dispatch<unknown, DataAlgUp, DataAlgNodeUp>(\n      this,\n      algNode,\n      undefined,\n    );\n  }\n\n  public traverseIntoAlgNode(algNode: AlgNode): AlgNode {\n    return mustBeAlgNode(this.traverseAlgNode(algNode) as any);\n  }\n\n  public abstract traverseAlg(alg: Alg): DataAlgUp;\n  public abstract traverseGrouping(grouping: Grouping): DataAlgNodeUp;\n  public abstract traverseMove(move: Move): DataAlgNodeUp;\n  public abstract traverseCommutator(commutator: Commutator): DataAlgNodeUp;\n  public abstract traverseConjugate(conjugate: Conjugate): DataAlgNodeUp;\n  public abstract traversePause(pause: Pause): DataAlgNodeUp;\n  public abstract traverseNewline(newline: Newline): DataAlgNodeUp;\n  public abstract traverseLineComment(comment: LineComment): DataAlgNodeUp;\n}\n\nexport interface SimplifyOptions {\n  collapseMoves?: boolean;\n  quantumMoveOrder?: (quantumMove: QuantumMove) => number;\n  depth?: number | null; // TODO: test\n}\n\n// TODO: Test that inverses are bijections.\nclass Simplify extends TraversalDownUp<SimplifyOptions, Generator<AlgNode>> {\n  #newPlaceholderAssociationsMap?: Map<Grouping, Pause>;\n  #newPlaceholderAssociations(): Map<Grouping, Pause> {\n    return (this.#newPlaceholderAssociationsMap ??= new Map<Grouping, Pause>());\n  }\n\n  static #newAmount(\n    move: Move,\n    deltaAmount: number,\n    options: SimplifyOptions,\n  ): number {\n    let newAmount = move.amount + deltaAmount;\n    if (options?.quantumMoveOrder) {\n      const order = options.quantumMoveOrder(move.quantum);\n      // Examples:\n      // \u2022 order 4 \u2192 min -1 (e.g. cube)\n      // \u2022 order 5 \u2192 min -2 (e.g. Megaminx)\n      // \u2022 order 3 \u2192 min -1 (e.g. Pyraminx)\n      const min = Math.floor(order / 2) + 1 - order;\n      newAmount = (((newAmount % order) + order - min) % order) + min; // TODO\n    }\n    return newAmount;\n  }\n\n  // TODO: Handle\n  public *traverseAlg(alg: Alg, options: SimplifyOptions): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield* alg.childAlgNodes();\n      return;\n    }\n\n    const newAlgNodes: AlgNode[] = [];\n    let lastAlgNode: AlgNode | null = null;\n    const collapseMoves = options?.collapseMoves ?? true;\n    function appendMoveWithNewAmount(move: Move, deltaAmount: number): boolean {\n      const newAmount = Simplify.#newAmount(move, deltaAmount, options);\n      if (newAmount === 0) {\n        return false;\n      }\n      const newMove = new Move(move.quantum, newAmount);\n      newAlgNodes.push(newMove);\n      lastAlgNode = newMove;\n      return true;\n    }\n    function appendCollapsed(newAlgNode: AlgNode) {\n      if (\n        collapseMoves &&\n        lastAlgNode?.is(Move) &&\n        newAlgNode.is(Move) &&\n        (lastAlgNode as Move).quantum.isIdentical((newAlgNode as Move).quantum)\n      ) {\n        newAlgNodes.pop();\n        if (\n          !appendMoveWithNewAmount(\n            lastAlgNode as Move,\n            (newAlgNode as Move).amount,\n          )\n        ) {\n          lastAlgNode = newAlgNodes.slice(-1)[0];\n        }\n      } else {\n        if (newAlgNode.is(Move)) {\n          appendMoveWithNewAmount(newAlgNode as Move, 0);\n        } else {\n          newAlgNodes.push(newAlgNode);\n          lastAlgNode = newAlgNode;\n        }\n      }\n    }\n\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    for (const algNode of alg.childAlgNodes()) {\n      for (const ancestorAlgNode of this.traverseAlgNode(algNode, newOptions)) {\n        appendCollapsed(ancestorAlgNode);\n      }\n    }\n    for (const newAlgNode of newAlgNodes) {\n      yield newAlgNode;\n    }\n  }\n\n  public *traverseGrouping(\n    grouping: Grouping,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield grouping;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    const newGrouping = new Grouping(\n      this.traverseAlg(grouping.alg, newOptions),\n      grouping.amount,\n    );\n\n    const newPlaceholder = this.#newPlaceholderAssociations().get(grouping);\n    if (newPlaceholder) {\n      newGrouping.experimentalNISSPlaceholder = newPlaceholder;\n      newPlaceholder.experimentalNISSGrouping = newGrouping;\n    }\n\n    yield newGrouping;\n  }\n\n  public *traverseMove(\n    move: Move,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield move;\n  }\n\n  public *traverseCommutator(\n    commutator: Commutator,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield commutator;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Commutator(\n      this.traverseAlg(commutator.A, newOptions),\n      this.traverseAlg(commutator.B, newOptions),\n    );\n  }\n\n  public *traverseConjugate(\n    conjugate: Conjugate,\n    options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (options.depth === 0) {\n      yield conjugate;\n      return;\n    }\n    const newOptions = {\n      depth: options.depth ? options.depth - 1 : null,\n    }; // TODO: avoid allocations?\n    yield new Conjugate(\n      this.traverseAlg(conjugate.A, newOptions),\n      this.traverseAlg(conjugate.B, newOptions),\n    );\n  }\n\n  public *traversePause(\n    pause: Pause,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    if (pause.experimentalNISSGrouping) {\n      const newPause = new Pause();\n      this.#newPlaceholderAssociations().set(\n        pause.experimentalNISSGrouping,\n        newPause,\n      );\n      yield newPause;\n    } else {\n      yield pause;\n    }\n  }\n\n  public *traverseNewline(\n    newline: Newline,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield newline;\n  }\n\n  public *traverseLineComment(\n    comment: LineComment,\n    _options: SimplifyOptions,\n  ): Generator<AlgNode> {\n    yield comment;\n  }\n}\n\nconst simplifyInstance = new Simplify();\nexport const simplify = simplifyInstance.traverseAlg.bind(simplifyInstance) as (\n  alg: Alg,\n  options: SimplifyOptions,\n) => Generator<AlgNode>;\n", "// https://js.cubing.net/cubing/alg/\n\nimport { AlgCommon, Comparable } from \"./common\";\nimport { experimentalIs, experimentalIsAlgNode } from \"./is\";\nimport { direct, IterationDirection, reverse } from \"./iteration\";\nimport { parseAlg } from \"./parse\";\nimport { simplify, SimplifyOptions } from \"./traversal\";\nimport { Grouping, Pause } from \"./alg-nodes\";\nimport { LineComment } from \"./alg-nodes/leaves/LineComment\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Newline } from \"./alg-nodes/leaves/Newline\";\nimport type { AlgLeafNode, AlgNode } from \"./alg-nodes/AlgNode\";\nimport { warnOnce } from \"./warnOnce\";\n\nexport type FlexibleAlgSource = string | Iterable<AlgNode> | Alg;\n\n// TODO: validate\nfunction toIterable(input?: FlexibleAlgSource): Iterable<AlgNode> {\n  if (!input) {\n    return [];\n  }\n\n  if (experimentalIs(input, Alg)) {\n    return (input as Alg).childAlgNodes();\n  }\n\n  if (typeof input === \"string\") {\n    return parseAlg(input).childAlgNodes(); // TODO: something more direct?\n  }\n\n  const iter = input as Iterable<AlgNode>;\n  if (typeof iter[Symbol.iterator] === \"function\") {\n    return iter; // TODO: avoid allocations\n  }\n\n  throw new Error(\"Invalid AlgNode\");\n}\n\n// Preserves the alg if it's already an `Alg`.\nexport function experimentalEnsureAlg(alg: FlexibleAlgSource): Alg {\n  if (experimentalIs(alg, Alg)) {\n    return alg as Alg;\n  }\n  return new Alg(alg);\n}\n\n/**\n * Alg is a class that encapsulates a structured alg. To create an alg from a string, use:\n *\n *     new Alg(\"R U R'\"); // Convenient\n *     Alg.fromString(dynamicString); // Recommended when user-provided string input.\n *\n * Once you have an Alg, you can call methods to transform it:\n *\n *     new Alg(\"[[R: U], R U R2']\").expand().simplify().invert();\n *\n * To convert an Alg to a string, use .toString():\n *\n *     new Alg(\"R U F\").invert().toString();\n *\n * If you need to debug, you may also find it convenient to use .log():\n *\n *     if (alg.isIdentical(alg.invert())) {\n *       alg.log(\"A self-inverse!\")\n *     }\n *\n * For more information, see: {@link https://js.cubing.net/cubing/alg/}\n *\n * @category Alg\n */\nexport class Alg extends AlgCommon<Alg> {\n  // #debugString: string;\n  #algNodes: Iterable<AlgNode>; // TODO: freeze?\n  constructor(alg?: FlexibleAlgSource) {\n    super();\n    this.#algNodes = Array.from(toIterable(alg)); // TODO: can we avoid array-casting?\n    // this.#debugString = this.toString();\n\n    for (const algNode of this.#algNodes) {\n      if (!experimentalIsAlgNode(algNode)) {\n        throw new Error(\"An alg can only contain alg nodes.\");\n      }\n    }\n  }\n\n  /**\n   * Checks whether this Alg is structurally identical to another Alg. This\n   * essentially means that they are written identically apart from whitespace.\n   *\n   *     const alg1 = new Alg(\"R U L'\");\n   *     const alg2 = new Alg(\"L U' R'\").invert();\n   *     // true\n   *     alg1.isIdentical(alg2);\n   *\n   *     // false\n   *     new Alg(\"[R, U]\").isIdentical(new Alg(\"R U R' U'\"));\n   *     // true\n   *     new Alg(\"[R, U]\").expand().isIdentical(new Alg(\"R U R' U'\"));\n   *\n   * Note that .isIdentical() efficiently compares algorithms, but mainly exists\n   * to help optimize code when the structure of an algorithm hasn't changed.\n   * There are many ways to write the \"same\" alg on most puzzles, but is\n   * *highly* recommended to avoid expanding two Alg instances to compare them,\n   * since that can easily slow your program to a crawl if someone inputs an alg\n   * containing a large repetition. In general, you should use `cubing/kpuzzle`\n   * to compare if two algs have the same effect on a puzzle.\n   *\n   * Also note that parser annotations are not take into account while comparing\n   * algs:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\")]);\n   *     // true, even though one of the algs has parser annotations\n   *     alg.isIdentical(new Alg(\"R U2\"))\n   *\n   */\n  isIdentical(other: Comparable): boolean {\n    const otherAsAlg = other as Alg;\n    if (!other.is(Alg)) {\n      return false;\n    }\n\n    // TODO: avoid converting to array\n    const l1 = Array.from(this.#algNodes);\n    const l2 = Array.from(otherAsAlg.#algNodes);\n    if (l1.length !== l2.length) {\n      return false;\n    }\n    for (let i = 0; i < l1.length; i++) {\n      if (!l1[i].isIdentical(l2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the inverse of the given alg.\n   *\n   * Note that that this does not make any assumptions about what puzzle the alg\n   * is for. For example, U2 is its own inverse on a cube, but U2' has the same\n   * effect U3 (and not U2) on Megaminx:\n   *\n   *     // Outputs: R U2' L'\n   *     new Alg(\"L U2 R'\").invert().log();\n   */\n  invert(): Alg {\n    // TODO: Handle newLines and comments correctly\n    // TODO: Make more efficient.\n    return new Alg(reverse(Array.from(this.#algNodes).map((u) => u.invert())));\n  }\n\n  /** @deprecated Use {@link Alg.expand} instead. */\n  *experimentalExpand(\n    iterDir: IterationDirection = IterationDirection.Forwards,\n    depth?: number,\n  ): Generator<AlgLeafNode> {\n    depth ??= Infinity;\n    for (const algNode of direct(this.#algNodes, iterDir)) {\n      yield* algNode.experimentalExpand(iterDir, depth);\n    }\n  }\n\n  /**\n   * Expands all Grouping, Commutator, and Conjugate parts nested inside the\n   * alg.\n   *\n   *     // F R U R' U' F'\n   *     new Alg(\"[F: [R, U]]\").expand().log();\n   *\n   *     // F [R, U] F'\n   *     new Alg(\"[F: [R, U]]\").expand(({ depth: 1 }).log();\n   *\n   * Avoid calling this on a user-provided alg unless the user explicitly asks\n   * to see the expanded alg. Otherwise, it's easy to make your program freeze\n   * when someone passes in an alg like: (R U)10000000\n   *\n   * Generally, if you want to perform an operation on an entire alg, you'll\n   * want to use something based on the `Traversal` mechanism, like countMoves()\n   * from `cubing/notation`.\n   */\n  expand(options?: { depth?: number }): Alg {\n    return new Alg(\n      this.experimentalExpand(\n        IterationDirection.Forwards,\n        options?.depth ?? Infinity,\n      ),\n    );\n  }\n\n  /** @deprecated */\n  *experimentalLeafMoves(): Generator<Move> {\n    for (const leaf of this.experimentalExpand()) {\n      if (leaf.is(Move)) {\n        yield leaf as Move;\n      }\n    }\n  }\n\n  concat(input: FlexibleAlgSource): Alg {\n    return new Alg(\n      Array.from(this.#algNodes).concat(Array.from(toIterable(input))),\n    );\n  }\n\n  /** @deprecated */\n  experimentalIsEmpty(): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for (const _ of this.#algNodes) {\n      return false;\n    }\n    return true;\n  }\n\n  static fromString(s: string): Alg {\n    return parseAlg(s);\n  }\n\n  /** @deprecated */\n  units(): Generator<AlgNode> {\n    return this.childAlgNodes();\n  }\n\n  *childAlgNodes(): Generator<AlgNode> {\n    for (const algNode of this.#algNodes) {\n      yield algNode;\n    }\n  }\n\n  /** @deprecated */\n  experimentalNumUnits(): number {\n    return this.experimentalNumChildAlgNodes();\n  }\n\n  experimentalNumChildAlgNodes(): number {\n    return Array.from(this.#algNodes).length;\n  }\n\n  /** @deprecated */\n  get type(): string {\n    warnOnce(\"deprecated: type\");\n    return \"sequence\";\n  }\n\n  /**\n   * Converts the Alg to a string:\n   *\n   *     const alg = new Alg([new Move(\"R\"), new Move(\"U2\"), new Move(\"L\")])\n   *     // R U2 L\n   *     console.log(alg.toString())\n   */\n  toString(): string {\n    let output = \"\";\n    let previousVisibleAlgNode: AlgNode | null = null;\n    for (const algNode of this.#algNodes) {\n      if (previousVisibleAlgNode) {\n        output += spaceBetween(previousVisibleAlgNode, algNode);\n      }\n      const nissGrouping = algNode.as(Pause)?.experimentalNISSGrouping;\n      if (nissGrouping) {\n        if (nissGrouping.amount !== -1) {\n          throw new Error(\"Invalid NISS Grouping amount!\");\n        }\n        output += `^(${nissGrouping.alg.toString()})`;\n      } else if (algNode.as(Grouping)?.experimentalNISSPlaceholder) {\n        // do not serialize (rely on the placeholder instead)\n      } else {\n        output += algNode.toString();\n      }\n      previousVisibleAlgNode = algNode;\n    }\n    return output;\n  }\n\n  simplify(options?: SimplifyOptions): Alg {\n    return new Alg(simplify(this, options ?? {}));\n  }\n}\n\nfunction spaceBetween(u1: AlgNode, u2: AlgNode): string {\n  if (u1.is(Newline) || u2.is(Newline)) {\n    return \"\";\n  }\n  if (u2.as(Grouping)?.experimentalNISSPlaceholder) {\n    return \"\";\n  }\n  if (u1.is(LineComment) && !u2.is(Newline)) {\n    return \"\\n\"; /// TODO\n  }\n  return \" \";\n}\n", "// tslint:disable-next-line no-namespace // TODO: nested module\n\nimport { Alg } from \"./Alg\";\nimport { Grouping } from \"./alg-nodes\";\nimport { Commutator } from \"./alg-nodes/containers/Commutator\";\nimport { Conjugate } from \"./alg-nodes/containers/Conjugate\";\nimport { Move } from \"./alg-nodes/leaves/Move\";\nimport { Pause } from \"./alg-nodes/leaves/Pause\";\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport const Example = {\n  Sune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -2),\n    new Move(\"R\", -1),\n  ]),\n\n  AntiSune: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 2),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n  ]),\n\n  SuneCommutator: new Alg([\n    new Commutator(\n      new Alg([new Move(\"R\", 1), new Move(\"U\", 1), new Move(\"R\", -2)]),\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n    ),\n  ]),\n\n  Niklas: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"L\", -1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"L\", 1),\n    new Move(\"U\", 1),\n  ]),\n\n  EPerm: new Alg([\n    new Move(\"x\", -1),\n    new Commutator(\n      new Alg([\n        new Conjugate(\n          new Alg([new Move(\"R\", 1)]),\n          new Alg([new Move(\"U\", -1)]),\n        ),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Commutator(\n      new Alg([\n        new Conjugate(new Alg([new Move(\"R\", 1)]), new Alg([new Move(\"U\", 1)])),\n      ]),\n      new Alg([new Move(\"D\", 1)]),\n    ),\n    new Move(\"x\", 1),\n  ]),\n\n  FURURFCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"U\", 1)]),\n          new Alg([new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  APermCompact: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"R\", 2)]),\n      new Alg([\n        new Commutator(\n          new Alg([new Move(\"F\", 2)]),\n          new Alg([new Move(\"R\", -1), new Move(\"B\", -1), new Move(\"R\", 1)]),\n        ),\n      ]),\n    ),\n  ]),\n\n  FURURFMoves: new Alg([\n    new Move(\"F\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", 1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  TPerm: new Alg([\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"F\", 1),\n    new Move(\"R\", 2),\n    new Move(\"U\", -1),\n    new Move(\"R\", -1),\n    new Move(\"U\", -1),\n    new Move(\"R\", 1),\n    new Move(\"U\", 1),\n    new Move(\"R\", -1),\n    new Move(\"F\", -1),\n  ]),\n\n  HeadlightSwaps: new Alg([\n    new Conjugate(\n      new Alg([new Move(\"F\", 1)]),\n      new Alg([\n        new Grouping(\n          new Alg([\n            new Commutator(\n              new Alg([new Move(\"R\", 1)]),\n              new Alg([new Move(\"U\", 1)]),\n            ),\n          ]),\n          3,\n        ),\n      ]),\n    ),\n  ]),\n\n  TriplePause: new Alg([new Pause(), new Pause(), new Pause()]),\n\n  // AllAlgParts: [\n  //   new Alg([new Move(\"R\", 1), new Move(\"U\", -1)]),\n  //   new Grouping(new Alg([new Move(\"F\", 1)]), 2),\n  //   // new Rotation(\"y\", -1),\n  //   new Move(\"R\", 2),\n  //   new Commutator(new Alg([new Move(\"R\", 2)]), new Alg([new Move(\"U\", 2)]), 2),\n  //   new Conjugate(new Alg([new Move(\"L\", 2)]), new Alg([new Move(\"D\", -1)]), 2),\n  //   new Pause(),\n  //   new Newline(),\n  //   new LineComment(\"line comment\"),\n  // ],\n};\n", "import { Move } from \"./alg-nodes/leaves/Move\";\n\nconst cubeKeyMapping: { [key: number]: Move } = {\n  73: new Move(\"R\"),\n  75: new Move(\"R'\"),\n  87: new Move(\"B\"),\n  79: new Move(\"B'\"),\n  83: new Move(\"D\"),\n  76: new Move(\"D'\"),\n  68: new Move(\"L\"),\n  69: new Move(\"L'\"),\n  74: new Move(\"U\"),\n  70: new Move(\"U'\"),\n  72: new Move(\"F\"),\n  71: new Move(\"F'\"),\n\n  78: new Move(\"x'\"),\n  67: new Move(\"l\"),\n  82: new Move(\"l'\"),\n  85: new Move(\"r\"),\n  77: new Move(\"r'\"),\n\n  88: new Move(\"d\"),\n  188: new Move(\"d'\"),\n\n  84: new Move(\"x\"),\n  89: new Move(\"x\"),\n  66: new Move(\"x'\"),\n  186: new Move(\"y\"),\n  59: new Move(\"y\"),\n  65: new Move(\"y'\"), // 186 is WebKit, 59 is Mozilla; see http://unixpapa.com/js/key.html\n  80: new Move(\"z\"),\n  81: new Move(\"z'\"),\n\n  90: new Move(\"M'\"),\n  190: new Move(\"M'\"),\n};\n\n// TODO: options about whether to ignore modifier keys (e.g. alt, ctrl).\n// TODO: Support different mappings.\n// TODO: Return BaseMove instead?\nexport function keyToMove(e: KeyboardEvent): Move | null {\n  if (e.altKey || e.ctrlKey) {\n    return null;\n  }\n\n  return cubeKeyMapping[e.keyCode] || null;\n}\n", "import type { Alg } from \"./Alg\";\n\n// This is not the most sophisticated scheme, but it has been used in production\n// at alg.cubing.net for years.\nfunction serializeURLParam(a: Alg): string {\n  let escaped = a.toString();\n  escaped = escaped.replace(/_/g, \"&#95;\").replace(/ /g, \"_\");\n  escaped = escaped.replace(/\\+/g, \"&#2b;\");\n  escaped = escaped.replace(/-/g, \"&#45;\").replace(/'/g, \"-\");\n  return escaped;\n}\n\nexport interface AlgCubingNetOptions {\n  alg?: Alg;\n  setup?: Alg;\n  title?: string;\n  puzzle?:\n    | \"1x1x1\"\n    | \"2x2x2\"\n    | \"3x3x3\"\n    | \"4x4x4\"\n    | \"5x5x5\"\n    | \"6x6x6\"\n    | \"7x7x7\"\n    | \"8x8x8\"\n    | \"9x9x9\"\n    | \"10x10x10\"\n    | \"11x11x11\"\n    | \"12x12x12\"\n    | \"13x13x13\"\n    | \"14x14x14\"\n    | \"16x16x16\"\n    | \"17x17x17\";\n  stage?:\n    | \"full\"\n    | \"cross\"\n    | \"F2L\"\n    | \"LL\"\n    | \"OLL\"\n    | \"PLL\"\n    | \"CLS\"\n    | \"ELS\"\n    | \"L6E\"\n    | \"CMLL\"\n    | \"WV\"\n    | \"ZBLL\"\n    | \"void\";\n  view?: \"editor\" | \"playback\" | \"fullscreen\";\n  type?: \"moves\" | \"reconstruction\" | \"alg\" | \"reconstruction-end-with-setup\";\n}\n\n// TODO: runtime validation?\nexport function algCubingNetLink(options: AlgCubingNetOptions): string {\n  const url = new URL(\"https://alg.cubing.net\");\n  if (!options.alg) {\n    throw new Error(\"An alg parameter is required.\");\n  }\n  url.searchParams.set(\"alg\", serializeURLParam(options.alg));\n\n  if (options.setup) {\n    url.searchParams.set(\"setup\", serializeURLParam(options.setup));\n  }\n  if (options.title) {\n    url.searchParams.set(\"title\", options.title);\n  }\n  if (options.puzzle) {\n    if (\n      ![\n        \"1x1x1\",\n        \"2x2x2\",\n        \"3x3x3\",\n        \"4x4x4\",\n        \"5x5x5\",\n        \"6x6x6\",\n        \"7x7x7\",\n        \"8x8x8\",\n        \"9x9x9\",\n        \"10x10x10\",\n        \"11x11x11\",\n        \"12x12x12\",\n        \"13x13x13\",\n        \"14x14x14\",\n        \"16x16x16\",\n        \"17x17x17\",\n      ].includes(options.puzzle)\n    ) {\n      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);\n    }\n    url.searchParams.set(\"puzzle\", options.puzzle);\n  }\n  if (options.stage) {\n    if (\n      ![\n        \"full\",\n        \"cross\",\n        \"F2L\",\n        \"LL\",\n        \"OLL\",\n        \"PLL\",\n        \"CLS\",\n        \"ELS\",\n        \"L6E\",\n        \"CMLL\",\n        \"WV\",\n        \"ZBLL\",\n        \"void\",\n      ].includes(options.stage)\n    ) {\n      throw new Error(`Invalid stage parameter: ${options.stage}`);\n    }\n    url.searchParams.set(\"stage\", options.stage);\n  }\n  if (options.view) {\n    if (![\"editor\", \"playback\", \"fullscreen\"].includes(options.view)) {\n      throw new Error(`Invalid view parameter: ${options.view}`);\n    }\n    url.searchParams.set(\"view\", options.view);\n  }\n  if (options.type) {\n    if (\n      ![\n        \"moves\",\n        \"reconstruction\",\n        \"alg\",\n        \"reconstruction-end-with-setup\",\n      ].includes(options.type)\n    ) {\n      throw new Error(`Invalid type parameter: ${options.type}`);\n    }\n    url.searchParams.set(\"type\", options.type);\n  }\n  return url.toString();\n}\n", "import { Alg } from \"./Alg\";\nimport type { Move } from \"./alg-nodes/leaves/Move\";\n\nexport function experimentalAppendMove(\n  alg: Alg,\n  newMove: Move,\n  options?: {\n    coalesce?: boolean; // defaults to false\n    mod?: number;\n  },\n): Alg {\n  const oldAlgNodes = Array.from(alg.childAlgNodes());\n  const oldLastMove = oldAlgNodes[oldAlgNodes.length - 1] as Move | undefined;\n  if (\n    options?.coalesce &&\n    oldLastMove &&\n    oldLastMove.quantum &&\n    oldLastMove.quantum.isIdentical(newMove.quantum)\n  ) {\n    const newAlgNodes = oldAlgNodes.slice(0, oldAlgNodes.length - 1);\n    let newAmount = oldLastMove.amount + newMove.amount;\n    const mod = options?.mod;\n    if (mod) {\n      newAmount = ((newAmount % mod) + mod) % mod;\n      if (newAmount * 2 > mod) {\n        newAmount -= mod;\n      }\n    }\n    if (newAmount !== 0) {\n      newAlgNodes.push(oldLastMove.modified({ amount: newAmount }));\n    }\n    return new Alg(newAlgNodes);\n  } else {\n    return new Alg([...oldAlgNodes, newMove]);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
