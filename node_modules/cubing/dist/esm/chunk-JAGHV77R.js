import {
  PuzzleStickering,
  StickeringManager,
  experimental3x3x3KPuzzle,
  experimentalStickerings
} from "./chunk-LTPPXK6F.js";
import {
  KPuzzle
} from "./chunk-UP6RBLG2.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-MGJA5U5O.js";

// src/cubing/puzzles/events.ts
var wcaEvents = {
  "333": { puzzleID: "3x3x3", eventName: "3x3x3 Cube" },
  "222": { puzzleID: "2x2x2", eventName: "2x2x2 Cube" },
  "444": { puzzleID: "4x4x4", eventName: "4x4x4 Cube" },
  "555": { puzzleID: "5x5x5", eventName: "5x5x5 Cube" },
  "666": { puzzleID: "6x6x6", eventName: "6x6x6 Cube" },
  "777": { puzzleID: "7x7x7", eventName: "7x7x7 Cube" },
  "333bf": { puzzleID: "3x3x3", eventName: "3x3x3 Blindfolded" },
  "333fm": { puzzleID: "3x3x3", eventName: "3x3x3 Fewest Moves" },
  "333oh": { puzzleID: "3x3x3", eventName: "3x3x3 One-Handed" },
  "clock": { puzzleID: "clock", eventName: "Clock" },
  "minx": { puzzleID: "megaminx", eventName: "Megaminx" },
  "pyram": { puzzleID: "pyraminx", eventName: "Pyraminx" },
  "skewb": { puzzleID: "skewb", eventName: "Skewb" },
  "sq1": { puzzleID: "square1", eventName: "Square-1" },
  "444bf": { puzzleID: "4x4x4", eventName: "4x4x4 Blindfolded" },
  "555bf": { puzzleID: "5x5x5", eventName: "5x5x5 Blindfolded" },
  "333mb": { puzzleID: "3x3x3", eventName: "3x3x3 Multi-Blind" }
};
function wcaEventInfo(event) {
  return wcaEvents[event] ?? null;
}
var events = {
  ...wcaEvents,
  fto: { puzzleID: "fto", eventName: "Face-Turning Octahedron" },
  master_tetraminx: {
    puzzleID: "master_tetraminx",
    eventName: "Master Tetraminx"
  },
  kilominx: {
    puzzleID: "kilominx",
    eventName: "Kilominx"
  },
  redi_cube: {
    puzzleID: "redi_cube",
    eventName: "Redi Cube"
  }
};
function eventInfo(event) {
  return events[event] ?? null;
}

// src/cubing/puzzles/stickerings/cube-stickerings.ts
async function cubeAppearance(puzzleLoader, stickering) {
  const kpuzzle = await puzzleLoader.kpuzzle();
  const puzzleStickering = new PuzzleStickering(kpuzzle);
  const m = new StickeringManager(kpuzzle);
  const LL = () => m.move("U");
  const orUD = () => m.or(m.moves(["U", "D"]));
  const orLR = () => m.or(m.moves(["L", "R"]));
  const M = () => m.not(orLR());
  const F2L = () => m.not(LL());
  const centerLL = () => m.and([LL(), m.orbits(["CENTERS"])]);
  const CENTERS = () => m.orbits(["CENTERS"]);
  const EDGES = () => m.orbits(["EDGES"]);
  const CORNERS = () => m.orbits(["CORNERS"]);
  const L6E = () => m.or([M(), m.and([LL(), EDGES()])]);
  const edgeFR = () => m.and([m.and(m.moves(["F", "R"])), EDGES()]);
  const cornerDFR = () => m.and([m.and(m.moves(["F", "R"])), CORNERS(), m.not(LL())]);
  const slotFR = () => m.or([cornerDFR(), edgeFR()]);
  function dimF2L() {
    puzzleStickering.set(F2L(), "Dim" /* Dim */);
  }
  function setPLL() {
    puzzleStickering.set(LL(), "PermuteNonPrimary" /* PermuteNonPrimary */);
    puzzleStickering.set(centerLL(), "Dim" /* Dim */);
  }
  function setOLL() {
    puzzleStickering.set(LL(), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
    puzzleStickering.set(centerLL(), "Regular" /* Regular */);
  }
  function dimOLL() {
    puzzleStickering.set(LL(), "Ignoriented" /* Ignoriented */);
    puzzleStickering.set(centerLL(), "Dim" /* Dim */);
  }
  switch (stickering) {
    case "full":
      break;
    case "PLL":
      dimF2L();
      setPLL();
      break;
    case "CLS":
      dimF2L();
      puzzleStickering.set(cornerDFR(), "Regular" /* Regular */);
      puzzleStickering.set(LL(), "Ignoriented" /* Ignoriented */);
      puzzleStickering.set(m.and([LL(), CENTERS()]), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "OLL":
      dimF2L();
      setOLL();
      break;
    case "COLL":
      dimF2L();
      puzzleStickering.set(m.and([LL(), EDGES()]), "Ignoriented" /* Ignoriented */);
      puzzleStickering.set(m.and([LL(), CENTERS()]), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "OCLL":
      dimF2L();
      dimOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "CLL":
      dimF2L();
      puzzleStickering.set(m.not(m.and([CORNERS(), LL()])), "Dim" /* Dim */);
      break;
    case "ELL":
      dimF2L();
      puzzleStickering.set(LL(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), EDGES()]), "Regular" /* Regular */);
      break;
    case "ELS":
      dimF2L();
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored" /* Ignored */);
      puzzleStickering.set(edgeFR(), "Regular" /* Regular */);
      puzzleStickering.set(cornerDFR(), "Ignored" /* Ignored */);
      break;
    case "LL":
      dimF2L();
      break;
    case "F2L":
      puzzleStickering.set(LL(), "Ignored" /* Ignored */);
      break;
    case "ZBLL":
      dimF2L();
      puzzleStickering.set(LL(), "PermuteNonPrimary" /* PermuteNonPrimary */);
      puzzleStickering.set(centerLL(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "ZBLS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored" /* Ignored */);
      break;
    case "VLS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      setOLL();
      break;
    case "WVLS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      puzzleStickering.set(m.and([LL(), EDGES()]), "Ignoriented" /* Ignoriented */);
      puzzleStickering.set(m.and([LL(), CENTERS()]), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "LS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      puzzleStickering.set(LL(), "Ignored" /* Ignored */);
      puzzleStickering.set(centerLL(), "Dim" /* Dim */);
      break;
    case "EO":
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      break;
    case "EOline":
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.and(m.moves(["D", "M"])), "Regular" /* Regular */);
      break;
    case "EOcross":
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.move("D"), "Regular" /* Regular */);
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      break;
    case "CMLL":
      puzzleStickering.set(F2L(), "Dim" /* Dim */);
      puzzleStickering.set(L6E(), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "L10P":
      puzzleStickering.set(m.not(L6E()), "Dim" /* Dim */);
      puzzleStickering.set(m.and([CORNERS(), LL()]), "Regular" /* Regular */);
      break;
    case "L6E":
      puzzleStickering.set(m.not(L6E()), "Dim" /* Dim */);
      break;
    case "L6EO":
      puzzleStickering.set(m.not(L6E()), "Dim" /* Dim */);
      puzzleStickering.set(L6E(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.and([CENTERS(), orUD()]), "OrientationStickers" /* OrientationStickers */);
      break;
    case "Daisy":
      puzzleStickering.set(m.all(), "Ignored" /* Ignored */);
      puzzleStickering.set(CENTERS(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("D"), CENTERS()]), "Regular" /* Regular */);
      puzzleStickering.set(m.and([m.move("U"), EDGES()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "Cross":
      puzzleStickering.set(m.all(), "Ignored" /* Ignored */);
      puzzleStickering.set(CENTERS(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("D"), CENTERS()]), "Regular" /* Regular */);
      puzzleStickering.set(m.and([m.move("D"), EDGES()]), "Regular" /* Regular */);
      break;
    case "2x2x2":
      puzzleStickering.set(m.or(m.moves(["U", "F", "R"])), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([m.or(m.moves(["U", "F", "R"])), CENTERS()]), "Dim" /* Dim */);
      break;
    case "2x2x3":
      puzzleStickering.set(m.all(), "Dim" /* Dim */);
      puzzleStickering.set(m.or(m.moves(["U", "F", "R"])), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([m.or(m.moves(["U", "F", "R"])), CENTERS()]), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("F"), m.not(m.or(m.moves(["U", "R"])))]), "Regular" /* Regular */);
      break;
    case "Void Cube":
      puzzleStickering.set(CENTERS(), "Invisible" /* Invisible */);
      break;
    case "picture":
    case "invisible":
      puzzleStickering.set(m.all(), "Invisible" /* Invisible */);
      break;
    case "centers-only":
      puzzleStickering.set(m.not(CENTERS()), "Ignored" /* Ignored */);
      break;
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
      puzzleStickering.set(m.and(m.moves([])), "Dim" /* Dim */);
  }
  return puzzleStickering.toAppearance();
}
async function cubeStickerings() {
  const stickerings = [];
  for (const [name, info] of Object.entries(experimentalStickerings)) {
    if (info.groups && "3x3x3" in info.groups) {
      stickerings.push(name);
    }
  }
  return stickerings;
}

// src/cubing/puzzles/async/lazy-cached.ts
function getCached(getValue) {
  let cachedPromise = null;
  return () => {
    return cachedPromise ?? (cachedPromise = getValue());
  };
}

// src/cubing/puzzles/async/async-pg3d.ts
async function asyncGetPuzzleGeometry(puzzleName) {
  const puzzleGeometry = await import("./puzzle-geometry/index.js");
  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {
    allMoves: true,
    orientCenters: true,
    addRotations: true
  });
}
async function asyncGetKPuzzle(pgPromise, puzzleName) {
  const pg = await pgPromise;
  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);
  kpuzzleDefinition.name = puzzleName;
  const puzzleGeometry = await import("./puzzle-geometry/index.js");
  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
  return new KPuzzle(kpuzzleDefinition, {
    experimentalPGNotation: pgNotation
  });
}
var _cachedPG, _cachedKPuzzle, _cachedSVG;
var PGPuzzleLoader = class {
  constructor(info) {
    __privateAdd(this, _cachedPG, void 0);
    __privateAdd(this, _cachedKPuzzle, void 0);
    __privateAdd(this, _cachedSVG, void 0);
    this.pgId = info.pgID;
    this.id = info.id;
    this.fullName = info.fullName;
    this.inventedBy = info.inventedBy;
    this.inventionYear = info.inventionYear;
  }
  pg() {
    return __privateGet(this, _cachedPG) ?? __privateSet(this, _cachedPG, asyncGetPuzzleGeometry(this.pgId ?? this.id));
  }
  kpuzzle() {
    return __privateGet(this, _cachedKPuzzle) ?? __privateSet(this, _cachedKPuzzle, asyncGetKPuzzle(this.pg(), this.id));
  }
  svg() {
    return __privateGet(this, _cachedSVG) ?? __privateSet(this, _cachedSVG, (async () => (await this.pg()).generatesvg())());
  }
};
_cachedPG = new WeakMap();
_cachedKPuzzle = new WeakMap();
_cachedSVG = new WeakMap();
var CubePGPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super(...arguments);
    this.stickerings = cubeStickerings;
  }
  appearance(stickering) {
    return cubeAppearance(this, stickering);
  }
};

// src/cubing/puzzles/implementations/2x2x2/index.ts
var cube2x2x2 = {
  id: "2x2x2",
  fullName: "2\xD72\xD72 Cube",
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-side-events-WZI4Y3N6.js")).cube2x2x2JSON)),
  svg: async () => {
    return (await import("./puzzles-dynamic-side-events-WZI4Y3N6.js")).cube2x2x2SVG;
  },
  pg: getCached(async () => {
    return asyncGetPuzzleGeometry("2x2x2");
  }),
  appearance: (stickering) => cubeAppearance(cube2x2x2, stickering),
  stickerings: cubeStickerings
};

// src/cubing/puzzles/implementations/3x3x3/index.ts
var cube3x3x3 = {
  id: "3x3x3",
  fullName: "3\xD73\xD73 Cube",
  inventedBy: ["Ern\u0151 Rubik"],
  inventionYear: 1974,
  kpuzzle: getCached(async () => {
    return experimental3x3x3KPuzzle;
  }),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-3x3x3-NB2PEZTV.js")).cube3x3x3SVG;
  }),
  llSVG: getCached(async () => {
    return (await import("./puzzles-dynamic-3x3x3-NB2PEZTV.js")).cube3x3x3LLSVG;
  }),
  pg: getCached(async () => {
    return asyncGetPuzzleGeometry("3x3x3");
  }),
  appearance: (stickering) => cubeAppearance(cube3x3x3, stickering),
  stickerings: cubeStickerings
};

// src/cubing/puzzles/implementations/clock/index.ts
var clock = {
  id: "clock",
  fullName: "Clock",
  inventedBy: ["Christopher C. Wiggs", "Christopher J. Taylor"],
  inventionYear: 1988,
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-side-events-WZI4Y3N6.js")).clockJSON)),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-side-events-WZI4Y3N6.js")).clockSVG;
  })
};

// src/cubing/puzzles/stickerings/fto-stickerings.ts
async function ftoStickering(puzzleLoader, stickering) {
  const kpuzzle = await puzzleLoader.kpuzzle();
  const puzzleStickering = new PuzzleStickering(kpuzzle);
  const m = new StickeringManager(kpuzzle);
  const experimentalFTO_FC = () => m.and([m.move("U"), m.not(m.or(m.moves(["F", "BL", "BR"])))]);
  const experimentalFTO_F2T = () => m.and([m.move("U"), m.not(m.move("F"))]);
  const experimentalFTO_SC = () => m.or([
    experimentalFTO_F2T(),
    m.and([m.move("F"), m.not(m.or(m.moves(["U", "BL", "BR"])))])
  ]);
  const experimentalFTO_L2C = () => m.not(m.or([
    m.and([m.move("U"), m.move("F")]),
    m.and([m.move("F"), m.move("BL")]),
    m.and([m.move("F"), m.move("BR")]),
    m.and([m.move("BL"), m.move("BR")])
  ]));
  const experimentalFTO_LBT = () => m.not(m.or([
    m.and([m.move("F"), m.move("BL")]),
    m.and([m.move("F"), m.move("BR")]),
    m.and([m.move("BL"), m.move("BR")])
  ]));
  switch (stickering) {
    case "full":
      break;
    case "experimental-fto-fc":
      puzzleStickering.set(m.not(experimentalFTO_FC()), "Ignored" /* Ignored */);
      break;
    case "experimental-fto-f2t":
      puzzleStickering.set(m.not(experimentalFTO_F2T()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_FC(), "Dim" /* Dim */);
      break;
    case "experimental-fto-sc":
      puzzleStickering.set(m.not(experimentalFTO_SC()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_F2T(), "Dim" /* Dim */);
      break;
    case "experimental-fto-l2c":
      puzzleStickering.set(m.not(experimentalFTO_L2C()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_SC(), "Dim" /* Dim */);
      break;
    case "experimental-fto-lbt":
      puzzleStickering.set(m.not(experimentalFTO_LBT()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_L2C(), "Dim" /* Dim */);
      break;
    case "experimental-fto-l3t":
      puzzleStickering.set(experimentalFTO_LBT(), "Dim" /* Dim */);
      break;
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
      puzzleStickering.set(m.and(m.moves([])), "Dim" /* Dim */);
  }
  return puzzleStickering.toAppearance();
}
async function ftoStickerings() {
  return [
    "full",
    "experimental-fto-fc",
    "experimental-fto-f2t",
    "experimental-fto-sc",
    "experimental-fto-l2c",
    "experimental-fto-lbt",
    "experimental-fto-l3t"
  ];
}

// src/cubing/puzzles/implementations/fto/index.ts
var FTOPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      pgID: "FTO",
      id: "fto",
      fullName: "Face-Turning Octahedron",
      inventedBy: ["Karl Rohrbach", "David Pitcher"],
      inventionYear: 1983
    });
    this.stickerings = ftoStickerings;
    this.svg = getCached(async () => {
      return (await import("./puzzles-dynamic-unofficial-FUG3JBMH.js")).ftoSVG;
    });
  }
  appearance(stickering) {
    return ftoStickering(this, stickering);
  }
};
var fto = new FTOPuzzleLoader();

// src/cubing/puzzles/stickerings/megaminx-stickerings.ts
async function megaminxAppearance(puzzleLoader, stickering) {
  switch (stickering) {
    case "full":
    case "F2L":
    case "LL":
    case "OLL":
    case "PLL":
    case "ELS":
    case "CLS":
      return cubeAppearance(puzzleLoader, stickering);
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
  }
  return cubeAppearance(puzzleLoader, "full");
}
async function megaminxStickerings() {
  return ["full", "F2L", "LL", "OLL", "PLL", "ELS", "CLS"];
}

// src/cubing/puzzles/implementations/megaminx/index.ts
var MegaminxPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      id: "megaminx",
      fullName: "Megaminx",
      inventionYear: 1981
    });
    this.stickerings = megaminxStickerings;
  }
  appearance(stickering) {
    return megaminxAppearance(this, stickering);
  }
};
var megaminx = new MegaminxPuzzleLoader();

// src/cubing/puzzles/implementations/pyraminx/index.ts
var PyraminxPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      id: "pyraminx",
      fullName: "Pyraminx",
      inventedBy: ["Uwe Meffert"]
    });
    this.svg = getCached(async () => {
      return (await import("./puzzles-dynamic-side-events-WZI4Y3N6.js")).pyraminxSVG;
    });
  }
};
var pyraminx = new PyraminxPuzzleLoader();

// src/cubing/puzzles/implementations/square1/index.ts
var square1 = {
  id: "square1",
  fullName: "Square-1",
  inventedBy: ["Karel Hr\u0161el", "Vojtech Kopsk\xFD"],
  inventionYear: 1990,
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-side-events-WZI4Y3N6.js")).sq1HyperOrbitJSON)),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-side-events-WZI4Y3N6.js")).sq1HyperOrbitSVG;
  })
};

// src/cubing/puzzles/implementations/kilominx/index.ts
var kilominx = {
  id: "kilominx",
  fullName: "Kilominx",
  kpuzzle: getCached(async () => {
    const pg = await asyncGetPuzzleGeometry("megaminx + chopasaurus");
    const kpuzzleDefinition = JSON.parse(JSON.stringify(pg.getKPuzzleDefinition(true)));
    delete kpuzzleDefinition.orbits.CENTERS;
    delete kpuzzleDefinition.orbits.CENTERS2;
    delete kpuzzleDefinition.startStateData.CENTERS;
    delete kpuzzleDefinition.startStateData.CENTERS2;
    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {
      delete moveDefinition.CENTERS;
      delete moveDefinition.CENTERS2;
    }
    kpuzzleDefinition.name = "kilominx";
    delete kpuzzleDefinition.experimentalPuzzleDescription;
    const puzzleGeometry = await import("./puzzle-geometry/index.js");
    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
    const kpuzzle = new KPuzzle(kpuzzleDefinition, {
      experimentalPGNotation: {
        lookupMove: (move) => {
          if (move.toString() === "x2" || move.toString() === "x2'") {
            return x2Transformation.transformationData;
          }
          return pgNotation.lookupMove(move);
        }
      }
    });
    const x2Transformation = kpuzzle.algToTransformation("Rv2 Fv Uv'");
    kpuzzleDefinition.moves["x2"] = x2Transformation;
    return kpuzzle;
  }),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-unofficial-FUG3JBMH.js")).kilominxSVG;
  })
};

// src/cubing/puzzles/implementations/redi-cube/index.ts
var rediCube = {
  id: "redi_cube",
  fullName: "Redi Cube",
  inventedBy: ["Oskar van Deventer"],
  inventionYear: 2009,
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-unofficial-FUG3JBMH.js")).rediCubeJSON)),
  svg: async () => {
    return (await import("./puzzles-dynamic-unofficial-FUG3JBMH.js")).rediCubeSVG;
  }
};

// src/cubing/puzzles/index.ts
var puzzles = {
  "3x3x3": cube3x3x3,
  "2x2x2": cube2x2x2,
  "4x4x4": new CubePGPuzzleLoader({ id: "4x4x4", fullName: "4\xD74\xD74 Cube" }),
  "5x5x5": new CubePGPuzzleLoader({ id: "5x5x5", fullName: "5\xD75\xD75 Cube" }),
  "6x6x6": new CubePGPuzzleLoader({ id: "6x6x6", fullName: "6\xD76\xD76 Cube" }),
  "7x7x7": new CubePGPuzzleLoader({ id: "7x7x7", fullName: "7\xD77\xD77 Cube" }),
  "40x40x40": new CubePGPuzzleLoader({
    id: "40x40x40",
    fullName: "40\xD740\xD740 Cube"
  }),
  clock,
  "megaminx": megaminx,
  pyraminx,
  "skewb": new PGPuzzleLoader({
    id: "skewb",
    fullName: "Skewb",
    inventedBy: ["Tony Durham"]
  }),
  square1,
  "fto": fto,
  "gigaminx": new PGPuzzleLoader({
    id: "gigaminx",
    fullName: "Gigaminx",
    inventedBy: ["Tyler Fox"],
    inventionYear: 2006
  }),
  "master_tetraminx": new PGPuzzleLoader({
    pgID: "master tetraminx",
    id: "master_tetraminx",
    fullName: "Master Tetraminx",
    inventedBy: ["Katsuhiko Okamoto"],
    inventionYear: 2002
  }),
  kilominx,
  "redi_cube": rediCube
};

export {
  wcaEventInfo,
  eventInfo,
  cube2x2x2,
  cube3x3x3,
  puzzles
};
//# sourceMappingURL=chunk-JAGHV77R.js.map
