{
  "version": 3,
  "sources": ["../../src/cubing/kpuzzle/combine.ts", "../../src/cubing/kpuzzle/construct.ts", "../../src/cubing/kpuzzle/KState.ts", "../../src/cubing/kpuzzle/KTransformation.ts", "../../src/cubing/kpuzzle/calculate.ts", "../../src/cubing/kpuzzle/KPuzzle.ts"],
  "sourcesContent": ["import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KStateData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = transformationData1[orbitName];\n    const orbit2 = transformationData2[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitName] = {\n          permutation: newPerm,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToStateData(\n  definition: KPuzzleDefinition,\n  stateData: KStateData,\n  transformationData: KTransformationData,\n): KStateData {\n  const newStateData = {} as KStateData;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const orbit1 = stateData[orbitName];\n    const orbit2 = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newStateData[orbitName] = orbit1;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: orbit1.orientation,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientation[orbit2.permutation[idx]] +\n              orbit2.orientation[idx]) %\n            orbitDefinition.numOrientations;\n          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];\n        }\n        newStateData[orbitName] = {\n          pieces: newPieces,\n          orientation: newOri,\n        };\n      }\n    }\n  }\n  return newStateData;\n}\n", "import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientation: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    definition.orbits,\n  )) {\n    transformation[orbitName] = constructIdentityOrbitTransformation(\n      orbitDefinition.numPieces,\n    );\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  const quantumKey = move.quantum.toString();\n  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey] as\n    | KTransformationData\n    | undefined;\n\n  if (!quantumMoveDefinition) {\n    const derivedFrom =\n      kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];\n\n    if (derivedFrom) {\n      // TODO: avoid the round trip?\n      quantumMoveDefinition =\n        kpuzzle.algToTransformation(derivedFrom).transformationData;\n    }\n  }\n\n  if (quantumMoveDefinition) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      quantumMoveDefinition,\n      move.amount,\n    );\n  }\n\n  // Handle e.g. `y2` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const moveDefinition = kpuzzle.definition.moves[move.toString()];\n  if (moveDefinition) {\n    return moveDefinition;\n  }\n\n  // Handle e.g. `y2'` if `y2` is defined.\n  // Note: this doesn't handle multiples.\n  const inverseMoveDefinition =\n    kpuzzle.definition.moves[move.invert().toString()];\n  if (inverseMoveDefinition) {\n    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);\n  }\n\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n", "import type { KPuzzle } from \"./KPuzzle\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToStateData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KStateData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport class KState {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly stateData: KStateData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      stateData: this.stateData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KState {\n    const newStateData = applyTransformationDataToStateData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.startStateData,\n      transformation.transformationData,\n    );\n    return new KState(transformation.kpuzzle, newStateData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KState {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KState {\n    if (transformation.isIdentityTransformation()) {\n      return new KState(this.kpuzzle, this.stateData);\n    }\n    const newStateData = applyTransformationDataToStateData(\n      this.kpuzzle.definition,\n      this.stateData,\n      transformation.transformationData,\n    );\n    return new KState(this.kpuzzle, newStateData);\n  }\n\n  applyMove(move: Move | string): KState {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KState {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: stateOrbitData.pieces,\n        orientation: stateOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsStateSolved) {\n      throw new Error(\n        \"`KState.experimentalIsSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsStateSolved(this, options);\n  }\n}\n", "import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKState(): KState {\n    return KState.fromTransformation(this);\n  }\n\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n", "import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n  KPuzzleDefinition,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignoreOrientation?: boolean;\n    ignorePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignoreOrientation &&\n      orbitTransformationData1.orientation[idx] !==\n        orbitTransformationData2.orientation[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(\n    kpuzzle.definition.orbits,\n  )) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitName],\n        transformationData2[orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitName in kpuzzle.definition.orbits) {\n    const orbitDefinition: KOrbitDefinition =\n      kpuzzle.definition.orbits[orbitName];\n    const orbitTransformationData = transformationData[orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitName] = orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: orbitTransformationData.orientation,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientation[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitName] = {\n        permutation: newPerm,\n        orientation: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nconst algToTransformationInstance = new AlgToTransformationTraversal();\nexport const algToTransformation = algToTransformationInstance.traverseAlg.bind(\n  algToTransformationInstance,\n) as (alg: Alg, kpuzzle: KPuzzle) => KTransformation;\n\nexport function canConvertStateToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const [orbitName, orbitDefinition] of Object.entries(definition)) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.startStateData[orbitName].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitName in definition.orbits) {\n    const orbitDefinition = definition.orbits[orbitName];\n    const transformationOrbit = transformation.transformationData[orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientation[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, orientationSum);\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n", "import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KState } from \"./KState\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  startState(): KState {\n    return new KState(this, this.definition.startStateData);\n  }\n\n  #cachedCanConvertStateToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete start state data\n  canConvertStateToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertStateToUniqueTransformation ??=\n      ((): boolean => {\n        for (const [orbitName, orbitDefinition] of Object.entries(\n          this.definition.orbits,\n        )) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.startStateData[orbitName]\n            .pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  get state(): never {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  reset(): never {\n    throw new Error(\"KPuzzle is now a different (stateless) class.\");\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  applyMove(_move: Move): never {\n    throw new Error(\n      \"KPuzzle is now a different class. Try `.moveToTransformation()` to get the transformation for a move.\",\n    );\n  }\n\n  // TODO: Remove completely with v0.25\n  /** @deprecated */\n  applyAlg(_alg: Alg): never {\n    throw new Error(\n      \"KPuzzle is now a different class. Try `.algToTransformation()` to get the transformation for an alg.\",\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
