{
  "version": 3,
  "sources": ["../../src/cubing/vendor/random-uint-below/get-random-values.ts", "../../src/cubing/vendor/random-uint-below/random53BitValue.ts", "../../src/cubing/vendor/random-uint-below/random-choice.ts", "../../src/cubing/vendor/random-uint-below/index.ts"],
  "sourcesContent": ["export type GetRandomValuesFunction = (arr: Uint32Array) => void;\n\n// This is a workaround for a `node` segfault.\n// In theory, imports are cached and safe to import multiple times: https://nodejs.org/api/esm.html#esm_urls\n// In practice, a rapid series of inline imports inside a worker causes a segfault(!) in `node`.\n// So we cache a single import reference. We avoid populating it until we first need it, so that we don't attempt to perform the import in environments that don't need or have it (e.g. browsers, `deno`).\nlet cryptoPromise: Promise<typeof import(\"crypto\")> | null = null;\n\n// `@types/node` is... lacking. This type may cause an error in the future, at which point we can hopefully use `@types/node` directly.\ntype NodeWebCrypto = typeof import(\"crypto\").webcrypto & {\n  getRandomValues: GetRandomValuesFunction;\n};\n\n// Mangled so that bundlers don't try to inline the source.\nconst cryptoMangled = \"cr-yp-to\";\nconst cryptoUnmangled = () => cryptoMangled.replace(/-/g, \"\");\n\n// We could use top-level await to define this more statically, but that has limited transpilation support.\nexport async function getRandomValuesFactory(): Promise<GetRandomValuesFunction> {\n  if (!globalThis?.crypto?.getRandomValues) {\n    const nodeWebCrypto = (\n      await (cryptoPromise ??= import(/* @vite-ignore */ cryptoUnmangled()))\n    ).webcrypto as NodeWebCrypto;\n    return nodeWebCrypto.getRandomValues.bind(\n      nodeWebCrypto,\n    ) as typeof nodeWebCrypto.getRandomValues;\n  } else {\n    return crypto.getRandomValues.bind(crypto) as GetRandomValuesFunction;\n  }\n}\n", "import {\n  getRandomValuesFactory,\n  GetRandomValuesFunction,\n} from \"./get-random-values\";\n\n/*\n * randomInt.below(max) returns a random non-negative integer less than max (0 <= output < max).\n * `max` must be at most 2^53.\n */\n\nconst MAX_JS_PRECISE_INT = 9007199254740992;\n\nconst UPPER_HALF_MULTIPLIER = 2097152; // 2^21. We have to use multiplication because bit shifts truncate to 32 bits.\nconst LOWER_HALF_DIVIDER = 2048;\n\nfunction random53BitValue(getRandomValues: GetRandomValuesFunction): number {\n  // Construct a random 53-bit value from a 32-bit upper half and a 21-bit lower half.\n  const arr = new Uint32Array(2);\n  getRandomValues(arr);\n  const upper = arr[0];\n  const lower = arr[1];\n  return (\n    Math.floor(upper * UPPER_HALF_MULTIPLIER) +\n    Math.floor(lower / LOWER_HALF_DIVIDER)\n  );\n}\n\nfunction validateMax(max: number): void {\n  if (typeof max !== \"number\" || max < 0 || Math.floor(max) !== max) {\n    throw new Error(\n      \"randomInt.below() not called with a positive integer value.\",\n    );\n  }\n  if (max > MAX_JS_PRECISE_INT) {\n    throw new Error(\n      `Called randomInt.below() with max == ${max}, which is larger than JavaScript can handle with integer precision.`,\n    );\n  }\n}\n\n// TODO: cache generated `randomUIntBelow`?\nexport async function randomUIntBelowFactory(): Promise<\n  (max: number) => number\n> {\n  const getRandomValues = await getRandomValuesFactory();\n  const randomUIntBelow = (max: number): number => {\n    validateMax(max);\n\n    const val = random53BitValue(getRandomValues);\n    const maxUniformSamplingRange = Math.floor(MAX_JS_PRECISE_INT / max) * max;\n\n    // Rejection sampling:\n    if (val < maxUniformSamplingRange) {\n      return val % max;\n    } else {\n      // val % max would produce a biased result. This bias an be very bad if `max` is on the order of MAX_JS_PRECISE_INT. We have to try again, so just call ourselves recursively.\n      // For some values of `max` just above 9007199254740992 / 2, this happens about once on average. For other values of `max`, it's less than that (and for small values of `max` it's extremely unlikely).\n\n      // TODO: Use more bits of accuracy instead of rejection sampling to avoid DoS.\n      return randomUIntBelow(max);\n    }\n  };\n  return randomUIntBelow;\n}\n", "import { randomUIntBelowFactory } from \"./random53BitValue\";\n\n// Inspired by https://reference.wolfram.com/language/ref/RandomChoice.html\n// This library itself should be kept small, but a wrapper library may want to implement selecting multiple element without replacement as with replacement:\n// https://reference.wolfram.com/language/ref/RandomSample.html\nexport async function randomChoiceFactory<T>(): Promise<(arr: Array<T>) => T> {\n  const randomUIntBelow = await randomUIntBelowFactory();\n  return (arr: Array<T>): T => arr[randomUIntBelow(arr.length)];\n}\n", "export { randomChoiceFactory } from \"./random-choice\";\nexport { randomUIntBelowFactory } from \"./random53BitValue\";\n\n// TODO: reuse factory properly, move this to a separate file, add to impl.\nimport { randomUIntBelowFactory } from \"./random53BitValue\";\nconst randomUIntBelowPromise = randomUIntBelowFactory();\nexport async function randomPermute<T>(list: T[]): Promise<void> {\n  for (let i = 1; i < list.length; i++) {\n    const j = (await randomUIntBelowPromise)(i);\n    [list[i], list[j]] = [list[j], list[i]];\n  }\n}\n"],
  "mappings": ";AAMA,IAAI,gBAAyD;AAQ7D,IAAM,gBAAgB;AACtB,IAAM,kBAAkB,MAAM,cAAc,QAAQ,MAAM,EAAE;AAG5D,wCAAiF;AAC/E,MAAI,CAAC,YAAY,QAAQ,iBAAiB;AACxC,UAAM,gBACJ,OAAO,mCAAkB;AAAA;AAAA,MAA0B,gBAAgB;AAAA,SACnE;AACF,WAAO,cAAc,gBAAgB,KACnC,aACF;AAAA,EACF,OAAO;AACL,WAAO,OAAO,gBAAgB,KAAK,MAAM;AAAA,EAC3C;AACF;;;ACnBA,IAAM,qBAAqB;AAE3B,IAAM,wBAAwB;AAC9B,IAAM,qBAAqB;AAE3B,0BAA0B,iBAAkD;AAE1E,QAAM,MAAM,IAAI,YAAY,CAAC;AAC7B,kBAAgB,GAAG;AACnB,QAAM,QAAQ,IAAI;AAClB,QAAM,QAAQ,IAAI;AAClB,SACE,KAAK,MAAM,QAAQ,qBAAqB,IACxC,KAAK,MAAM,QAAQ,kBAAkB;AAEzC;AAEA,qBAAqB,KAAmB;AACtC,MAAI,OAAO,QAAQ,YAAY,MAAM,KAAK,KAAK,MAAM,GAAG,MAAM,KAAK;AACjE,UAAM,IAAI,MACR,6DACF;AAAA,EACF;AACA,MAAI,MAAM,oBAAoB;AAC5B,UAAM,IAAI,MACR,wCAAwC,yEAC1C;AAAA,EACF;AACF;AAGA,wCAEE;AACA,QAAM,kBAAkB,MAAM,uBAAuB;AACrD,QAAM,kBAAkB,CAAC,QAAwB;AAC/C,gBAAY,GAAG;AAEf,UAAM,MAAM,iBAAiB,eAAe;AAC5C,UAAM,0BAA0B,KAAK,MAAM,qBAAqB,GAAG,IAAI;AAGvE,QAAI,MAAM,yBAAyB;AACjC,aAAO,MAAM;AAAA,IACf,OAAO;AAKL,aAAO,gBAAgB,GAAG;AAAA,IAC5B;AAAA,EACF;AACA,SAAO;AACT;;;AC1DA,qCAA8E;AAC5E,QAAM,kBAAkB,MAAM,uBAAuB;AACrD,SAAO,CAAC,QAAqB,IAAI,gBAAgB,IAAI,MAAM;AAC7D;;;ACHA,IAAM,yBAAyB,uBAAuB;AACtD,6BAAuC,MAA0B;AAC/D,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,IAAK,OAAM,wBAAwB,CAAC;AAC1C,KAAC,KAAK,IAAI,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,KAAK,EAAE;AAAA,EACxC;AACF;",
  "names": []
}
