import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper
} from "./chunk-MGJA5U5O.js";

// src/cubing/alg/common.ts
var writeAlgDebugField = false;
var Comparable = class {
  is(c) {
    return this instanceof c;
  }
  as(c) {
    return this instanceof c ? this : null;
  }
};
var AlgCommon = class extends Comparable {
  constructor() {
    super();
    if (writeAlgDebugField) {
      Object.defineProperty(this, "_debugStr", {
        get: () => {
          return this.toString();
        }
      });
    }
  }
  get log() {
    return console.log.bind(console, this, this.toString());
  }
};

// src/cubing/alg/iteration.ts
function toggleDirection(iterationDirection, flip = true) {
  if (!flip) {
    return iterationDirection;
  }
  switch (iterationDirection) {
    case 1 /* Forwards */:
      return -1 /* Backwards */;
    case -1 /* Backwards */:
      return 1 /* Forwards */;
  }
}
function direct(g, iterDir) {
  return iterDir === -1 /* Backwards */ ? Array.from(g).reverse() : g;
}
function reverse(g) {
  return Array.from(g).reverse();
}
function* directedGenerator(g, direction) {
  direction === -1 /* Backwards */ ? yield* reverseGenerator(g) : yield* g;
}
function* reverseGenerator(g) {
  for (const t of Array.from(g).reverse()) {
    yield t;
  }
}

// src/cubing/alg/limits.ts
var MAX_INT = 2147483647;
var MAX_INT_DESCRIPTION = "2^31 - 1";
var MIN_INT = -2147483648;

// src/cubing/alg/AlgBuilder.ts
var _algNode;
var AlgBuilder = class {
  constructor() {
    __privateAdd(this, _algNode, []);
  }
  push(u) {
    __privateGet(this, _algNode).push(u);
  }
  experimentalPushAlg(alg) {
    for (const u of alg.childAlgNodes()) {
      this.push(u);
    }
  }
  experimentalNumAlgNodes() {
    return __privateGet(this, _algNode).length;
  }
  toAlg() {
    return new Alg(__privateGet(this, _algNode));
  }
  reset() {
    __privateSet(this, _algNode, []);
  }
};
_algNode = new WeakMap();

// src/cubing/alg/debug.ts
var algDebugGlobals = {
  caratNISSNotationEnabled: false
};
function setAlgDebug(options) {
  if ("caratNISSNotationEnabled" in options) {
    algDebugGlobals.caratNISSNotationEnabled = !!options.caratNISSNotationEnabled;
  }
}

// src/cubing/alg/alg-nodes/containers/Commutator.ts
var _A, _B;
var _Commutator = class extends AlgCommon {
  constructor(aSource, bSource) {
    super();
    __privateAdd(this, _A, void 0);
    __privateAdd(this, _B, void 0);
    __privateSet(this, _A, experimentalEnsureAlg(aSource));
    __privateSet(this, _B, experimentalEnsureAlg(bSource));
  }
  get A() {
    return __privateGet(this, _A);
  }
  get B() {
    return __privateGet(this, _B);
  }
  isIdentical(other) {
    const otherAsCommutator = other.as(_Commutator);
    return !!(otherAsCommutator?.A.isIdentical(this.A) && otherAsCommutator?.B.isIdentical(this.B));
  }
  invert() {
    return new _Commutator(__privateGet(this, _B), __privateGet(this, _A));
  }
  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {
    depth ?? (depth = Infinity);
    if (depth === 0) {
      yield iterDir === 1 /* Forwards */ ? this : this.invert();
    } else {
      if (iterDir === 1 /* Forwards */) {
        yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);
        yield* this.B.experimentalExpand(1 /* Forwards */, depth - 1);
        yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);
        yield* this.B.experimentalExpand(-1 /* Backwards */, depth - 1);
      } else {
        yield* this.B.experimentalExpand(1 /* Forwards */, depth - 1);
        yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);
        yield* this.B.experimentalExpand(-1 /* Backwards */, depth - 1);
        yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);
      }
    }
  }
  toString() {
    return `[${__privateGet(this, _A).toString()}, ${__privateGet(this, _B).toString()}]`;
  }
};
var Commutator = _Commutator;
_A = new WeakMap();
_B = new WeakMap();

// src/cubing/alg/alg-nodes/containers/Conjugate.ts
var _A2, _B2;
var _Conjugate = class extends AlgCommon {
  constructor(aSource, bSource) {
    super();
    __privateAdd(this, _A2, void 0);
    __privateAdd(this, _B2, void 0);
    __privateSet(this, _A2, experimentalEnsureAlg(aSource));
    __privateSet(this, _B2, experimentalEnsureAlg(bSource));
  }
  get A() {
    return __privateGet(this, _A2);
  }
  get B() {
    return __privateGet(this, _B2);
  }
  isIdentical(other) {
    const otherAsConjugate = other.as(_Conjugate);
    return !!(otherAsConjugate?.A.isIdentical(this.A) && otherAsConjugate?.B.isIdentical(this.B));
  }
  invert() {
    return new _Conjugate(__privateGet(this, _A2), __privateGet(this, _B2).invert());
  }
  *experimentalExpand(iterDir, depth) {
    depth ?? (depth = Infinity);
    if (depth === 0) {
      yield iterDir === 1 /* Forwards */ ? this : this.invert();
    } else {
      yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);
      yield* this.B.experimentalExpand(iterDir, depth - 1);
      yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);
    }
  }
  toString() {
    return `[${this.A}: ${this.B}]`;
  }
};
var Conjugate = _Conjugate;
_A2 = new WeakMap();
_B2 = new WeakMap();

// src/cubing/alg/alg-nodes/leaves/LineComment.ts
var _text;
var _LineComment = class extends AlgCommon {
  constructor(commentText) {
    super();
    __privateAdd(this, _text, void 0);
    if (commentText.includes("\n") || commentText.includes("\r")) {
      throw new Error("LineComment cannot contain newline");
    }
    __privateSet(this, _text, commentText);
  }
  get text() {
    return __privateGet(this, _text);
  }
  isIdentical(other) {
    const otherAsLineComment = other;
    return other.is(_LineComment) && __privateGet(this, _text) === __privateGet(otherAsLineComment, _text);
  }
  invert() {
    return this;
  }
  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {
    yield this;
  }
  toString() {
    return `//${__privateGet(this, _text)}`;
  }
};
var LineComment = _LineComment;
_text = new WeakMap();

// src/cubing/alg/alg-nodes/leaves/Newline.ts
var Newline = class extends AlgCommon {
  toString() {
    return `
`;
  }
  isIdentical(other) {
    return other.is(Newline);
  }
  invert() {
    return this;
  }
  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {
    yield this;
  }
};

// src/cubing/alg/alg-nodes/leaves/Pause.ts
var Pause = class extends AlgCommon {
  toString() {
    return `.`;
  }
  isIdentical(other) {
    return other.is(Pause);
  }
  invert() {
    return this;
  }
  *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {
    yield this;
  }
};

// src/cubing/alg/parse.ts
function parseIntWithEmptyFallback(n, emptyFallback) {
  return n ? parseInt(n) : emptyFallback;
}
var AMOUNT_REGEX = /^(\d+)?('?)/;
var MOVE_START_REGEX = /^[_\dA-Za-z]/;
var QUANTUM_MOVE_REGEX = /^((([1-9]\d*)-)?([1-9]\d*))?([_A-Za-z]+)?/;
var COMMENT_TEXT_REGEX = /^[^\n]*/;
var SQUARE1_PAIR_START_REGEX = /^(-?\d+), ?/;
var SQUARE1_PAIR_END_REGEX = /^(-?\d+)\)/;
function parseAlg(s) {
  return new AlgParser().parseAlg(s);
}
function parseMove(s) {
  return new AlgParser().parseMove(s);
}
function parseQuantumMove(s) {
  return new AlgParser().parseQuantumMove(s);
}
function addCharIndices(t, startCharIndex, endCharIndex) {
  const parsedT = t;
  parsedT.startCharIndex = startCharIndex;
  parsedT.endCharIndex = endCharIndex;
  return parsedT;
}
function transferCharIndex(from, to) {
  if ("startCharIndex" in from) {
    to.startCharIndex = from.startCharIndex;
  }
  if ("endCharIndex" in from) {
    to.endCharIndex = from.endCharIndex;
  }
  return to;
}
var _input, _idx, _nissQueue;
var AlgParser = class {
  constructor() {
    __privateAdd(this, _input, "");
    __privateAdd(this, _idx, 0);
    __privateAdd(this, _nissQueue, []);
  }
  parseAlg(input) {
    __privateSet(this, _input, input);
    __privateSet(this, _idx, 0);
    const alg = this.parseAlgWithStopping([]);
    this.mustBeAtEndOfInput();
    const algNodes = Array.from(alg.childAlgNodes());
    if (__privateGet(this, _nissQueue).length > 0) {
      for (const nissGrouping of __privateGet(this, _nissQueue).reverse()) {
        algNodes.push(nissGrouping);
      }
    }
    return new Alg(algNodes);
  }
  parseMove(input) {
    __privateSet(this, _input, input);
    __privateSet(this, _idx, 0);
    const move = this.parseMoveImpl();
    this.mustBeAtEndOfInput();
    return move;
  }
  parseQuantumMove(input) {
    __privateSet(this, _input, input);
    __privateSet(this, _idx, 0);
    const quantumMove = this.parseQuantumMoveImpl();
    this.mustBeAtEndOfInput();
    return quantumMove;
  }
  mustBeAtEndOfInput() {
    if (__privateGet(this, _idx) !== __privateGet(this, _input).length) {
      throw new Error("parsing unexpectedly ended early");
    }
  }
  parseAlgWithStopping(stopBefore) {
    let algStartIdx = __privateGet(this, _idx);
    let algEndIdx = __privateGet(this, _idx);
    const algBuilder = new AlgBuilder();
    let crowded = false;
    const mustNotBeCrowded = (idx) => {
      if (crowded) {
        throw new Error(`Unexpected character at index ${idx}. Are you missing a space?`);
      }
    };
    mainLoop:
      while (__privateGet(this, _idx) < __privateGet(this, _input).length) {
        const savedCharIndex = __privateGet(this, _idx);
        if (stopBefore.includes(__privateGet(this, _input)[__privateGet(this, _idx)])) {
          return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);
        }
        if (this.tryConsumeNext(" ")) {
          crowded = false;
          if (algBuilder.experimentalNumAlgNodes() === 0) {
            algStartIdx = __privateGet(this, _idx);
          }
          continue mainLoop;
        } else if (MOVE_START_REGEX.test(__privateGet(this, _input)[__privateGet(this, _idx)])) {
          mustNotBeCrowded(savedCharIndex);
          const move = this.parseMoveImpl();
          algBuilder.push(move);
          crowded = true;
          algEndIdx = __privateGet(this, _idx);
          continue mainLoop;
        } else if (this.tryConsumeNext("(")) {
          mustNotBeCrowded(savedCharIndex);
          const sq1PairStartMatch = this.tryRegex(SQUARE1_PAIR_START_REGEX);
          if (sq1PairStartMatch) {
            const topAmountString = sq1PairStartMatch[1];
            const savedCharIndexD = __privateGet(this, _idx);
            const sq1PairEndMatch = this.parseRegex(SQUARE1_PAIR_END_REGEX);
            const uMove = addCharIndices(new Move(new QuantumMove("U_SQ_"), parseInt(topAmountString)), savedCharIndex + 1, savedCharIndex + 1 + topAmountString.length);
            const dMove = addCharIndices(new Move(new QuantumMove("D_SQ_"), parseInt(sq1PairEndMatch[1])), savedCharIndexD, __privateGet(this, _idx) - 1);
            const alg = addCharIndices(new Alg([uMove, dMove]), savedCharIndex + 1, __privateGet(this, _idx) - 1);
            algBuilder.push(addCharIndices(new Grouping(alg), savedCharIndex, __privateGet(this, _idx)));
            crowded = true;
            algEndIdx = __privateGet(this, _idx);
            continue mainLoop;
          } else {
            const alg = this.parseAlgWithStopping([")"]);
            this.mustConsumeNext(")");
            const amount = this.parseAmount();
            algBuilder.push(addCharIndices(new Grouping(alg, amount), savedCharIndex, __privateGet(this, _idx)));
            crowded = true;
            algEndIdx = __privateGet(this, _idx);
            continue mainLoop;
          }
        } else if (this.tryConsumeNext("^")) {
          if (!algDebugGlobals.caratNISSNotationEnabled) {
            throw new Error("Alg contained a carat but carat NISS notation is not enabled.");
          }
          this.mustConsumeNext("(");
          const alg = this.parseAlgWithStopping([")"]);
          this.popNext();
          const grouping = new Grouping(alg, -1);
          const placeholder = new Pause();
          grouping.experimentalNISSPlaceholder = placeholder;
          placeholder.experimentalNISSGrouping = grouping;
          __privateGet(this, _nissQueue).push(grouping);
          algBuilder.push(placeholder);
        } else if (this.tryConsumeNext("[")) {
          mustNotBeCrowded(savedCharIndex);
          const A = this.parseAlgWithStopping([",", ":"]);
          const separator = this.popNext();
          const B = this.parseAlgWithStopping(["]"]);
          this.mustConsumeNext("]");
          switch (separator) {
            case ":":
              algBuilder.push(addCharIndices(new Conjugate(A, B), savedCharIndex, __privateGet(this, _idx)));
              crowded = true;
              algEndIdx = __privateGet(this, _idx);
              continue mainLoop;
            case ",":
              algBuilder.push(addCharIndices(new Commutator(A, B), savedCharIndex, __privateGet(this, _idx)));
              crowded = true;
              algEndIdx = __privateGet(this, _idx);
              continue mainLoop;
            default:
              throw new Error("unexpected parsing error");
          }
        } else if (this.tryConsumeNext("\n")) {
          algBuilder.push(addCharIndices(new Newline(), savedCharIndex, __privateGet(this, _idx)));
          crowded = false;
          algEndIdx = __privateGet(this, _idx);
          continue mainLoop;
        } else if (this.tryConsumeNext("/")) {
          if (this.tryConsumeNext("/")) {
            mustNotBeCrowded(savedCharIndex);
            const [text] = this.parseRegex(COMMENT_TEXT_REGEX);
            algBuilder.push(addCharIndices(new LineComment(text), savedCharIndex, __privateGet(this, _idx)));
            crowded = false;
            algEndIdx = __privateGet(this, _idx);
            continue mainLoop;
          } else {
            algBuilder.push(addCharIndices(new Move("_SLASH_"), savedCharIndex, __privateGet(this, _idx)));
            crowded = true;
            algEndIdx = __privateGet(this, _idx);
            continue mainLoop;
          }
        } else if (this.tryConsumeNext(".")) {
          mustNotBeCrowded(savedCharIndex);
          algBuilder.push(addCharIndices(new Pause(), savedCharIndex, __privateGet(this, _idx)));
          crowded = true;
          algEndIdx = __privateGet(this, _idx);
          continue mainLoop;
        } else {
          throw new Error(`Unexpected character: ${this.popNext()}`);
        }
      }
    if (__privateGet(this, _idx) !== __privateGet(this, _input).length) {
      throw new Error("did not finish parsing?");
    }
    if (stopBefore.length > 0) {
      throw new Error("expected stopping");
    }
    return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);
  }
  parseQuantumMoveImpl() {
    const [, , , outerLayerStr, innerLayerStr, family] = this.parseRegex(QUANTUM_MOVE_REGEX);
    return new QuantumMove(family, parseIntWithEmptyFallback(innerLayerStr, void 0), parseIntWithEmptyFallback(outerLayerStr, void 0));
  }
  parseMoveImpl() {
    const savedCharIndex = __privateGet(this, _idx);
    if (this.tryConsumeNext("/")) {
      return addCharIndices(new Move("_SLASH_"), savedCharIndex, __privateGet(this, _idx));
    }
    let quantumMove = this.parseQuantumMoveImpl();
    let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();
    const suffix = this.parseMoveSuffix();
    if (suffix) {
      if (amount < 0) {
        throw new Error("uh-oh");
      }
      if ((suffix === "++" || suffix === "--") && amount !== 1) {
        throw new Error("Pochmann ++ or -- moves cannot have an amount other than 1.");
      }
      if ((suffix === "++" || suffix === "--") && !hadEmptyAbsAmount) {
        throw new Error("Pochmann ++ or -- moves cannot have an amount written as a number.");
      }
      if ((suffix === "+" || suffix === "-") && hadEmptyAbsAmount) {
        throw new Error("Clock dial moves must have an amount written as a natural number followed by + or -.");
      }
      if (suffix.startsWith("+")) {
        quantumMove = quantumMove.modified({
          family: `${quantumMove.family}_${suffix === "+" ? "PLUS" : "PLUSPLUS"}_`
        });
      }
      if (suffix.startsWith("-")) {
        quantumMove = quantumMove.modified({
          family: `${quantumMove.family}_${suffix === "-" ? "PLUS" : "PLUSPLUS"}_`
        });
        amount *= -1;
      }
    }
    const move = addCharIndices(new Move(quantumMove, amount), savedCharIndex, __privateGet(this, _idx));
    return move;
  }
  parseMoveSuffix() {
    if (this.tryConsumeNext("+")) {
      if (this.tryConsumeNext("+")) {
        return "++";
      }
      return "+";
    }
    if (this.tryConsumeNext("-")) {
      if (this.tryConsumeNext("-")) {
        return "--";
      }
      return "-";
    }
    return null;
  }
  parseAmountAndTrackEmptyAbsAmount() {
    const savedIdx = __privateGet(this, _idx);
    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);
    if (absAmountStr?.startsWith("0") && absAmountStr !== "0") {
      throw new Error(`Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`);
    }
    return [
      parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === "'" ? -1 : 1),
      !absAmountStr
    ];
  }
  parseAmount() {
    const savedIdx = __privateGet(this, _idx);
    const [, absAmountStr, primeStr] = this.parseRegex(AMOUNT_REGEX);
    if (absAmountStr?.startsWith("0") && absAmountStr !== "0") {
      throw new Error(`Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`);
    }
    return parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === "'" ? -1 : 1);
  }
  parseRegex(regex) {
    const arr = regex.exec(this.remaining());
    if (arr === null) {
      throw new Error("internal parsing error");
    }
    __privateSet(this, _idx, __privateGet(this, _idx) + arr[0].length);
    return arr;
  }
  tryRegex(regex) {
    const arr = regex.exec(this.remaining());
    if (arr === null) {
      return null;
    }
    __privateSet(this, _idx, __privateGet(this, _idx) + arr[0].length);
    return arr;
  }
  remaining() {
    return __privateGet(this, _input).slice(__privateGet(this, _idx));
  }
  popNext() {
    const next = __privateGet(this, _input)[__privateGet(this, _idx)];
    __privateWrapper(this, _idx)._++;
    return next;
  }
  tryConsumeNext(expected) {
    if (__privateGet(this, _input)[__privateGet(this, _idx)] === expected) {
      __privateWrapper(this, _idx)._++;
      return true;
    }
    return false;
  }
  mustConsumeNext(expected) {
    const next = this.popNext();
    if (next !== expected) {
      throw new Error(`expected \`${expected}\` while parsing, encountered ${next}`);
    }
    return next;
  }
};
_input = new WeakMap();
_idx = new WeakMap();
_nissQueue = new WeakMap();

// src/cubing/alg/warnOnce.ts
var warned = /* @__PURE__ */ new Set();
function warnOnce(s) {
  if (!warned.has(s)) {
    console.warn(s);
    warned.add(s);
  }
}

// src/cubing/alg/alg-nodes/QuantumWithAmount.ts
var QuantumWithAmount = class {
  constructor(quantum, amount = 1) {
    this.quantum = quantum;
    this.amount = amount;
    if (!Number.isInteger(this.amount) || this.amount < MIN_INT || this.amount > MAX_INT) {
      throw new Error(`AlgNode amount absolute value must be a non-negative integer below ${MAX_INT_DESCRIPTION}.`);
    }
  }
  suffix() {
    let s = "";
    const absAmount = Math.abs(this.amount);
    if (absAmount !== 1) {
      s += absAmount;
    }
    if (this.amount < 0) {
      s += "'";
    }
    return s;
  }
  isIdentical(other) {
    return this.quantum.isIdentical(other.quantum) && this.amount === other.amount;
  }
  *experimentalExpand(iterDir, depth) {
    const absAmount = Math.abs(this.amount);
    const newIterDir = toggleDirection(iterDir, this.amount < 0);
    for (let i = 0; i < absAmount; i++) {
      yield* this.quantum.experimentalExpand(newIterDir, depth);
    }
  }
};

// src/cubing/alg/alg-nodes/leaves/Move.ts
var _family, _innerLayer, _outerLayer;
var _QuantumMove = class extends Comparable {
  constructor(family, innerLayer, outerLayer) {
    super();
    __privateAdd(this, _family, void 0);
    __privateAdd(this, _innerLayer, void 0);
    __privateAdd(this, _outerLayer, void 0);
    __privateSet(this, _family, family);
    __privateSet(this, _innerLayer, innerLayer ?? null);
    __privateSet(this, _outerLayer, outerLayer ?? null);
    Object.freeze(this);
    if (__privateGet(this, _innerLayer) !== null && (!Number.isInteger(__privateGet(this, _innerLayer)) || __privateGet(this, _innerLayer) < 1 || __privateGet(this, _innerLayer) > MAX_INT)) {
      throw new Error(`QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`);
    }
    if (__privateGet(this, _outerLayer) !== null && (!Number.isInteger(__privateGet(this, _outerLayer)) || __privateGet(this, _outerLayer) < 1 || __privateGet(this, _outerLayer) > MAX_INT)) {
      throw new Error(`QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`);
    }
    if (__privateGet(this, _outerLayer) !== null && __privateGet(this, _innerLayer) !== null && __privateGet(this, _innerLayer) <= __privateGet(this, _outerLayer)) {
      throw new Error("QuantumMove outer layer must be smaller than inner layer.");
    }
    if (__privateGet(this, _outerLayer) !== null && __privateGet(this, _innerLayer) === null) {
      throw new Error("QuantumMove with an outer layer must have an inner layer");
    }
  }
  static fromString(s) {
    return parseQuantumMove(s);
  }
  modified(modifications) {
    return new _QuantumMove(modifications.family ?? __privateGet(this, _family), modifications.innerLayer ?? __privateGet(this, _innerLayer), modifications.outerLayer ?? __privateGet(this, _outerLayer));
  }
  isIdentical(other) {
    const otherAsQuantumMove = other;
    return other.is(_QuantumMove) && __privateGet(this, _family) === __privateGet(otherAsQuantumMove, _family) && __privateGet(this, _innerLayer) === __privateGet(otherAsQuantumMove, _innerLayer) && __privateGet(this, _outerLayer) === __privateGet(otherAsQuantumMove, _outerLayer);
  }
  get family() {
    return __privateGet(this, _family);
  }
  get outerLayer() {
    return __privateGet(this, _outerLayer);
  }
  get innerLayer() {
    return __privateGet(this, _innerLayer);
  }
  experimentalExpand() {
    throw new Error("experimentalExpand() cannot be called on a `QuantumMove` directly.");
  }
  toString() {
    let s = __privateGet(this, _family);
    if (__privateGet(this, _innerLayer) !== null) {
      s = String(__privateGet(this, _innerLayer)) + s;
      if (__privateGet(this, _outerLayer) !== null) {
        s = String(__privateGet(this, _outerLayer)) + "-" + s;
      }
    }
    return s;
  }
};
var QuantumMove = _QuantumMove;
_family = new WeakMap();
_innerLayer = new WeakMap();
_outerLayer = new WeakMap();
var _quantumWithAmount;
var _Move = class extends AlgCommon {
  constructor(...args) {
    super();
    __privateAdd(this, _quantumWithAmount, void 0);
    if (typeof args[0] === "string") {
      if (args[1] ?? null) {
        __privateSet(this, _quantumWithAmount, new QuantumWithAmount(QuantumMove.fromString(args[0]), args[1]));
        return;
      } else {
        return _Move.fromString(args[0]);
      }
    }
    __privateSet(this, _quantumWithAmount, new QuantumWithAmount(args[0], args[1]));
  }
  isIdentical(other) {
    const otherAsMove = other.as(_Move);
    return !!otherAsMove && __privateGet(this, _quantumWithAmount).isIdentical(__privateGet(otherAsMove, _quantumWithAmount));
  }
  invert() {
    return transferCharIndex(this, new _Move(__privateGet(this, _quantumWithAmount).quantum, -this.amount));
  }
  *experimentalExpand(iterDir = 1 /* Forwards */) {
    if (iterDir === 1 /* Forwards */) {
      yield this;
    } else {
      yield this.modified({
        amount: -this.amount
      });
    }
  }
  get quantum() {
    return __privateGet(this, _quantumWithAmount).quantum;
  }
  modified(modifications) {
    return new _Move(__privateGet(this, _quantumWithAmount).quantum.modified(modifications), modifications.amount ?? this.amount);
  }
  static fromString(s) {
    return parseMove(s);
  }
  get amount() {
    return __privateGet(this, _quantumWithAmount).amount;
  }
  get type() {
    warnOnce("deprecated: type");
    return "blockMove";
  }
  get family() {
    return __privateGet(this, _quantumWithAmount).quantum.family ?? void 0;
  }
  get outerLayer() {
    return __privateGet(this, _quantumWithAmount).quantum.outerLayer ?? void 0;
  }
  get innerLayer() {
    return __privateGet(this, _quantumWithAmount).quantum.innerLayer ?? void 0;
  }
  toString() {
    if (this.family === "_SLASH_") {
      return "/";
    }
    if (this.family.endsWith("_PLUS_")) {
      return __privateGet(this, _quantumWithAmount).quantum.toString().slice(0, -6) + Math.abs(this.amount) + (this.amount < 0 ? "-" : "+");
    }
    if (this.family.endsWith("_PLUSPLUS_")) {
      const absAmount = Math.abs(this.amount);
      return __privateGet(this, _quantumWithAmount).quantum.toString().slice(0, -10) + (absAmount === 1 ? "" : absAmount) + (this.amount < 0 ? "--" : "++");
    }
    return __privateGet(this, _quantumWithAmount).quantum.toString() + __privateGet(this, _quantumWithAmount).suffix();
  }
};
var Move = _Move;
_quantumWithAmount = new WeakMap();

// src/cubing/alg/alg-nodes/containers/Grouping.ts
var Square1TupleFormatter = class {
  constructor() {
    this.quantumU_SQ_ = null;
    this.quantumD_SQ_ = null;
  }
  format(grouping) {
    const amounts = this.tuple(grouping);
    if (!amounts) {
      return null;
    }
    return `(${amounts.map((move) => move.amount).join(", ")})`;
  }
  tuple(grouping) {
    this.quantumU_SQ_ || (this.quantumU_SQ_ = new QuantumMove("U_SQ_"));
    this.quantumD_SQ_ || (this.quantumD_SQ_ = new QuantumMove("D_SQ_"));
    const quantumAlg = grouping.alg;
    if (quantumAlg.experimentalNumChildAlgNodes() === 2) {
      const [U, D] = quantumAlg.childAlgNodes();
      if (U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) && D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)) {
        if (grouping.amount !== 1) {
          throw new Error("Square-1 tuples cannot have an amount other than 1.");
        }
        return [U, D];
      }
    }
    return null;
  }
};
var square1TupleFormatterInstance = new Square1TupleFormatter();
var _quantumWithAmount2;
var _Grouping = class extends AlgCommon {
  constructor(algSource, amount) {
    super();
    __privateAdd(this, _quantumWithAmount2, void 0);
    const alg = experimentalEnsureAlg(algSource);
    __privateSet(this, _quantumWithAmount2, new QuantumWithAmount(alg, amount));
  }
  isIdentical(other) {
    const otherAsGrouping = other;
    return other.is(_Grouping) && __privateGet(this, _quantumWithAmount2).isIdentical(__privateGet(otherAsGrouping, _quantumWithAmount2));
  }
  get alg() {
    return __privateGet(this, _quantumWithAmount2).quantum;
  }
  get amount() {
    return __privateGet(this, _quantumWithAmount2).amount;
  }
  get experimentalRepetitionSuffix() {
    return __privateGet(this, _quantumWithAmount2).suffix();
  }
  invert() {
    return new _Grouping(__privateGet(this, _quantumWithAmount2).quantum, -__privateGet(this, _quantumWithAmount2).amount);
  }
  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {
    depth ?? (depth = Infinity);
    if (depth === 0) {
      yield iterDir === 1 /* Forwards */ ? this : this.invert();
    } else {
      yield* __privateGet(this, _quantumWithAmount2).experimentalExpand(iterDir, depth - 1);
    }
  }
  static fromString() {
    throw new Error("unimplemented");
  }
  toString() {
    return square1TupleFormatterInstance.format(this) ?? `(${__privateGet(this, _quantumWithAmount2).quantum.toString()})${__privateGet(this, _quantumWithAmount2).suffix()}`;
  }
  experimentalAsSquare1Tuple() {
    return square1TupleFormatterInstance.tuple(this);
  }
};
var Grouping = _Grouping;
_quantumWithAmount2 = new WeakMap();

// src/cubing/alg/is.ts
function experimentalIs(v, c) {
  return v instanceof c;
}
function experimentalIsAlgNode(v) {
  return experimentalIs(v, Grouping) || experimentalIs(v, LineComment) || experimentalIs(v, Commutator) || experimentalIs(v, Conjugate) || experimentalIs(v, Move) || experimentalIs(v, Newline) || experimentalIs(v, Pause);
}

// src/cubing/alg/traversal.ts
function dispatch(t, algNode, dataDown) {
  if (algNode.is(Grouping)) {
    return t.traverseGrouping(algNode, dataDown);
  }
  if (algNode.is(Move)) {
    return t.traverseMove(algNode, dataDown);
  }
  if (algNode.is(Commutator)) {
    return t.traverseCommutator(algNode, dataDown);
  }
  if (algNode.is(Conjugate)) {
    return t.traverseConjugate(algNode, dataDown);
  }
  if (algNode.is(Pause)) {
    return t.traversePause(algNode, dataDown);
  }
  if (algNode.is(Newline)) {
    return t.traverseNewline(algNode, dataDown);
  }
  if (algNode.is(LineComment)) {
    return t.traverseLineComment(algNode, dataDown);
  }
  throw new Error(`unknown AlgNode`);
}
function mustBeAlgNode(t) {
  if (t.is(Grouping) || t.is(Move) || t.is(Commutator) || t.is(Conjugate) || t.is(Pause) || t.is(Newline) || t.is(LineComment)) {
    return t;
  }
  throw new Error("internal error: expected AlgNode");
}
var TraversalDownUp = class {
  traverseAlgNode(algNode, dataDown) {
    return dispatch(this, algNode, dataDown);
  }
  traverseIntoAlgNode(algNode, dataDown) {
    return mustBeAlgNode(this.traverseAlgNode(algNode, dataDown));
  }
};
var TraversalUp = class extends TraversalDownUp {
  traverseAlgNode(algNode) {
    return dispatch(this, algNode, void 0);
  }
  traverseIntoAlgNode(algNode) {
    return mustBeAlgNode(this.traverseAlgNode(algNode));
  }
};
var _newPlaceholderAssociationsMap, _newPlaceholderAssociations, newPlaceholderAssociations_fn, _newAmount, newAmount_fn;
var _Simplify = class extends TraversalDownUp {
  constructor() {
    super(...arguments);
    __privateAdd(this, _newPlaceholderAssociations);
    __privateAdd(this, _newPlaceholderAssociationsMap, void 0);
  }
  *traverseAlg(alg, options) {
    if (options.depth === 0) {
      yield* alg.childAlgNodes();
      return;
    }
    const newAlgNodes = [];
    let lastAlgNode = null;
    const collapseMoves = options?.collapseMoves ?? true;
    function appendMoveWithNewAmount(move, deltaAmount) {
      var _a;
      const newAmount = __privateMethod(_a = _Simplify, _newAmount, newAmount_fn).call(_a, move, deltaAmount, options);
      if (newAmount === 0) {
        return false;
      }
      const newMove = new Move(move.quantum, newAmount);
      newAlgNodes.push(newMove);
      lastAlgNode = newMove;
      return true;
    }
    function appendCollapsed(newAlgNode) {
      if (collapseMoves && lastAlgNode?.is(Move) && newAlgNode.is(Move) && lastAlgNode.quantum.isIdentical(newAlgNode.quantum)) {
        newAlgNodes.pop();
        if (!appendMoveWithNewAmount(lastAlgNode, newAlgNode.amount)) {
          lastAlgNode = newAlgNodes.slice(-1)[0];
        }
      } else {
        if (newAlgNode.is(Move)) {
          appendMoveWithNewAmount(newAlgNode, 0);
        } else {
          newAlgNodes.push(newAlgNode);
          lastAlgNode = newAlgNode;
        }
      }
    }
    const newOptions = {
      depth: options.depth ? options.depth - 1 : null
    };
    for (const algNode of alg.childAlgNodes()) {
      for (const ancestorAlgNode of this.traverseAlgNode(algNode, newOptions)) {
        appendCollapsed(ancestorAlgNode);
      }
    }
    for (const newAlgNode of newAlgNodes) {
      yield newAlgNode;
    }
  }
  *traverseGrouping(grouping, options) {
    if (options.depth === 0) {
      yield grouping;
      return;
    }
    const newOptions = {
      depth: options.depth ? options.depth - 1 : null
    };
    const newGrouping = new Grouping(this.traverseAlg(grouping.alg, newOptions), grouping.amount);
    const newPlaceholder = __privateMethod(this, _newPlaceholderAssociations, newPlaceholderAssociations_fn).call(this).get(grouping);
    if (newPlaceholder) {
      newGrouping.experimentalNISSPlaceholder = newPlaceholder;
      newPlaceholder.experimentalNISSGrouping = newGrouping;
    }
    yield newGrouping;
  }
  *traverseMove(move, _options) {
    yield move;
  }
  *traverseCommutator(commutator, options) {
    if (options.depth === 0) {
      yield commutator;
      return;
    }
    const newOptions = {
      depth: options.depth ? options.depth - 1 : null
    };
    yield new Commutator(this.traverseAlg(commutator.A, newOptions), this.traverseAlg(commutator.B, newOptions));
  }
  *traverseConjugate(conjugate, options) {
    if (options.depth === 0) {
      yield conjugate;
      return;
    }
    const newOptions = {
      depth: options.depth ? options.depth - 1 : null
    };
    yield new Conjugate(this.traverseAlg(conjugate.A, newOptions), this.traverseAlg(conjugate.B, newOptions));
  }
  *traversePause(pause, _options) {
    if (pause.experimentalNISSGrouping) {
      const newPause = new Pause();
      __privateMethod(this, _newPlaceholderAssociations, newPlaceholderAssociations_fn).call(this).set(pause.experimentalNISSGrouping, newPause);
      yield newPause;
    } else {
      yield pause;
    }
  }
  *traverseNewline(newline, _options) {
    yield newline;
  }
  *traverseLineComment(comment, _options) {
    yield comment;
  }
};
var Simplify = _Simplify;
_newPlaceholderAssociationsMap = new WeakMap();
_newPlaceholderAssociations = new WeakSet();
newPlaceholderAssociations_fn = function() {
  return __privateGet(this, _newPlaceholderAssociationsMap) ?? __privateSet(this, _newPlaceholderAssociationsMap, /* @__PURE__ */ new Map());
};
_newAmount = new WeakSet();
newAmount_fn = function(move, deltaAmount, options) {
  let newAmount = move.amount + deltaAmount;
  if (options?.quantumMoveOrder) {
    const order = options.quantumMoveOrder(move.quantum);
    const min = Math.floor(order / 2) + 1 - order;
    newAmount = (newAmount % order + order - min) % order + min;
  }
  return newAmount;
};
__privateAdd(Simplify, _newAmount);
var simplifyInstance = new Simplify();
var simplify = simplifyInstance.traverseAlg.bind(simplifyInstance);

// src/cubing/alg/Alg.ts
function toIterable(input) {
  if (!input) {
    return [];
  }
  if (experimentalIs(input, Alg)) {
    return input.childAlgNodes();
  }
  if (typeof input === "string") {
    return parseAlg(input).childAlgNodes();
  }
  const iter = input;
  if (typeof iter[Symbol.iterator] === "function") {
    return iter;
  }
  throw new Error("Invalid AlgNode");
}
function experimentalEnsureAlg(alg) {
  if (experimentalIs(alg, Alg)) {
    return alg;
  }
  return new Alg(alg);
}
var _algNodes;
var _Alg = class extends AlgCommon {
  constructor(alg) {
    super();
    __privateAdd(this, _algNodes, void 0);
    __privateSet(this, _algNodes, Array.from(toIterable(alg)));
    for (const algNode of __privateGet(this, _algNodes)) {
      if (!experimentalIsAlgNode(algNode)) {
        throw new Error("An alg can only contain alg nodes.");
      }
    }
  }
  isIdentical(other) {
    const otherAsAlg = other;
    if (!other.is(_Alg)) {
      return false;
    }
    const l1 = Array.from(__privateGet(this, _algNodes));
    const l2 = Array.from(__privateGet(otherAsAlg, _algNodes));
    if (l1.length !== l2.length) {
      return false;
    }
    for (let i = 0; i < l1.length; i++) {
      if (!l1[i].isIdentical(l2[i])) {
        return false;
      }
    }
    return true;
  }
  invert() {
    return new _Alg(reverse(Array.from(__privateGet(this, _algNodes)).map((u) => u.invert())));
  }
  *experimentalExpand(iterDir = 1 /* Forwards */, depth) {
    depth ?? (depth = Infinity);
    for (const algNode of direct(__privateGet(this, _algNodes), iterDir)) {
      yield* algNode.experimentalExpand(iterDir, depth);
    }
  }
  expand(options) {
    return new _Alg(this.experimentalExpand(1 /* Forwards */, options?.depth ?? Infinity));
  }
  *experimentalLeafMoves() {
    for (const leaf of this.experimentalExpand()) {
      if (leaf.is(Move)) {
        yield leaf;
      }
    }
  }
  concat(input) {
    return new _Alg(Array.from(__privateGet(this, _algNodes)).concat(Array.from(toIterable(input))));
  }
  experimentalIsEmpty() {
    for (const _ of __privateGet(this, _algNodes)) {
      return false;
    }
    return true;
  }
  static fromString(s) {
    return parseAlg(s);
  }
  units() {
    return this.childAlgNodes();
  }
  *childAlgNodes() {
    for (const algNode of __privateGet(this, _algNodes)) {
      yield algNode;
    }
  }
  experimentalNumUnits() {
    return this.experimentalNumChildAlgNodes();
  }
  experimentalNumChildAlgNodes() {
    return Array.from(__privateGet(this, _algNodes)).length;
  }
  get type() {
    warnOnce("deprecated: type");
    return "sequence";
  }
  toString() {
    let output = "";
    let previousVisibleAlgNode = null;
    for (const algNode of __privateGet(this, _algNodes)) {
      if (previousVisibleAlgNode) {
        output += spaceBetween(previousVisibleAlgNode, algNode);
      }
      const nissGrouping = algNode.as(Pause)?.experimentalNISSGrouping;
      if (nissGrouping) {
        if (nissGrouping.amount !== -1) {
          throw new Error("Invalid NISS Grouping amount!");
        }
        output += `^(${nissGrouping.alg.toString()})`;
      } else if (algNode.as(Grouping)?.experimentalNISSPlaceholder) {
      } else {
        output += algNode.toString();
      }
      previousVisibleAlgNode = algNode;
    }
    return output;
  }
  simplify(options) {
    return new _Alg(simplify(this, options ?? {}));
  }
};
var Alg = _Alg;
_algNodes = new WeakMap();
function spaceBetween(u1, u2) {
  if (u1.is(Newline) || u2.is(Newline)) {
    return "";
  }
  if (u2.as(Grouping)?.experimentalNISSPlaceholder) {
    return "";
  }
  if (u1.is(LineComment) && !u2.is(Newline)) {
    return "\n";
  }
  return " ";
}

// src/cubing/alg/example.ts
var Example = {
  Sune: new Alg([
    new Move("R", 1),
    new Move("U", 1),
    new Move("R", -1),
    new Move("U", 1),
    new Move("R", 1),
    new Move("U", -2),
    new Move("R", -1)
  ]),
  AntiSune: new Alg([
    new Move("R", 1),
    new Move("U", 2),
    new Move("R", -1),
    new Move("U", -1),
    new Move("R", 1),
    new Move("U", -1),
    new Move("R", -1)
  ]),
  SuneCommutator: new Alg([
    new Commutator(new Alg([new Move("R", 1), new Move("U", 1), new Move("R", -2)]), new Alg([
      new Conjugate(new Alg([new Move("R", 1)]), new Alg([new Move("U", 1)]))
    ]))
  ]),
  Niklas: new Alg([
    new Move("R", 1),
    new Move("U", -1),
    new Move("L", -1),
    new Move("U", 1),
    new Move("R", -1),
    new Move("U", -1),
    new Move("L", 1),
    new Move("U", 1)
  ]),
  EPerm: new Alg([
    new Move("x", -1),
    new Commutator(new Alg([
      new Conjugate(new Alg([new Move("R", 1)]), new Alg([new Move("U", -1)]))
    ]), new Alg([new Move("D", 1)])),
    new Commutator(new Alg([
      new Conjugate(new Alg([new Move("R", 1)]), new Alg([new Move("U", 1)]))
    ]), new Alg([new Move("D", 1)])),
    new Move("x", 1)
  ]),
  FURURFCompact: new Alg([
    new Conjugate(new Alg([new Move("F", 1)]), new Alg([
      new Commutator(new Alg([new Move("U", 1)]), new Alg([new Move("R", 1)]))
    ]))
  ]),
  APermCompact: new Alg([
    new Conjugate(new Alg([new Move("R", 2)]), new Alg([
      new Commutator(new Alg([new Move("F", 2)]), new Alg([new Move("R", -1), new Move("B", -1), new Move("R", 1)]))
    ]))
  ]),
  FURURFMoves: new Alg([
    new Move("F", 1),
    new Move("U", 1),
    new Move("R", 1),
    new Move("U", -1),
    new Move("R", -1),
    new Move("F", -1)
  ]),
  TPerm: new Alg([
    new Move("R", 1),
    new Move("U", 1),
    new Move("R", -1),
    new Move("U", -1),
    new Move("R", -1),
    new Move("F", 1),
    new Move("R", 2),
    new Move("U", -1),
    new Move("R", -1),
    new Move("U", -1),
    new Move("R", 1),
    new Move("U", 1),
    new Move("R", -1),
    new Move("F", -1)
  ]),
  HeadlightSwaps: new Alg([
    new Conjugate(new Alg([new Move("F", 1)]), new Alg([
      new Grouping(new Alg([
        new Commutator(new Alg([new Move("R", 1)]), new Alg([new Move("U", 1)]))
      ]), 3)
    ]))
  ]),
  TriplePause: new Alg([new Pause(), new Pause(), new Pause()])
};

// src/cubing/alg/keyboard.ts
var cubeKeyMapping = {
  73: new Move("R"),
  75: new Move("R'"),
  87: new Move("B"),
  79: new Move("B'"),
  83: new Move("D"),
  76: new Move("D'"),
  68: new Move("L"),
  69: new Move("L'"),
  74: new Move("U"),
  70: new Move("U'"),
  72: new Move("F"),
  71: new Move("F'"),
  78: new Move("x'"),
  67: new Move("l"),
  82: new Move("l'"),
  85: new Move("r"),
  77: new Move("r'"),
  88: new Move("d"),
  188: new Move("d'"),
  84: new Move("x"),
  89: new Move("x"),
  66: new Move("x'"),
  186: new Move("y"),
  59: new Move("y"),
  65: new Move("y'"),
  80: new Move("z"),
  81: new Move("z'"),
  90: new Move("M'"),
  190: new Move("M'")
};
function keyToMove(e) {
  if (e.altKey || e.ctrlKey) {
    return null;
  }
  return cubeKeyMapping[e.keyCode] || null;
}

// src/cubing/alg/url.ts
function serializeURLParam(a) {
  let escaped = a.toString();
  escaped = escaped.replace(/_/g, "&#95;").replace(/ /g, "_");
  escaped = escaped.replace(/\+/g, "&#2b;");
  escaped = escaped.replace(/-/g, "&#45;").replace(/'/g, "-");
  return escaped;
}
function algCubingNetLink(options) {
  const url = new URL("https://alg.cubing.net");
  if (!options.alg) {
    throw new Error("An alg parameter is required.");
  }
  url.searchParams.set("alg", serializeURLParam(options.alg));
  if (options.setup) {
    url.searchParams.set("setup", serializeURLParam(options.setup));
  }
  if (options.title) {
    url.searchParams.set("title", options.title);
  }
  if (options.puzzle) {
    if (![
      "1x1x1",
      "2x2x2",
      "3x3x3",
      "4x4x4",
      "5x5x5",
      "6x6x6",
      "7x7x7",
      "8x8x8",
      "9x9x9",
      "10x10x10",
      "11x11x11",
      "12x12x12",
      "13x13x13",
      "14x14x14",
      "16x16x16",
      "17x17x17"
    ].includes(options.puzzle)) {
      throw new Error(`Invalid puzzle parameter: ${options.puzzle}`);
    }
    url.searchParams.set("puzzle", options.puzzle);
  }
  if (options.stage) {
    if (![
      "full",
      "cross",
      "F2L",
      "LL",
      "OLL",
      "PLL",
      "CLS",
      "ELS",
      "L6E",
      "CMLL",
      "WV",
      "ZBLL",
      "void"
    ].includes(options.stage)) {
      throw new Error(`Invalid stage parameter: ${options.stage}`);
    }
    url.searchParams.set("stage", options.stage);
  }
  if (options.view) {
    if (!["editor", "playback", "fullscreen"].includes(options.view)) {
      throw new Error(`Invalid view parameter: ${options.view}`);
    }
    url.searchParams.set("view", options.view);
  }
  if (options.type) {
    if (![
      "moves",
      "reconstruction",
      "alg",
      "reconstruction-end-with-setup"
    ].includes(options.type)) {
      throw new Error(`Invalid type parameter: ${options.type}`);
    }
    url.searchParams.set("type", options.type);
  }
  return url.toString();
}

// src/cubing/alg/operation.ts
function experimentalAppendMove(alg, newMove, options) {
  const oldAlgNodes = Array.from(alg.childAlgNodes());
  const oldLastMove = oldAlgNodes[oldAlgNodes.length - 1];
  if (options?.coalesce && oldLastMove && oldLastMove.quantum && oldLastMove.quantum.isIdentical(newMove.quantum)) {
    const newAlgNodes = oldAlgNodes.slice(0, oldAlgNodes.length - 1);
    let newAmount = oldLastMove.amount + newMove.amount;
    const mod = options?.mod;
    if (mod) {
      newAmount = (newAmount % mod + mod) % mod;
      if (newAmount * 2 > mod) {
        newAmount -= mod;
      }
    }
    if (newAmount !== 0) {
      newAlgNodes.push(oldLastMove.modified({ amount: newAmount }));
    }
    return new Alg(newAlgNodes);
  } else {
    return new Alg([...oldAlgNodes, newMove]);
  }
}

export {
  direct,
  directedGenerator,
  AlgBuilder,
  setAlgDebug,
  Commutator,
  Conjugate,
  LineComment,
  Newline,
  Pause,
  QuantumMove,
  Move,
  Grouping,
  experimentalIs,
  TraversalDownUp,
  TraversalUp,
  Alg,
  Example,
  keyToMove,
  algCubingNetLink,
  experimentalAppendMove
};
//# sourceMappingURL=chunk-GXZIBFSN.js.map
