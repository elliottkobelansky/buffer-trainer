{
  "version": 3,
  "sources": ["../../src/cubing/search/inside/solve/puzzles/clock.ts", "../../src/cubing/search/inside/solve/puzzles/wca-minx.ts", "../../src/cubing/vendor/comlink-everywhere/outside/index.ts", "../../src/cubing/search/inside/search-worker-ts-entry-path-getter.ts", "../../src/cubing/search/instantiator.ts", "../../src/cubing/search/outside.ts"],
  "sourcesContent": ["import { randomUIntBelowFactory } from \"../../../../vendor/random-uint-below\";\n\nconst pins = [\"UR\", \"DR\", \"DL\", \"UL\"];\nconst backMoves = [\"U\", \"R\", \"D\", \"L\", \"ALL\"];\nconst frontMoves = pins.concat(backMoves);\n\nconst randomUIntBelowPromise = randomUIntBelowFactory();\n\nexport async function randomClockScrambleString(): Promise<string> {\n  const randomUIntBelow = await randomUIntBelowPromise;\n\n  let filteringMoveCount = 0;\n\n  async function randomSuffix(randomUIntBelow: (max: number) => number) {\n    const amount = randomUIntBelow(12);\n    if (amount !== 0) {\n      filteringMoveCount++;\n    }\n    if (amount <= 6) {\n      return `${amount}+`;\n    } else {\n      return `${12 - amount}-`;\n    }\n  }\n\n  const moves = [];\n  async function side(families: string[]): Promise<void> {\n    for (const family of families) {\n      moves.push(`${family}${await randomSuffix(randomUIntBelow)}`);\n    }\n  }\n\n  await side(frontMoves);\n  moves.push(\"y2\");\n  await side(backMoves);\n\n  // https://www.worldcubeassociation.org/regulations/#4b3\n  if (filteringMoveCount < 2) {\n    return randomClockScrambleString();\n  }\n\n  for (const pin of pins) {\n    if (randomUIntBelow(2) === 0) {\n      moves.push(pin);\n    }\n  }\n  return moves.join(\" \");\n}\n", "import { randomUIntBelowFactory } from \"../../../../vendor/random-uint-below\";\n\nconst randomUIntBelowPromise = randomUIntBelowFactory();\n\nconst suffixes = [\"++\", \"--\"];\n\nexport async function randomMegaminxScrambleString(): Promise<string> {\n  const randomUIntBelow = await randomUIntBelowPromise;\n\n  function rdPair(): string {\n    return `R${suffixes[randomUIntBelow(2)]} D${suffixes[randomUIntBelow(2)]}`;\n  }\n\n  function randomU(): string {\n    return `U${[\"\", \"'\"][randomUIntBelow(2)]}`;\n  }\n\n  function row(): string {\n    const chunks = [];\n    for (let i = 0; i < 5; i++) {\n      chunks.push(rdPair());\n    }\n    chunks.push(randomU());\n    return chunks.join(\" \");\n  }\n\n  const chunks = [];\n  for (let i = 0; i < 6; i++) {\n    chunks.push(row());\n  }\n  return chunks.join(\"\\n\");\n}\n", "import nodeEndpoint from \"../node-adapter\";\n\nexport { wrap } from \"comlink\";\n// Mangled so that bundlers don't try to inline the source.\n\nconst worker_threads_mangled = \"node:w-orker-_threa-ds\";\nconst worker_threads_unmangled = () => worker_threads_mangled.replace(/-/g, \"\");\n\nconst useNodeWorkarounds =\n  typeof globalThis.Worker === \"undefined\" &&\n  typeof (globalThis as any).WorkerNavigator === \"undefined\";\n\nasync function nodeWorker(\n  source: string | URL,\n  options?: { eval?: boolean },\n): Promise<Worker> {\n  const { Worker: NodeWorker } = await import(\n    /* @vite-ignore */ worker_threads_unmangled()\n  );\n  const worker = new NodeWorker(source, options);\n  worker.unref();\n  return nodeEndpoint(worker);\n}\n\nexport async function constructWorker(\n  source: string | URL,\n  options?: { eval?: boolean; type?: WorkerType },\n): Promise<Worker> {\n  let worker;\n  if (useNodeWorkarounds) {\n    return nodeWorker(source, { eval: options?.eval });\n  } else {\n    if (options?.eval) {\n      const blob = new Blob([source as string], {\n        type: \"application/javascript\",\n      });\n      source = URL.createObjectURL(blob);\n    }\n    worker = new globalThis.Worker(source, {\n      type: options ? options.type : undefined, // TODO: Is it safe to use `options?.type`?\n    });\n  }\n  return worker;\n}\n", "import { exposeAPI } from \"./worker-guard\";\n\nexposeAPI.expose = false;\nexport async function getWorkerEntryFileURL() {\n  return (await import(\"./search-worker-ts-entry\")).WORKER_ENTRY_FILE_URL;\n}\n", "import { constructWorker, wrap } from \"../vendor/comlink-everywhere/outside\";\nimport type { WorkerInsideAPI } from \"./inside/api\";\nimport { getWorkerEntryFileURL } from \"./inside/search-worker-ts-entry-path-getter\";\n\nconst MODULE_WORKER_TIMEOUT_MILLISECONDS = 5000;\n\nlet forceStringWorker: boolean = false;\nexport function setForceStringWorker(force: boolean): void {\n  forceStringWorker = force;\n}\nlet disableStringWorker: boolean = false;\nexport function setDisableStringWorker(disable: boolean): void {\n  disableStringWorker = disable;\n}\n\nexport async function instantiateModuleWorker(): Promise<WorkerInsideAPI> {\n  // eslint-disable-next-line no-async-promise-executor\n  return new Promise<WorkerInsideAPI>(async (resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      reject(new Error(\"module instantiation timeout\"));\n    }, MODULE_WORKER_TIMEOUT_MILLISECONDS);\n\n    try {\n      const workerEntryFileURL = await getWorkerEntryFileURL();\n      if (!workerEntryFileURL) {\n        // This happens in `bundle-global`.\n        reject(new Error(\"Could not get worker entry file URL.\"));\n      }\n      let url: string | URL;\n      if (globalThis.Worker) {\n        // Standard browser-like environment.\n        const importSrc = `import \"${workerEntryFileURL}\";`;\n        const blob = new Blob([importSrc], {\n          type: \"text/javascript\",\n        });\n        url = URL.createObjectURL(blob);\n      } else {\n        // `node` < 18 doesn't have `Blob`:\n        // https://nodejs.org/ko/blog/announcements/v18-release-announce/#other-global-apis\n        // But `node` will not let us construct a worker from a `blob:` URL either.\n        //\n        // We need to keep the original entry file URL, but we have to wrap it in the `URL` class.\n        url = new URL(workerEntryFileURL);\n      }\n\n      const worker = (await constructWorker(url, {\n        type: \"module\",\n      })) as Worker & {\n        nodeWorker?: import(\"worker_threads\").Worker;\n      };\n\n      const onError = (e: ErrorEvent) => {\n        // TODO: Remove fallback when Firefox implements module workers: https://bugzilla.mozilla.org/show_bug.cgi?id=1247687\n        if (e.message?.startsWith(\"SyntaxError\")) {\n          reject(e);\n        }\n      };\n\n      const onFirstMessage = (messageData: string) => {\n        if (messageData === \"comlink-exposed\") {\n          // We need to clear the timeout so that we don't prevent `node` from exiting in the meantime.\n          clearTimeout(timeoutID);\n          resolve(wrap<WorkerInsideAPI>(worker));\n        } else {\n          reject(\n            new Error(\"wrong module instantiation message \" + messageData),\n          );\n        }\n      };\n\n      if (worker.nodeWorker) {\n        // We have to use `once` so the `unref()` from `comlink-everywhere` allows the process to quite as expected.\n        worker.nodeWorker.once(\"message\", onFirstMessage);\n      } else {\n        worker.addEventListener(\"error\", onError, {\n          once: true,\n        });\n        worker.addEventListener(\"message\", (e) => onFirstMessage(e.data), {\n          once: true,\n        });\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nasync function instantiateClassicWorker(): Promise<WorkerInsideAPI> {\n  const { workerSource } = await import(\n    \"./search-worker-inside-generated-string.js\"\n  );\n  const worker = await constructWorker(workerSource, { eval: true });\n  return wrap(worker);\n}\n\nexport async function instantiateWorker(): Promise<WorkerInsideAPI> {\n  if (forceStringWorker) {\n    console.warn(\n      \"Using the `forceStringWorker` workaround for search worker instantiation. This will require downloading significantly more code than necessary, but the functionality will be the same.\",\n    );\n    return instantiateClassicWorker();\n  }\n  try {\n    // `await` is important for `catch` to work.\n    return await instantiateModuleWorker();\n  } catch (e) {\n    const commonErrorPrefix =\n      \"Could not instantiate module worker (this may happen in Firefox, with `bundle-global`, or when using Parcel).\";\n    if (disableStringWorker) {\n      console.error(\n        `${commonErrorPrefix} Fallback to string worker is disabled.`,\n        e,\n      );\n      throw new Error(`Module worker instantiation failed.`);\n    }\n    console.warn(`${commonErrorPrefix} Falling back to string worker.`, e);\n    return instantiateClassicWorker();\n  }\n}\n", "import { Alg } from \"../alg\";\n// import { preInitialize222 } from \"../implementations/2x2x2\";\nimport { randomClockScrambleString } from \"./inside/solve/puzzles/clock\"; // TODO: don't reach into `inside` code.\nimport { randomMegaminxScrambleString } from \"./inside/solve/puzzles/wca-minx\"; // TODO: don't reach into `inside` code.\nimport {\n  instantiateWorker,\n  setDisableStringWorker,\n  setForceStringWorker,\n} from \"./instantiator\";\nimport type { PrefetchLevel, WorkerInsideAPI } from \"./inside/api\";\nimport type { KState } from \"../kpuzzle/KState\";\n\nlet cachedWorkerInstance: Promise<WorkerInsideAPI> | null = null;\nasync function getCachedWorkerInstance(): Promise<WorkerInsideAPI> {\n  return await (cachedWorkerInstance ??= instantiateWorker());\n}\n\n// Pre-initialize the scrambler for the given event. (Otherwise, an event is\n// initialized the first time you ask for a scramble for that event.)\n//\n// Some typical numbers for a fast computer:\n// - 3x3x3 initialization: 200ms\n// - Each 3x3x3 scramble: 50ms\n// - 4x4x4 initialization: 2500ms\n// - Each 4x4x4 scramble: 300ms to 800ms\n//\n// It is safe to immediately call for a scramble\n// any time after starting pre-initialization, or to call for them without\n// pre-initializing. Pre-initializing essentially gives the scramble worker a\n// head start in case a scramble doesn't get requested immediately.\n//\n// Note that events cannot be pre-initialized in parallel. Attempting to\n// pre-initialize multiple events will initialize them consecutively. Scrambles\n// for a given event cannot be computed while another event is being initialized.\nexport function _preInitializationHintForEvent(\n  eventID: string,\n  // callback?: () => void\n): void {\n  switch (eventID) {\n    case \"clock\":\n    case \"minx\":\n      return;\n    case \"333oh\":\n      return _preInitializationHintForEvent(\"333\");\n  }\n  (async () => {\n    await (await getCachedWorkerInstance()).initialize(eventID);\n  })();\n}\n\nexport async function randomScrambleForEvent(eventID: string): Promise<Alg> {\n  switch (eventID) {\n    case \"clock\":\n      return Alg.fromString(await randomClockScrambleString());\n    case \"minx\":\n      return Alg.fromString(await randomMegaminxScrambleString());\n  }\n  const prom = _randomScrambleStringForEvent(eventID);\n  const wat = await prom;\n  return Alg.fromString(wat);\n}\n\nexport async function _randomScrambleStringForEvent(\n  eventID: string,\n): Promise<string> {\n  const cwi = await getCachedWorkerInstance();\n  return cwi.randomScrambleStringForEvent(eventID);\n}\n\nexport async function randomScrambleStringForEvent(\n  eventID: string,\n): Promise<string> {\n  switch (eventID) {\n    case \"clock\":\n      return randomClockScrambleString();\n    case \"minx\":\n      return randomMegaminxScrambleString();\n  }\n  return await _randomScrambleStringForEvent(eventID);\n}\n\nexport async function experimentalSolve3x3x3IgnoringCenters(\n  state: KState,\n): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solve333ToString(state.stateData));\n}\n\nexport async function experimentalSolve2x2x2(state: KState): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solve222ToString(state.stateData));\n}\n\nexport async function solveSkewb(state: KState): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solveSkewbToString(state.stateData));\n}\n\nexport async function solvePyraminx(state: KState): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solvePyraminxToString(state.stateData));\n}\n\nexport async function solveMegaminx(state: KState): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(await cwi.solveMegaminxToString(state.stateData));\n}\n\nexport function setDebug(options: {\n  logPerf?: boolean;\n  scramblePrefetchLevel?: `${PrefetchLevel}`;\n  forceStringWorker?: boolean;\n  disableStringWorker?: boolean;\n}): void {\n  const { logPerf, scramblePrefetchLevel } = options;\n  if (typeof logPerf !== \"undefined\") {\n    getCachedWorkerInstance().then((cwi) => cwi.setDebugMeasurePerf(logPerf));\n  }\n  if (typeof scramblePrefetchLevel !== \"undefined\") {\n    getCachedWorkerInstance().then((cwi) =>\n      cwi.setScramblePrefetchLevel(scramblePrefetchLevel as PrefetchLevel),\n    );\n  }\n  if (\"forceStringWorker\" in options) {\n    setForceStringWorker(!!options.forceStringWorker);\n  }\n  if (\"disableStringWorker\" in options) {\n    setDisableStringWorker(!!options.disableStringWorker);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
