{
  "version": 3,
  "sources": ["../../src/cubing/vendor/xyzzy/kilosolver.js"],
  "sourcesContent": ["/* eslint-disable */\n/* kilosolver.js - A kilominx solver\nversion 0.7 (2021-04-03)\nCopyright (c) 2016, 2020, 2021\n\nFrom https://torchlight.github.io/kiloscrambler.html\nOriginally MIT licensed, added to `cubing.js` under the GPL license by permission from the author (@torchlight/xyzzy).\n\nThis is a port of the kilominx solver originally written in Python with a few minor optimisations.\n\nHow to run this:\n(0) Save this file somewhere.\n(1) Install any JavaScript shell and run it with this file.\n(2) Type stuff into the shell.\n\n(or just use the HTML interface! it exists now!)\n\nThere is currently not much of a public interface. Useful stuff:\ncache_all_tables()\n    to generate all the lookup tables\nprint_move_sequence(generate_random_state_scramble())\n    to get a random-state scramble\nprint_move_sequence(generate_hybrid_scramble())\n    to get a hybrid random-move scramble\n\nFor the full solver (used in the random-state scrambler), a few hundred megabytes of RAM may be used\nfor the lookup tables, which will also take roughly a minute to generate. Once generated, each solve\ntakes roughly 0.08 second.\n\nThe hybrid scrambler uses much smaller lookup tables that take less memory and are generated faster,\nbut produces somewhat longer scramble sequences and isn't fully random-state. It should nevertheless\nbe good enough for non-competition purposes.\n\nOn the to-do list:\n- optimise the heck out of the lookup table generation\n- a GUI for the solver\n- optimise the solver with colour neutrality and NISS(tm) techniques\n- throw all the global variables into a namespace\n\nCompatibility notes:\nThis code makes fairly heavy use of ES6 syntactic sugar because writing code in JavaScript's already\nan exercise in masochism and I'm not going to make my life harder by restricting myself to ES5. Some\nof the features used are:\n- let, const\n- destructuring assignment\n- for-of\n- arrow functions\n- 'use strict'\n\nAny web browser from 2016 or later should support all of these; the code has been tested only on the\nlatest versions of Firefox and Chrome, as well as a somewhat outdated SpiderMonkey shell, but should\nalso work with recent versions of Edge, Safari, etc.\n*/\n\n\"use strict\";\n\nimport { Alg } from \"../../alg\";\nimport { randomUIntBelowFactory } from \"../random-uint-below\";\n\nlet PHASE4_THRESHOLD = 7;\n// change this to 8 to make the individual solves faster, at the cost of slower initialisation\n\nfunction counter(A) {\n  let counts = [];\n  for (let a of A) counts[a] = (counts[a] || 0) + 1;\n  return counts;\n}\n\n/* Combinatoric functions */\n\nfunction factorial(n) {\n  if (n < 2) return n;\n  let f = 1;\n  for (let i = 2; i <= n; i++) f *= i;\n  return f;\n}\n\nfunction C(n, k) {\n  if (k < 0 || k > n) return 0;\n  if (k === 0 || k === n) return 1;\n  let c = 1;\n  for (let i = 0; i < k; i++) {\n    c = ((c * (n - i)) / (i + 1)) | 0;\n  }\n  return c;\n}\n\nfunction permutation_to_index(perm) {\n  perm = perm.slice();\n  let n = perm.length;\n  let f = factorial(n - 1);\n  let ind = 0;\n  while (n > 1) {\n    n--;\n    // invariant: f == factorial(n)\n    // also, perm stores meaningful values up to perm[n]\n    let e = perm[0];\n    ind += e * f;\n    for (let i = 0; i < n; i++) {\n      let x = perm[i + 1];\n      perm[i] = x - (x > e);\n    }\n    f /= n;\n  }\n  return ind;\n}\n\nfunction index_to_permutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1);\n  for (let i = 0; i < n; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      perm[j] += +(perm[j] >= perm[i]);\n    }\n  }\n  return perm;\n}\n\nfunction permutation_parity(A) {\n  let n = A.length;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = i; j < n; j++) {\n      if (A[i] > A[j]) parity ^= 1;\n    }\n  }\n  return parity;\n}\n\nfunction index_to_evenpermutation(ind, n) {\n  let perm = [];\n  let f = factorial(n - 1) / 2;\n  let parity = 0;\n  for (let i = 0; i < n - 1; i++) {\n    perm[i] = (ind / f) | 0;\n    ind %= f;\n    f /= n - 1 - i;\n  }\n  perm[n - 1] = 0;\n  for (let i = n - 2; i >= 0; i--) {\n    for (let j = i + 1; j < n; j++) {\n      if (perm[j] >= perm[i]) perm[j]++;\n      else parity ^= 1;\n    }\n  }\n  if (parity === 1) [perm[n - 2], perm[n - 1]] = [perm[n - 1], perm[n - 2]];\n  return perm;\n}\n\nfunction evenpermutation_to_index(perm) {\n  return permutation_to_index(perm) >> 1;\n}\n\nlet [evenpermutation10_to_index, index_to_evenpermutation10] = (() => {\n  let index_in_set_bits = new Int8Array(1024 * 10);\n  let look_up_set_bits = new Int8Array(1024 * 10);\n  for (let i = 0; i < 1024; i++) {\n    for (let j = 0, counter = 0; j < 10; j++) {\n      if (((i >>> j) & 1) === 0) {\n        continue;\n      }\n      index_in_set_bits[(j << 10) | i] = counter;\n      look_up_set_bits[(counter << 10) | i] = j;\n      counter++;\n    }\n  }\n\n  function evenpermutation10_to_index(perm) {\n    let unused = 0x3ff; // track which values in 0..9 haven't been used so far\n    let f = 181440; // = 9!/2\n    let ind = 0;\n    for (let i = 0; i < 8; i++) {\n      let v = perm[i];\n      ind += index_in_set_bits[unused | (v << 10)] * f;\n      unused &= ~(1 << v);\n      f /= 9 - i;\n    }\n    return ind;\n  }\n\n  // note: this is *not* a drop-in replacement for index_to_evenpermutation!\n  function index_to_evenpermutation10(ind, perm) {\n    let unused = 0x3ff;\n    let f = 181440; // = 9!/2\n    let parity = 0;\n    for (let i = 0; i < 8; i++) {\n      let a = (ind / f) | 0;\n      ind -= a * f;\n      parity ^= a & 1;\n      let v = look_up_set_bits[unused | (a << 10)];\n      perm[i] = v;\n      unused &= ~(1 << v);\n      f /= 9 - i;\n    }\n    // the last two elements are uniquely determined by the other ten\n    perm[8] = look_up_set_bits[unused | (parity << 10)];\n    perm[9] = look_up_set_bits[unused | ((parity ^ 1) << 10)];\n    return perm;\n  }\n\n  return [evenpermutation10_to_index, index_to_evenpermutation10];\n})();\n\nfunction comb_to_index(l) {\n  let bits = l.length;\n  let ones = 0;\n  for (let i = 0; i < bits; i++) ones += +(l[i] === 1);\n  let zeros = bits - ones;\n  if (zeros === 0 || ones === 0 || bits === 1) return 0;\n  let b = C(bits - 1, ones);\n  let ind = 0;\n  for (let i = 0; zeros > 0 && ones > 0 && bits > 1; i++) {\n    bits--;\n    if (l[i] === 0) {\n      b = (b * --zeros) / bits;\n    } // l[i] === 1\n    else {\n      ind += b;\n      b = (b * ones--) / bits;\n    }\n  }\n  return ind;\n}\n\nfunction index_to_comb(ind, ones, bits) {\n  let zeros = bits - ones;\n  let b = C(bits - 1, ones);\n  let l = [];\n  let n = bits - 1;\n  for (let i = 0; i < n; i++) {\n    bits--;\n    if (ind < b) {\n      l.push(0);\n      b = (b * --zeros) / bits;\n    } else {\n      l.push(1);\n      ind -= b;\n      b = (b * ones--) / bits;\n    }\n  }\n  l.push(ones);\n  return l;\n}\n\nfunction compose(A, B) {\n  let C = [];\n  for (let i = 0; i < B.length; i++) C[i] = A[B[i]];\n  return C;\n}\n\nfunction compose_o(A, B) {\n  // note: we hardcode the modulus to 3 here, because ~optimisations~\n  // (unnecessary abstraction is bad, actually)\n  let p = compose(A[0], B[0]);\n  let o = [];\n  let n = B[0].length;\n  for (let i = 0; i < n; i++) {\n    o[i] = (A[1][B[0][i]] + B[1][i]) % 3;\n  }\n  return [p, o];\n}\n\nfunction permutation_from_cycle(cycle, n) {\n  let perm = [];\n  for (let i = 0; i < n; i++) perm[i] = i;\n  for (let i = 0; i < cycle.length; i++) {\n    perm[cycle[i]] = cycle[(i + 1) % cycle.length];\n  }\n  return perm;\n}\n\nfunction unsparsify_list(d, n) {\n  let l = Array(n).fill(0);\n  for (let k in d) l[k] = d[k];\n  return l;\n}\n\n/* The basic moves */\n\nconst move_U = [\n  permutation_from_cycle([0, 1, 2, 3, 4], 20),\n  unsparsify_list({}, 20),\n];\nconst move_R = [\n  permutation_from_cycle([4, 3, 11, 12, 13], 20),\n  unsparsify_list({ 4: 2, 3: 1, 11: 1, 12: 1, 13: 1 }, 20),\n];\nconst move_F = [\n  permutation_from_cycle([3, 2, 9, 10, 11], 20),\n  unsparsify_list({ 3: 2, 2: 1, 9: 1, 10: 1, 11: 1 }, 20),\n];\nconst move_L = [\n  permutation_from_cycle([2, 1, 7, 8, 9], 20),\n  unsparsify_list({ 2: 2, 1: 1, 7: 1, 8: 1, 9: 1 }, 20),\n];\nlet move_BL = [\n  permutation_from_cycle([1, 0, 5, 6, 7], 20),\n  unsparsify_list({ 1: 2, 0: 1, 5: 1, 6: 1, 7: 1 }, 20),\n];\nlet move_BR = [\n  permutation_from_cycle([0, 4, 13, 14, 5], 20),\n  unsparsify_list({ 0: 2, 4: 1, 13: 1, 14: 1, 5: 1 }, 20),\n];\nlet move_x2 = [\n  [15, 16, 17, 18, 19, 10, 9, 8, 7, 6, 5, 14, 13, 12, 11, 0, 1, 2, 3, 4],\n  unsparsify_list({}, 20),\n];\nlet move_y = [\n  [1, 2, 3, 4, 0, 7, 8, 9, 10, 11, 12, 13, 14, 5, 6, 19, 15, 16, 17, 18],\n  unsparsify_list({}, 20),\n];\nlet move_rot = [\n  [9, 10, 11, 3, 2, 8, 16, 15, 19, 12, 13, 4, 0, 1, 7, 14, 18, 17, 6, 5],\n  [2, 0, 1, 2, 1, 2, 2, 0, 1, 1, 1, 1, 0, 2, 2, 1, 2, 1, 2, 0],\n];\n\nconst moves = [move_U, move_R, move_F, move_L, move_BL, move_BR, move_x2];\nconst move_names = [\"U\", \"R\", \"F\", \"L\", \"BL\", \"BR\", \"x2\"];\n\nlet id = compose_o(move_x2, move_x2);\n\nlet moves_full = [];\nfor (let i = 0; i < moves.length; i++) {\n  moves_full[i] = [id];\n  for (let j = 1; j < 5; j++)\n    moves_full[i][j] = compose_o(moves_full[i][j - 1], moves[i]);\n}\n\nfunction random_state(randomUintBelow) {\n  let p = [0];\n  for (let i = 1; i < 20; i++) {\n    let r = randomUintBelow(i + 1);\n    p[i] = p[r];\n    p[r] = i;\n  }\n  if (permutation_parity(p) === 1) [p[0], p[1]] = [p[1], p[0]];\n  let o = Array(20).fill(0);\n  for (let i = 0; i < 19; i++) {\n    o[i] = randomUintBelow(3);\n    o[19] += 3 - o[i];\n  }\n  o[19] %= 3;\n  return [p, o];\n}\n\n/* Human interface stuff */\n\nfunction stringify_move_sequence(move_sequence) {\n  let suffixes = [\"0\", \"\", \"2\", \"2'\", \"'\"];\n  let s = move_sequence.map(([m, r]) => move_names[m] + suffixes[r]);\n  return s.join(\" \");\n}\n\nfunction print_move_sequence(move_sequence) {\n  console.log(stringify_move_sequence(move_sequence));\n}\n\nfunction apply_move_sequence(state, move_sequence) {\n  for (let [m, r] of move_sequence) {\n    for (let i = 0; i < r; i++) state = compose_o(state, moves[m]);\n  }\n  return state;\n}\n\nfunction generate_random_state_scramble(randomUintBelow) {\n  return solve(random_state(randomUintBelow));\n}\n\nfunction generate_random_move_scramble(M, N) {\n  M = M || 6;\n  N = N || 6;\n  // total number of moves = (M+1)(N+1)-1\n  let move_sequence = [];\n  for (let i = 0; i <= M; i++) {\n    let last = -1,\n      lastlast = -1;\n    for (let j = 0; j < N; j++) {\n      let m;\n      while (true) {\n        m = Math.floor(Math.random() * 6);\n        // don't output stuff like U2 U\n        if (m === last) continue;\n        // U move never commutes with the others\n        else if (m === 0) break;\n        // don't output stuff like L R L because L and R commute\n        else if (m === lastlast && ((m - last) * (m - last)) % 5 === 4)\n          continue;\n        else break;\n      }\n      // make 144-deg moves twice as likely as 72-deg moves\n      move_sequence.push([m, 1 + Math.round(Math.random() * 3)]);\n      [last, lastlast] = [m, last];\n    }\n    // flip after every set of moves on the hemisphere except the last because that would be\n    // kind of pointless\n    if (i < M) move_sequence.push([6, 1]);\n  }\n  return move_sequence;\n}\n\n/* a brief note on analysing random-move scrambles\n\nLet M = num flips and N = num moves between flips.\n\nTracking just corner orientation is pretty much useless to determine if a scramble is good, at least\nfor the choice of CO reference used in the solver (<U,flip,(R'FRF')3>); even M=1, N=8 is good enough\nto randomise the CO, despite leaving a bunch of obvious blocks.\n\nInstead, we can track the location of, say, the white pieces. There are C(20, 5) combinations, so we\njust try out a million random-move scrambles and do a chi-squared test. (Except I don't have a stats\npackage installed, so this is just a qualitative approximation.)\n\nM=4, N=5 (29 moves): +2.7 stddev\nM=3, N=8 (35 moves): +15.7 stddev\nM=5, N=5 (35 moves): -0.1 stddev\nM=4, N=7 (39 moves): +3.8 stddev\nM=5, N=6 (41 moves): -0.4 stddev\nM=4, N=8 (44 moves): +2.2 stddev\n\n(the 95% confidence interval for these estimated values should be taken to be +-2, as usual)\n\nObviously we get closer to a uniform distribution with more moves, but we also want the scrambles to\nbe of a reasonable length. M=5, N=6 seems to be a good tradeoff.\n\nThis is until you realise that the five grey pieces are effectively scrambled with M reduced by one,\nso we compensate for that by using M=6, N=6, which gives 48-move scrambles.\n\nasdsadsf\n\n(tl;dr: use the hybrid scrambler if you can stomach 0.3-second initialisation; don't use this)\n*/\n\n/* GUI stuff\n\nThe create_svg_template function returns an <svg> element with the facelets laid out neatly as a net\nand the draw_state function fills in the colours given a state.\n\nThe input to the latter function does not have to be an <svg> element returned by the former, but it\nmust contain an element for each of the 60 facelets, with class 'loc%d_%d' % (i, j), where i is from\n0 to 19 and j is either 0, 1 or 2.\n\nj = 0 corresponds to the reference facelet (the one closest to perpendicular to the U-D axis), j = 1\ncorresponds to the one clockwise from the reference, and j = 2 corresponds to the one anticlockwise.\n\nOther than the loc%d_%d classes, the facelet <polygon> elements also have the .facelet class and the\nface outline <polygon> elements have the .face class, and may be customised with CSS. For example:\n\n.face {stroke-linejoin: miter; stroke-width: 0.1;}\n\nThis can be used to make the corners sharp and the face outlines thicker; you get the idea.\n\nTODO: figure out a sane way to handle changing colour scheme on the fly\n(maybe tag the facelets with a separate class for each colour in addition to setting the fill)\n*/\n\n// colours copied from Kit's modded version of the Python scrambler, but with pale yellow made a bit\n// darker.\nlet default_colour_scheme = {\n  U: \"#ffffff\", // U (white)\n  L: \"#57007f\", // L (purple)\n  F: \"#007f0e\", // F (green)\n  R: \"#ff0000\", // R (red)\n  BR: \"#0026ff\", // BR (blue)\n  BL: \"#ffd800\", // BL (yellow)\n  DBR: \"#ff82b8\", // DBR (pink)\n  DB: \"#00ff21\", // DB (light green)\n  DBL: \"#ff6a00\", // DBL (orange)\n  DFL: \"#0094ff\", // DFL (light blue)\n  DFR: \"#ffff77\", // DFR (pale yellow)\n  D: \"#808080\", // D (grey)\n};\n\nlet face_names = [\n  \"U\",\n  \"L\",\n  \"F\",\n  \"R\",\n  \"BR\",\n  \"BL\",\n  \"DBR\",\n  \"DB\",\n  \"DBL\",\n  \"DFL\",\n  \"DFR\",\n  \"D\",\n];\n\n// return the face on which the loc_ori piece lies\nfunction map_piece_to_face(loc, ori) {\n  ori = ((ori % 3) + 3) % 3;\n  let face = [\n    [\"U\", \"BL\", \"BR\"],\n    [\"U\", \"L\", \"BL\"],\n    [\"U\", \"F\", \"L\"],\n    [\"U\", \"R\", \"F\"],\n    [\"U\", \"BR\", \"R\"],\n    [\"DB\", \"BR\", \"BL\"],\n    [\"BL\", \"DBL\", \"DB\"],\n    [\"DBL\", \"BL\", \"L\"],\n    [\"L\", \"DFL\", \"DBL\"],\n    [\"DFL\", \"L\", \"F\"],\n    [\"F\", \"DFR\", \"DFL\"],\n    [\"DFR\", \"F\", \"R\"],\n    [\"R\", \"DBR\", \"DFR\"],\n    [\"DBR\", \"R\", \"BR\"],\n    [\"BR\", \"DB\", \"DBR\"],\n    [\"D\", \"DFL\", \"DFR\"],\n    [\"D\", \"DBL\", \"DFL\"],\n    [\"D\", \"DB\", \"DBL\"],\n    [\"D\", \"DBR\", \"DB\"],\n    [\"D\", \"DFR\", \"DBR\"],\n  ][loc][ori];\n  return face;\n}\n\n// how much to rotate a facelet (divided by 18 degrees) and where to draw it\nlet rotation_amounts = [\n  [0, 3, 7],\n  [8, 1, 5],\n  [6, 9, 3],\n  [4, 7, 1],\n  [2, 5, 9],\n  [0, 9, 1],\n  [9, 0, 2],\n  [2, 7, 9],\n  [7, 2, 4],\n  [4, 5, 7],\n  [5, 4, 6],\n  [6, 3, 5],\n  [3, 6, 8],\n  [8, 1, 3],\n  [1, 8, 0],\n  [5, 8, 2],\n  [3, 6, 0],\n  [1, 4, 8],\n  [9, 2, 6],\n  [7, 0, 4],\n];\nlet translation_amounts;\n{\n  let A = Math.sin(Math.PI / 5),\n    B = Math.cos(Math.PI / 10);\n  let C = Math.cos(Math.PI / 5),\n    D = Math.sin(Math.PI / 10);\n  translation_amounts = {\n    U: [0, 0],\n    L: [-A - B, C - D],\n    F: [0, 2 * C],\n    R: [A + B, C - D],\n    BR: [B, -1 - D],\n    BL: [-B, -1 - D],\n    DBR: [2 * A + 2 * B, 0],\n    DB: [3 * A + 3 * B, -C - D],\n    DBL: [4 * A + 4 * B, 0],\n    DFL: [3 * A + 4 * B, 1 + C],\n    DFR: [3 * A + 2 * B, 1 + C],\n    D: [3 * A + 3 * B, C - D],\n  };\n  // trigonometry :(\n}\n\nfunction create_svg_template(state, colour_scheme) {\n  state = state || id;\n  colour_scheme = colour_scheme || default_colour_scheme;\n  let svgns = \"http://www.w3.org/2000/svg\";\n  let root = document.createElementNS(svgns, \"svg\");\n  root.setAttribute(\"viewBox\", \"-2.590 -2.218 9.796 4.936\");\n  /*\n\tlong diagonal = 1\n\tshort side = sin(pi/5)\n\tlong side = cos(pi/5)\n\tdiagonal of pentagon = 2cos(pi/10)\n\tviewbox size calculations and stuff:\n\tleftmost: -(2cos(pi/10) + sin(pi/5)) = -2.490\n\trightmost: 4sin(pi/5) + 5cos(pi/10) = 7.106\n\ttopmost: -(2cos(pi/5)^2 + cos(pi/5)) = -2.118\n\tbottommost: 2cos(pi/5)+1 = 2.618\n\tthe aspect ratio is almost exactly 2, which is pretty convenient.\n\t*/\n  root.setAttribute(\"width\", \"12em\");\n  root.setAttribute(\"height\", \"6em\");\n\n  // create a polygon for each facelet\n  let points = \"0,0  -0.475528,-0.654508  0,-1  0.475528,-0.654508\";\n  // 0.4755 = sin(pi/5)cos(pi/5) and 0.6545 = cos(pi/5)^2\n  for (let i = 0; i < 20; i++) {\n    for (let j = 0; j < 3; j++) {\n      let face = map_piece_to_face(i, j);\n      let el = document.createElementNS(svgns, \"polygon\");\n      let [translate_x, translate_y] = translation_amounts[face];\n      let theta = rotation_amounts[i][j] * 36;\n      el.setAttribute(\"class\", \"facelet loc\" + i + \"_\" + j);\n      el.setAttribute(\"points\", points);\n      el.setAttribute(\n        \"transform\",\n        `translate(${translate_x},${translate_y}) rotate(${theta})`,\n      );\n      el.setAttribute(\n        \"fill\",\n        colour_scheme[map_piece_to_face(state[0][i], state[1][i] + j)],\n      );\n      el.setAttribute(\"stroke\", \"currentColor\");\n      el.setAttribute(\"stroke-linejoin\", \"round\");\n      el.setAttribute(\"stroke-width\", \"0.03\");\n      root.appendChild(el);\n    }\n  }\n\n  // create a polygon for each face to serve as an outline\n  let face_points = \"\";\n  for (let i = 0; i < 5; i++) {\n    face_points +=\n      Math.sin((Math.PI * 2 * i) / 5) +\n      \",\" +\n      -Math.cos((Math.PI * 2 * i) / 5) +\n      \" \";\n  }\n  for (let face of face_names) {\n    let el = document.createElementNS(svgns, \"polygon\");\n    let [translate_x, translate_y] = translation_amounts[face];\n    let theta = face === \"U\" || (face[0] === \"D\" && face !== \"D\") ? 0 : 180;\n    el.setAttribute(\"points\", face_points);\n    el.setAttribute(\n      \"transform\",\n      `translate(${translate_x},${translate_y}) rotate(${theta})`,\n    );\n    el.setAttribute(\"class\", \"face\");\n    el.setAttribute(\"fill\", \"none\");\n    el.setAttribute(\"stroke\", \"currentColor\");\n    el.setAttribute(\"stroke-linejoin\", \"round\");\n    el.setAttribute(\"stroke-width\", \"0.05\");\n    root.appendChild(el);\n  }\n\n  return root;\n}\n\nfunction draw_state(svgel, state, colour_scheme) {\n  colour_scheme = colour_scheme || default_colour_scheme;\n  if (!svgel) return create_svg_template(state, colour_scheme);\n  for (let i = 0; i < 20; i++) {\n    for (let j = 0; j < 3; j++) {\n      let el = svgel.querySelector(\".loc\" + i + \"_\" + j);\n      el.setAttribute(\n        \"fill\",\n        colour_scheme[map_piece_to_face(state[0][i], state[1][i] + j)],\n      );\n    }\n  }\n  return svgel;\n}\n\n/* Solver logic\n\nFor scrambling purposes, we have these two options:\n(i) generate a random state, solve it, then invert the solution\n(ii) generate a random state, solve it, return the solution as is\n\nThe former has a caveat that \"solve\" really means \"solve into the scramble orientation\". If we solve\ninto an arbitrary orientation, the result is a random-modulo-orientation state, in that the scramble\nhas the same relative positions of pieces as the random state, but possibly with the wrong colours.\n\nThe latter works here because the kilominx states form a group and taking the inverse doesn't affect\nthe randomness, and we do have the freedom to solve into any orientation. Since the WCA regs specify\nthat scrambled puzzles are delivered to the competitor in an arbitrary orientation, we may take this\nto be equivalent to right-composing with a random rotation, and this would \"cancel out\" any rotation\nshowing up at the end of the solution.\n\nSolving to orientations other than white-top-green-front saves a few moves (~2.2 moves by testing 10\norientations out of 60), but it's also proportionally slower for marginal gain.\n\nPhases used:\n\nPhase 1: get the five grey corners out of the U layer (6-gen), then rotate.\n\nPhase 2: form the U layer out of the grey corners (6-gen), then rotate.\n\nPhase 3: solve five more corners at the back/left to reduce to <U,R,F> (6-gen).\n\nPhase 4: finish last three faces (3-gen).\n\nPhase 1 is a skip (all five grey corners are already not on the D layer) ~19% of the time, and takes\njust one flip ~18% of the time, so there's a ~37% chance this step is basically trivial. With colour\nneutrality, this could be something like 99.9% trivial.\n\nPhases 2 and 3 make use of the same permutation/orientation move tables. Ideally, we'd use only one,\nbut it would be kinda terrible for a web app to eat hundreds of megabytes of memory. Luckily for us,\nIDA* settles these phases quickly enough that it doesn't really matter. Unluckily for us, this makes\nthe code a bit more complicated.\n\nPhase 4 is the problematic one, with 35.7 billion states. We use three pruning tables:\n- orientation (3^9 = 19683 states)\n- permutation (10!/2 = 1814400 states)\n- list of states up to 7 moves (3565896 states)\n\nWe don't even need to store the actual distances for the almost-solved states; we just let IDA* work\nits magic with the other pruning tables. Basically, if a state is in the list, the heuristic reports\na lower bound of 0, and if it's not, it reports a lower bound of 8.\n*/\n\nfunction solve_phase1(state) {\n  // we don't care about orientation.\n  let p = state[0];\n  // x < 15 tests if a piece is non-grey.\n  if (p.slice(15, 20).every((x) => x < 15)) return [];\n  if (p.slice(0, 5).every((x) => x < 15)) return [[6, 1]];\n  let flags = p.map((x) => x >= 15);\n  let depth = 0,\n    sol;\n  while (sol === undefined) {\n    depth++;\n    sol = search_phase1(flags, depth, -1);\n  }\n  sol.push([6, 1]);\n  return sol;\n}\n\nfunction search_phase1(flags, depth, last) {\n  if (depth == 0) {\n    if (flags.slice(0, 5).some((x) => x)) return;\n    return [];\n  }\n  for (let move_index = 0; move_index < 6; move_index++) {\n    if (move_index === last) continue;\n    for (let r = 1; r < 5; r++) {\n      let new_flags = compose(flags, moves_full[move_index][r][0]);\n      let sol = search_phase1(new_flags, depth - 1, move_index);\n      if (sol !== undefined) return [[move_index, r]].concat(sol);\n    }\n  }\n  return;\n}\n\nfunction index_phase2(state) {\n  let p = state[0].slice(0, 15),\n    o = state[1];\n  let index_c = comb_to_index(p.map((x) => +(x >= 15)));\n  let index_o = 243 * index_c;\n  for (let i = 0, j = 0; i < 15; i++) {\n    if (p[i] < 15) continue;\n    index_o += o[i] * Math.pow(3, j);\n    // as it so happens, my JS shell is too outdated and doesn't support **\n    j++;\n  }\n  let index_p = 0;\n  for (let i = 0; i < 5; i++) {\n    index_p += p.indexOf(15 + i) * Math.pow(15, i);\n  }\n  return [index_o, index_p];\n}\n\nfunction solve_phase2(state) {\n  let mtables = [\n    generate_phase23_orientation_mtable(),\n    generate_phase23_permutation_mtable(),\n  ];\n  let ptables = [\n    generate_phase2_orientation_ptable(),\n    generate_phase2_permutation_ptable(),\n  ];\n  return ida_solve(index_phase2(state), mtables, ptables).concat([[6, 1]]);\n}\n\nfunction index_phase3(state) {\n  let pieces = [5, 6, 7, 8, 14];\n  let p = state[0].slice(0, 15),\n    o = state[1];\n  let index_c = comb_to_index(p.map((x) => +(pieces.indexOf(x) !== -1)));\n  let index_o = 243 * index_c;\n  for (let i = 0, j = 0; i < 15; i++) {\n    if (pieces.indexOf(p[i]) === -1) continue;\n    index_o += o[i] * Math.pow(3, j);\n    j++;\n  }\n  let index_p = 0;\n  for (let i = 0; i < 5; i++) {\n    index_p += p.indexOf(pieces[i]) * Math.pow(15, i);\n  }\n  return [index_o, index_p];\n}\n\nfunction solve_phase3(state) {\n  let mtables = [\n    generate_phase23_orientation_mtable(),\n    generate_phase23_permutation_mtable(),\n  ];\n  let ptables = [\n    generate_phase3_orientation_ptable(),\n    generate_phase3_permutation_ptable(),\n  ];\n  return ida_solve(index_phase3(state), mtables, ptables);\n}\n\nfunction index_phase4(state) {\n  let p = state[0].slice(0, 14),\n    o = state[1];\n  let index_o = 0,\n    perm = [];\n  let j = 0;\n  for (let i of [0, 1, 2, 3, 4, 9, 10, 11, 12, 13]) {\n    if (i !== 13) index_o += o[i] * Math.pow(3, j);\n    perm[j] = p[i] < 5 ? p[i] : p[i] - 4;\n    j++;\n  }\n  return [index_o, evenpermutation_to_index(perm)];\n}\n\nfunction solve_phase4(state) {\n  let mtables = [\n    generate_phase4_orientation_mtable(),\n    generate_phase4_permutation_mtable(),\n  ];\n  let ptables = [\n    generate_phase4_orientation_ptable(),\n    generate_phase4_permutation_ptable(),\n  ];\n  return ida_solve(index_phase4(state), mtables, ptables);\n}\n\nfunction solve_phase4_fast(state) {\n  return phase4_ida_solve(index_phase4(state));\n}\n\nfunction solve(state) {\n  let sol = [];\n  for (let solver of [\n    solve_phase1,\n    solve_phase2,\n    solve_phase3,\n    solve_phase4_fast,\n  ]) {\n    //console.log(`solving with ${solver.name}`);\n    let phase_sol = solver(state);\n    state = apply_move_sequence(state, phase_sol);\n    //console.log(`solution: ${stringify_move_sequence(phase_sol)}`);\n    sol = sol.concat(phase_sol);\n  }\n  return sol;\n}\n\nfunction cn_solve(state) {\n  // Solve with partial colour neutrality. We don't want to check all 120 cases, so we look only\n  // at <y, flip>-neutrality, which has 10 cases.\n  let sol_lengths = [],\n    shortest_sol,\n    shortest_sol_length = 999999;\n  for (let x = 0; x < 2; x++) {\n    for (let y = 0; y < 5; y++) {\n      let sol = solve(state);\n      sol_lengths.push(sol.length);\n      if (shortest_sol_length > sol.length) {\n        shortest_sol_length = sol.length;\n        shortest_sol = sol;\n      }\n      state = compose_o(move_y, state);\n    }\n    state = compose_o(move_x2, state);\n  }\n  console.log(`solution lengths: ${sol_lengths.join(\", \")}`);\n  return shortest_sol;\n}\n\nconst tables = {};\n\nfunction generate_phase23_orientation_mtable() {\n  if (tables.phase23om) return tables.phase23om;\n  const C15_5 = C(15, 5),\n    THREE = [1, 3, 9, 27, 81, 243];\n  let phase23om = Array(C(15, 5) * THREE[5]);\n  tables.phase23om = phase23om;\n  for (let i = 0; i < C15_5; i++) {\n    let comb = index_to_comb(i, 5, 15).concat(Array(5).fill(0));\n    let new_comb_indices = [];\n    for (let move_index = 0; move_index < 6; move_index++) {\n      let new_comb = compose(comb, moves[move_index][0]).slice(0, 15);\n      new_comb_indices[move_index] = comb_to_index(new_comb);\n    }\n    for (let j = 0; j < THREE[5]; j++) {\n      phase23om[j + 243 * i] = [];\n      let orient_full = [];\n      for (let k = 0, l = 0; k < 20; k++) {\n        if (comb[k] === 1) {\n          orient_full[k] = ((j / THREE[l]) | 0) % 3;\n          l++;\n        } else orient_full[k] = 99; // some irrelevant garbage value\n      }\n      for (let move_index = 0; move_index < 6; move_index++) {\n        let move = moves[move_index];\n        let new_orient_full = [];\n        for (let k = 0; k < 15; k++) {\n          new_orient_full[k] = orient_full[move[0][k]] + move[1][k];\n        }\n        let new_orient = new_orient_full.filter((x) => x < 10); // get rid of garbage\n        let J = 0;\n        for (let k = 0; k < 5; k++) {\n          J += (new_orient[k] % 3) * THREE[k];\n        }\n        phase23om[j + 243 * i][move_index] =\n          J + 243 * new_comb_indices[move_index];\n      }\n    }\n  }\n  return phase23om;\n}\n\nfunction generate_phase2_orientation_ptable() {\n  if (tables.phase2op) return tables.phase2op;\n  let mtable = generate_phase23_orientation_mtable();\n  return (tables.phase2op = bfs(mtable, [243 * 3002]));\n}\n\nfunction generate_phase3_orientation_ptable() {\n  if (tables.phase3op) return tables.phase3op;\n  let mtable = generate_phase23_orientation_mtable();\n  return (tables.phase3op = bfs(mtable, [243 * 246]));\n}\n\nfunction generate_phase23_permutation_mtable() {\n  if (tables.phase23pm) return tables.phase23pm;\n  const FIFTEEN = [\n    1,\n    15,\n    225,\n    Math.pow(15, 3),\n    Math.pow(15, 4),\n    Math.pow(15, 5),\n  ];\n  let phase23pm = Array(FIFTEEN[5]);\n  let single = Array(15);\n  for (let i = 0; i < 15; i++) {\n    single[i] = Array(6);\n    for (let move_index = 0; move_index < 6; move_index++) {\n      single[i][move_index] = moves[move_index][0].indexOf(i);\n    }\n  }\n  let locations = [0, 0, 0, 0, 0];\n  for (let ind = 0; ind < FIFTEEN[5]; ind++) {\n    phase23pm[ind] = Array(6);\n    for (let move_index = 0; move_index < 6; move_index++) {\n      let new_ind = 0;\n      for (let i = 0; i < 5; i++) {\n        new_ind += single[locations[i]][move_index] * FIFTEEN[i];\n      }\n      phase23pm[ind][move_index] = new_ind;\n    }\n    locations[0]++;\n    for (let i = 0; i < 4; i++) {\n      if (locations[i] === 15) {\n        locations[i] = 0;\n        locations[i + 1]++;\n      }\n    }\n  }\n  return (tables.phase23pm = phase23pm);\n}\n\nfunction generate_phase2_permutation_ptable() {\n  if (tables.phase2pp) return tables.phase2pp;\n  let mtable = generate_phase23_permutation_mtable();\n  return (tables.phase2pp = bfs(mtable, [213090]));\n}\n\nfunction generate_phase3_permutation_ptable() {\n  if (tables.phase3pp) return tables.phase3pp;\n  let mtable = generate_phase23_permutation_mtable();\n  return (tables.phase3pp = bfs(mtable, [737420]));\n}\n\nfunction generate_phase4_orientation_mtable() {\n  if (tables.phase4om) return tables.phase4om;\n  const THREE = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049];\n  let mtable = Array(THREE[9]);\n  for (let i = 0; i < THREE[9]; i++) {\n    let o = Array(14).fill(0);\n    for (let j = 0; j < 9; j++) {\n      let J = j < 5 ? j : j + 4;\n      o[J] = ((i / THREE[j]) | 0) % 3;\n      o[13] -= o[J];\n    }\n    o[13] = (o[13] + 999) % 3;\n    mtable[i] = [];\n    for (let move_index = 0; move_index < 3; move_index++) {\n      let move = moves[move_index];\n      let new_o = [0, 1, 2, 3, 4, 9, 10, 11, 12, 13].map(\n        (i) => o[move[0][i]] + move[1][i],\n      );\n      let new_i = 0;\n      for (let j = 0; j < 9; j++) new_i += (new_o[j] % 3) * THREE[j];\n      mtable[i][move_index] = new_i;\n    }\n  }\n  return (tables.phase4om = mtable);\n}\n\nfunction generate_phase4_permutation_mtable() {\n  if (tables.phase4pm) return tables.phase4pm;\n  const HALFFACT10 = factorial(10) / 2,\n    n = 10;\n  let pre = [0, 1, 2, 3, 4, -1, -1, -1, -1, 5, 6, 7, 8, 9];\n  let post = [0, 1, 2, 3, 4, 9, 10, 11, 12, 13];\n  let move_permutations = [\n    compose(pre, compose(move_U[0], post)),\n    compose(pre, compose(move_R[0], post)),\n    compose(pre, compose(move_F[0], post)),\n  ];\n  let mtable = Array(HALFFACT10);\n  let perm = Array(10);\n  for (let i = 0; i < HALFFACT10; i++) {\n    index_to_evenpermutation10(i, perm);\n    mtable[i] = [];\n    for (let move_index = 0; move_index < 3; move_index++) {\n      let new_perm = compose(perm, move_permutations[move_index]);\n      mtable[i][move_index] = evenpermutation10_to_index(new_perm);\n    }\n  }\n  return (tables.phase4pm = mtable);\n}\n\nfunction generate_phase4_orientation_ptable() {\n  if (tables.phase4op) return tables.phase4op;\n  let mtable = generate_phase4_orientation_mtable();\n  return (tables.phase4op = bfs(mtable, [0]));\n}\n\nfunction generate_phase4_permutation_ptable() {\n  if (tables.phase4pp) return tables.phase4pp;\n  let mtable = generate_phase4_permutation_mtable();\n  return (tables.phase4pp = bfs(mtable, [0]));\n}\n\nfunction generate_phase4_near_ptable_list(threshold) {\n  if (tables.phase4np_list && tables.phase4np_list.threshold === threshold)\n    return tables.phase4np_list;\n  let mtables = [\n    generate_phase4_orientation_mtable(),\n    generate_phase4_permutation_mtable(),\n  ];\n  let base = Math.pow(3, 9);\n  let states = [0];\n  populate(threshold, [0, 0], -1);\n  function populate(depth, state, last) {\n    states.push(state[0] + base * state[1]);\n    if (depth === 0) return;\n    let new_state = [];\n    for (let move_index = 0; move_index < 3; move_index++) {\n      if (move_index === last) continue;\n      new_state[0] = state[0];\n      new_state[1] = state[1];\n      for (let r = 1; r < 5; r++) {\n        new_state[0] = mtables[0][new_state[0]][move_index];\n        new_state[1] = mtables[1][new_state[1]][move_index];\n        populate(depth - 1, new_state, move_index);\n      }\n    }\n    return;\n  }\n  states.sort((x, y) => x - y);\n  let unique_states = [],\n    last = -1;\n  for (let state of states)\n    if (state !== last) unique_states.push((last = state));\n  unique_states.threshold = threshold;\n  return (tables.phase4np_list = unique_states);\n}\n\nfunction binary_search(A, x) {\n  let lo = 0,\n    hi = A.length - 1;\n  while (hi - lo > 1) {\n    // invariants: hi - lo >= 2; x > A[lo-1]; x < A[hi+1]\n    let mid = (lo + hi) >> 1; // lo < mid < hi\n    if (x > A[mid]) lo = mid + 1;\n    else hi = mid;\n  }\n  return x === A[lo] || x === A[hi];\n}\n\nfunction cache_all_tables() {\n  let time = +new Date(),\n    splits = [time];\n  console.log(\"generating phase 2/3 move tables...\");\n  generate_phase23_orientation_mtable();\n  generate_phase23_permutation_mtable();\n  splits.push(+new Date());\n  console.log(\n    `done ${(\n      (splits[splits.length - 1] - splits[splits.length - 2]) /\n      1e3\n    ).toFixed(3)}`,\n  );\n\n  console.log(\"generating phase 2 pruning tables...\");\n  generate_phase2_orientation_ptable();\n  generate_phase2_permutation_ptable();\n  splits.push(+new Date());\n  console.log(\n    `done ${(\n      (splits[splits.length - 1] - splits[splits.length - 2]) /\n      1e3\n    ).toFixed(3)}`,\n  );\n\n  console.log(\"generating phase 3 pruning tables...\");\n  generate_phase3_orientation_ptable();\n  generate_phase3_permutation_ptable();\n  splits.push(+new Date());\n  console.log(\n    `done ${(\n      (splits[splits.length - 1] - splits[splits.length - 2]) /\n      1e3\n    ).toFixed(3)}`,\n  );\n\n  console.log(\"generating phase 4 move tables...\");\n  generate_phase4_orientation_mtable();\n  generate_phase4_permutation_mtable();\n  splits.push(+new Date());\n  console.log(\n    `done ${(\n      (splits[splits.length - 1] - splits[splits.length - 2]) /\n      1e3\n    ).toFixed(3)}`,\n  );\n\n  console.log(\"generating phase 4 pruning tables...\");\n  generate_phase4_orientation_ptable();\n  generate_phase4_permutation_ptable();\n  splits.push(+new Date());\n  console.log(\n    `done ${(\n      (splits[splits.length - 1] - splits[splits.length - 2]) /\n      1e3\n    ).toFixed(3)}`,\n  );\n\n  console.log(\"generating phase 4 bonus pruning table...\");\n  generate_phase4_near_ptable_list(PHASE4_THRESHOLD);\n  splits.push(+new Date());\n  console.log(\n    `done ${(\n      (splits[splits.length - 1] - splits[splits.length - 2]) /\n      1e3\n    ).toFixed(3)}`,\n  );\n\n  console.log(\n    \"total elapsed: \" +\n      ((splits[splits.length - 1] - splits[0]) / 1000).toFixed(3),\n  );\n}\n\nfunction bfs(mtable, goal_states) {\n  let N = mtable.length;\n  let nmoves = mtable[0].length;\n  let ptable = Array(N).fill(-1);\n  for (let state of goal_states) {\n    ptable[state] = 0;\n  }\n  let depth = 0;\n  let done = false;\n  while (!done) {\n    done = true;\n    for (let state = 0; state < N; state++) {\n      if (ptable[state] !== depth) {\n        continue;\n      }\n      for (let move_index = 0; move_index < nmoves; move_index++) {\n        let new_state = mtable[state][move_index];\n        while (new_state !== state) {\n          if (ptable[new_state] === -1) {\n            done = false;\n            ptable[new_state] = depth + 1;\n          }\n          new_state = mtable[new_state][move_index];\n        }\n      }\n    }\n    depth++;\n  }\n  return ptable;\n}\n\nfunction ida_solve(indices, mtables, ptables) {\n  let ncoords = indices.length;\n  let bound = 0;\n  for (let i = 0; i < ncoords; i++)\n    bound = Math.max(bound, ptables[i][indices[i]]);\n  while (true) {\n    let path = ida_search(indices, mtables, ptables, bound, -1);\n    if (path !== undefined) return path;\n    bound++;\n  }\n}\n\nfunction ida_search(indices, mtables, ptables, bound, last) {\n  let ncoords = indices.length;\n  let nmoves = mtables[0][0].length;\n  let heuristic = 0;\n  for (let i = 0; i < ncoords; i++)\n    heuristic = Math.max(heuristic, ptables[i][indices[i]]);\n  if (heuristic > bound) return;\n  if (bound === 0 || heuristic === 0) return [];\n  for (let m = 0; m < nmoves; m++) {\n    if (m === last) continue;\n    let new_indices = indices.slice();\n    for (let c = 0; c < ncoords; c++)\n      new_indices[c] = mtables[c][indices[c]][m];\n    let r = 1;\n    while (indices.some((_, i) => indices[i] != new_indices[i])) {\n      let subpath = ida_search(new_indices, mtables, ptables, bound - 1, m);\n      if (subpath !== undefined) return [[m, r]].concat(subpath);\n      for (let c = 0; c < ncoords; c++) {\n        new_indices[c] = mtables[c][new_indices[c]][m];\n      }\n      r++;\n    }\n  }\n  return;\n}\n\nfunction phase4_ida_solve(indices) {\n  let mtable_o = generate_phase4_orientation_mtable();\n  let mtable_p = generate_phase4_permutation_mtable();\n  let ptable_o = generate_phase4_orientation_ptable();\n  let ptable_p = generate_phase4_permutation_ptable();\n  let ptable_n = generate_phase4_near_ptable_list(PHASE4_THRESHOLD);\n  let bound = Math.max(ptable_o[indices[0]], ptable_p[indices[1]]);\n  while (true) {\n    let path = phase4_ida_search(\n      indices,\n      bound,\n      -1,\n      mtable_o,\n      mtable_p,\n      ptable_o,\n      ptable_p,\n      ptable_n,\n    );\n    if (path !== undefined) return path;\n    bound++;\n  }\n}\n\nfunction phase4_ida_search(\n  indices,\n  bound,\n  last,\n  mtable_o,\n  mtable_p,\n  ptable_o,\n  ptable_p,\n  ptable_n,\n) {\n  let heuristic = Math.max(ptable_o[indices[0]], ptable_p[indices[1]]);\n  if (heuristic > bound) return;\n  if (\n    heuristic <= PHASE4_THRESHOLD &&\n    !binary_search(ptable_n, indices[0] + 19683 * indices[1])\n  )\n    heuristic = PHASE4_THRESHOLD + 1;\n  if (heuristic > bound) return;\n  if (bound === 0 || heuristic === 0) return [];\n  for (let m = 0; m < 3; m++) {\n    if (m === last) continue;\n    let new_indices = indices.slice();\n    for (let r = 1; r < 5; r++) {\n      new_indices[0] = mtable_o[new_indices[0]][m];\n      new_indices[1] = mtable_p[new_indices[1]][m];\n      let subpath = phase4_ida_search(\n        new_indices,\n        bound - 1,\n        m,\n        mtable_o,\n        mtable_p,\n        ptable_o,\n        ptable_p,\n        ptable_n,\n      );\n      if (subpath !== undefined) return [[m, r]].concat(subpath);\n    }\n  }\n  return;\n}\n\nfunction* phase4_ida_solve_gen(indices) {\n  let mtable_o = generate_phase4_orientation_mtable();\n  let mtable_p = generate_phase4_permutation_mtable();\n  let ptable_o = generate_phase4_orientation_ptable();\n  let ptable_p = generate_phase4_permutation_ptable();\n  let ptable_n = generate_phase4_near_ptable_list(PHASE4_THRESHOLD);\n  let bound = Math.max(ptable_o[indices[0]], ptable_p[indices[1]]);\n  while (true) {\n    yield* phase4_ida_search_gen(\n      indices,\n      bound,\n      -1,\n      mtable_o,\n      mtable_p,\n      ptable_o,\n      ptable_p,\n      ptable_n,\n    );\n    bound++;\n  }\n}\n\nfunction* phase4_ida_search_gen(\n  indices,\n  bound,\n  last,\n  mtable_o,\n  mtable_p,\n  ptable_o,\n  ptable_p,\n  ptable_n,\n) {\n  let heuristic = Math.max(ptable_o[indices[0]], ptable_p[indices[1]]);\n  if (heuristic > bound) return;\n  if (\n    heuristic <= PHASE4_THRESHOLD &&\n    !binary_search(ptable_n, indices[0] + 19683 * indices[1])\n  )\n    heuristic = PHASE4_THRESHOLD + 1;\n  if (heuristic > bound) return;\n  if (bound === 0 || heuristic === 0) yield [];\n  for (let m = 0; m < 3; m++) {\n    if (m === last) continue;\n    let new_indices = indices.slice();\n    for (let r = 1; r < 5; r++) {\n      new_indices[0] = mtable_o[new_indices[0]][m];\n      new_indices[1] = mtable_p[new_indices[1]][m];\n      let subpath_gen = phase4_ida_search_gen(\n        new_indices,\n        bound - 1,\n        m,\n        mtable_o,\n        mtable_p,\n        ptable_o,\n        ptable_p,\n        ptable_n,\n      );\n      while (true) {\n        let { value: subpath, done } = subpath_gen.next();\n        if (done) break;\n        yield [[m, r]].concat(subpath);\n      }\n    }\n  }\n}\n\n/* Additional solving logic for the hybrid scrambler\n\nRather than being a purely random-move or random-state scramble (the former isn't random enough, but\nthe latter is too slow), we fully randomise the locations of the white pieces and of the grey pieces\nthen apply a bunch of random moves afterwards.\n\nThis is in the sense that the C(20,10,5,5) = 46558512 possible combinations of where the white, grey\nand E-slice pieces are (without distinguishing between the white pieces, etc.) are equally likely.\n\nCorner orientation is effectively randomised by doing at least 8 random moves on each hemisphere, so\nfor all intents and purposes, this should be as good as a random-state scramble.\n*/\n\nfunction generate_hs_mtable() {\n  if (tables.hsm) return tables.hsm;\n  const C20_5 = C(20, 5); // = 15504\n  let mtable = Array(C20_5);\n  for (let i = 0; i < C20_5; i++) {\n    mtable[i] = Array(7);\n    let comb = index_to_comb(i, 5, 20);\n    for (let m = 0; m < 7; m++) {\n      let new_comb = compose(comb, moves[m][0]);\n      mtable[i][m] = comb_to_index(new_comb);\n    }\n  }\n  return (tables.hsm = mtable);\n}\n\nfunction generate_hs_u_ptable() {\n  if (tables.hsup) return tables.hsup;\n  let mtable = generate_hs_mtable();\n  return (tables.hsup = bfs(mtable, [15503]));\n}\n\nfunction generate_hs_d_ptable() {\n  if (tables.hsdp) return tables.hsdp;\n  let mtable = generate_hs_mtable();\n  return (tables.hsdp = bfs(mtable, [0]));\n}\n\nfunction index_hs(state) {\n  let p = state[0];\n  return [\n    comb_to_index(p.map((x) => +(x < 5))),\n    comb_to_index(p.map((x) => +(x >= 15))),\n  ];\n}\n\n// this is too unpredictably slow\n// (obv we could generate a full pruning table, but that defeats the purpose of fast initialisation)\nfunction solve_hs(state) {\n  let mtables = Array(2).fill(generate_hs_mtable());\n  let ptables = [generate_hs_u_ptable(), generate_hs_d_ptable()];\n  return ida_solve(index_hs(state), mtables, ptables);\n}\n\n// this gives sequences ~2 moves longer on average, but is way faster\nfunction solve_hs_twophase(state) {\n  let mtable = generate_hs_mtable();\n  let u_ptable = generate_hs_u_ptable();\n  let d_ptable = generate_hs_d_ptable();\n  let indices = index_hs(state);\n  let sol1;\n  /*\n\tif (u_ptable[indices[0]] < d_ptable[indices[1]]) sol1 = ida_solve([indices[0]], [mtable], [u_ptable]);\n\telse sol1 = ida_solve([indices[1]], [mtable], [d_ptable]);\n\t// don't do this because it'd give solutions starting with flip pretty often.\n\t*/\n  sol1 = ida_solve([indices[1]], [mtable], [d_ptable]);\n  let s1 = apply_move_sequence(state, sol1);\n  let sol2 = ida_solve(index_hs(s1), [mtable, mtable], [u_ptable, d_ptable]);\n  return sol1.concat(sol2);\n}\n\nfunction generate_hybrid_scramble() {\n  let move_sequence = [];\n  let sort_seq = solve_hs_twophase(random_state());\n  for (let [m, r] of sort_seq) {\n    let period = m === 6 ? 2 : 5;\n    move_sequence.unshift([m, (period - r) % period]);\n  }\n\n  // TODO: remove possible move cancellations between the random-state and random-move phases\n  return move_sequence.concat(generate_random_move_scramble(2, 9));\n}\n\nfunction generate_fullseparate_mtable() {\n  if (tables.fsm) return tables.fsm;\n  const C20_10 = C(20, 10); // = 184756\n  const C19_9 = C(19, 9); // = 92378\n  let moves12 = moves.slice(0, 6);\n  moves12 = moves12.concat(\n    moves12.map((move) => compose_o(compose_o(move_x2, move), move_x2)),\n  );\n  // get all 12 face moves by conjugating the six \"top half\" moves with a flip\n  let moves15 = moves12.concat([move_x2, move_y, move_rot]);\n  let mtable = Array(C20_10 * 2);\n  let mtable15 = Array(C20_10 * 2);\n  for (let i = 0; i < C20_10; i++) {\n    mtable[i * 2] = Array(12);\n    mtable[i * 2 + 1] = Array(12);\n    mtable15[i * 2] = Array(15);\n    mtable15[i * 2 + 1] = Array(15);\n    let comb = index_to_comb(i, 10, 20);\n    let perm = [];\n    for (let j = 0, k = 0; j < 20; j++) {\n      if (comb[j] === 0) perm[j] = -1;\n      else perm[j] = k++;\n    }\n    for (let m = 0; m < 15; m++) {\n      let new_perm = compose(perm, moves15[m][0]);\n      let new_comb = compose(comb, moves15[m][0]);\n      let parity = permutation_parity(new_perm.filter((x) => x >= 0));\n      let I = comb_to_index(new_comb);\n      mtable15[i * 2][m] = I * 2 + parity;\n      mtable15[i * 2 + 1][m] = I * 2 + (parity ^ 1);\n      if (m < 12) {\n        mtable[i * 2][m] = I * 2 + parity;\n        mtable[i * 2 + 1][m] = I * 2 + (parity ^ 1);\n      }\n    }\n  }\n  tables.fsm = mtable;\n  tables.fsm15 = mtable15;\n  return mtable;\n}\n\nfunction generate_fullseparate_ptable() {\n  if (tables.fsp) return tables.fsp;\n  let mtable = generate_fullseparate_mtable();\n  /*\n\tlet separations = [\n\t\t[0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  1, 1, 1, 1, 1,  1, 1, 1, 1, 1],\n\t\t[0, 0, 0, 0, 0,  1, 1, 0, 0, 0,  0, 0, 1, 1, 1,  1, 1, 1, 1, 1],\n\t\t[0, 0, 0, 0, 0,  1, 1, 1, 1, 0,  0, 0, 0, 0, 1,  1, 1, 1, 1, 1],\n\t\t[0, 0, 0, 0, 0,  0, 1, 1, 1, 1,  1, 0, 0, 0, 0,  1, 1, 1, 1, 1],\n\t\t[0, 0, 0, 0, 0,  0, 0, 0, 1, 1,  1, 1, 1, 0, 0,  1, 1, 1, 1, 1],\n\t\t[0, 0, 1, 1, 1,  0, 0, 0, 0, 1,  1, 1, 1, 1, 0,  1, 0, 0, 0, 1],\n\t\t[1, 0, 0, 1, 1,  1, 0, 0, 0, 0,  0, 1, 1, 1, 1,  0, 0, 0, 1, 1].map(x => 1-x),\n\t\t[1, 1, 0, 0, 1,  1, 1, 1, 0, 0,  0, 0, 0, 1, 1,  0, 0, 1, 1, 0].map(x => 1-x),\n\t\t[1, 1, 1, 0, 0,  1, 1, 1, 1, 1,  0, 0, 0, 0, 0,  0, 1, 1, 0, 0].map(x => 1-x),\n\t\t[0, 1, 1, 1, 0,  0, 0, 1, 1, 1,  1, 1, 0, 0, 0,  1, 1, 0, 0, 0],\n\t];\n\t*/\n  let goal_states = [0],\n    l = 1;\n  while (true) {\n    for (let ind of goal_states) {\n      for (let m = 12; m < 15; m++) {\n        let new_ind = tables.fsm15[ind][m];\n        if (goal_states.indexOf(new_ind) === -1) {\n          goal_states.push(new_ind);\n          goal_states.sort((x, y) => x - y); // slow but w/e\n        }\n      }\n    }\n    if (goal_states.length === l) break;\n    l = goal_states.length;\n  }\n  print(goal_states.toSource());\n  return (tables.fsp = bfs5(mtable, goal_states));\n}\n\nfunction bfs5(mtable, goal_states) {\n  let N = mtable.length;\n  let nmoves = mtable[0].length;\n  let ptable = Array(N).fill(-1);\n  let queue = goal_states.slice(),\n    new_queue = [];\n  let depth = 0;\n  while (queue.length > 0) {\n    new_queue.length = 0;\n    for (let state of queue) {\n      if (ptable[state] !== -1) continue;\n      ptable[state] = depth;\n      for (let move_index = 0; move_index < nmoves; move_index++) {\n        let new_state = mtable[state][move_index];\n        for (let r = 1; r <= 4; r++) {\n          if (r === 1 || r === 4) new_queue.push(new_state);\n          new_state = mtable[new_state][move_index];\n        }\n      }\n    }\n    [queue, new_queue] = [new_queue, queue];\n    depth += 1;\n  }\n  return ptable;\n}\n\nconst randomUintBelow = randomUIntBelowFactory();\nexport async function getRandomKilominxScramble() {\n  return new Alg(\n    stringify_move_sequence(\n      generate_random_state_scramble(await randomUintBelow),\n    ),\n  );\n}\n\ngetRandomKilominxScramble().then((alg) => alg.log());\n"],
  "mappings": "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",
  "names": []
}
