{
  "version": 3,
  "sources": ["../../src/cubing/protocol/binary/orbit-indexing.ts", "../../src/cubing/protocol/binary/binary3x3x3.ts", "../../src/cubing/protocol/binary/hex.ts"],
  "sourcesContent": ["export function identityPermutation(numElems: number): number[] {\n  const arr = new Array<number>(numElems);\n  for (let i = 0; i < numElems; i++) {\n    arr[i] = i;\n  }\n  return arr;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function orientationsToMask(\n  radix: number,\n  orientations: number[],\n): number {\n  let val = 0;\n  for (const orientation of orientations) {\n    val *= radix;\n    val += orientation;\n  }\n  return val;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function maskToOrientations(\n  radix: number,\n  numElems: number,\n  mask: number,\n): number[] {\n  const arr = [];\n  while (mask > 0) {\n    arr.push(mask % radix);\n    mask = Math.floor(mask / radix);\n  }\n  return new Array<number>(numElems - arr.length).fill(0).concat(arr.reverse());\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function permutationToLex(permutation: number[]): number {\n  const n = permutation.length;\n  let lexicographicIdx = 0;\n  for (let i = 0; i < n - 1; i++) {\n    lexicographicIdx = lexicographicIdx * (n - i);\n    for (let j = i + 1; j < n; j++) {\n      if (permutation[i] > permutation[j]) {\n        lexicographicIdx += 1;\n      }\n    }\n  }\n  return lexicographicIdx;\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function lexToPermutation(\n  numPieces: number,\n  lexicographicIdx: number,\n): number[] {\n  const permutation: number[] = new Array(numPieces);\n  permutation[numPieces - 1] = 0;\n  for (let i = numPieces - 2; i >= 0; i--) {\n    permutation[i] = lexicographicIdx % (numPieces - i);\n    lexicographicIdx = Math.floor(lexicographicIdx / (numPieces - i));\n    for (let j = i + 1; j < numPieces; j++) {\n      if (permutation[j] >= permutation[i]) {\n        permutation[j] = permutation[j] + 1;\n      }\n    }\n  }\n  return permutation;\n}\n", "import { KState } from \"../../kpuzzle\";\nimport {\n  experimental3x3x3KPuzzle,\n  experimentalNormalize3x3x3Orientation,\n  experimentalPuzzleOrientation3x3x3Cache,\n  experimentalPuzzleOrientation3x3x3Idx,\n} from \"../../puzzles/cubing-private\";\nimport {\n  identityPermutation,\n  lexToPermutation,\n  maskToOrientations,\n  orientationsToMask,\n  permutationToLex,\n} from \"./orbit-indexing\";\n\n// TODO: combine with `orientPuzzle`?\nexport function reorientPuzzle(\n  state: KState,\n  idxU: number,\n  idxL: number,\n): KState {\n  return state.applyTransformation(\n    experimentalPuzzleOrientation3x3x3Cache()[idxU][idxL].invert(),\n  );\n}\n\ntype Binary3x3x3State = ArrayBuffer;\n\n// Bit lengths of the encoded components, in order.\nconst BIT_LENGTHS = [29, 12, 16, 13, 3, 2, 1, 12];\n\n// These fields are sorted by the order in which they appear in the binary format.\nexport interface Binary3x3x3Components {\n  epLex: number; // 29 bits, edge permutation\n  eoMask: number; // 12 bits, edge orientation\n  cpLex: number; // 16 bits, corner permutation\n  coMask: number; // 13 bits, corner orientation\n  poIdxU: number; // 3 bits, puzzle orientation (U face)\n  poIdxL: number; // 2 bits, puzzle orientation (L face)\n  moSupport: number; // 1 bit, center orientation support\n  moMask: number; // 12 bits, center orientation\n}\n\n// There are various clever ways to do this, but this is simple and efficient.\nfunction arraySum(arr: number[]): number {\n  let total = 0;\n  for (const entry of arr) {\n    total += entry;\n  }\n  return total;\n}\n\n// Due to limitations in JS bit operations, this is unsafe if any of the bit lengths span across the contents of more than 4 bytes.\n// - Safe: [8, 32]\n// - Unsafe: [4, 32, 4]\n// - Unsafe: [40, 4]\nfunction splitBinary(bitLengths: number[], buffy: ArrayBuffer): number[] {\n  const u8buffy = new Uint8Array(buffy);\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  const values: number[] = [];\n  for (const bitLength of bitLengths) {\n    while (bits < bitLength) {\n      accum = (accum << 8) | u8buffy[at++];\n      bits += 8;\n    }\n    values.push((accum >> (bits - bitLength)) & ((1 << bitLength) - 1));\n    bits -= bitLength;\n  }\n  return values;\n}\n\n// See above for safety notes.\nfunction concatBinary(bitLengths: number[], values: number[]): ArrayBuffer {\n  const buffy = new Uint8Array(Math.ceil(arraySum(bitLengths) / 8));\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  for (let i = 0; i < bitLengths.length; i++) {\n    accum = (accum << bitLengths[i]) | values[i];\n    bits += bitLengths[i];\n    while (bits >= 8) {\n      buffy[at++] = accum >> (bits - 8);\n      bits -= 8;\n    }\n  }\n  if (bits > 0) {\n    buffy[at++] = accum << (8 - bits);\n  }\n  return buffy;\n}\n\n// 0x111 (for idxU) means \"not supported\"\nfunction supportsPuzzleOrientation(components: Binary3x3x3Components): boolean {\n  return components.poIdxU !== 7;\n}\n\nexport function reid3x3x3ToBinaryComponents(\n  state: KState,\n): Binary3x3x3Components {\n  const normedState = experimentalNormalize3x3x3Orientation(state);\n\n  const epLex = permutationToLex(normedState.stateData[\"EDGES\"].pieces);\n  const eoMask = orientationsToMask(\n    2,\n    normedState.stateData[\"EDGES\"].orientation,\n  );\n  const cpLex = permutationToLex(normedState.stateData[\"CORNERS\"].pieces);\n  const coMask = orientationsToMask(\n    3,\n    normedState.stateData[\"CORNERS\"].orientation,\n  );\n  const [poIdxU, poIdxL] = experimentalPuzzleOrientation3x3x3Idx(state);\n  const moSupport = 1; // Required for now.\n  const moMask = orientationsToMask(\n    4,\n    normedState.stateData[\"CENTERS\"].orientation,\n  );\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\nexport function binaryComponentsToTwizzleBinary(\n  components: Binary3x3x3Components,\n): Binary3x3x3State {\n  const { epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask } =\n    components;\n\n  return concatBinary(BIT_LENGTHS, [\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  ]);\n}\n\n/** @category Binary 3x3x3 Format */\nexport function reid3x3x3ToTwizzleBinary(state: KState): Binary3x3x3State {\n  const components: Binary3x3x3Components = reid3x3x3ToBinaryComponents(state);\n  return binaryComponentsToTwizzleBinary(components);\n}\n\n/** @category Binary 3x3x3 Format */\nexport function twizzleBinaryToBinaryComponents(\n  buffer: ArrayBuffer,\n): Binary3x3x3Components {\n  const [epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask] =\n    splitBinary(BIT_LENGTHS, buffer);\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\n/** @category Binary 3x3x3 Format */\nexport function binaryComponentsToReid3x3x3(\n  components: Binary3x3x3Components,\n): KState {\n  if (components.moSupport !== 1) {\n    throw new Error(\"Must support center orientation.\");\n  }\n\n  const normedState = new KState(experimental3x3x3KPuzzle, {\n    EDGES: {\n      pieces: lexToPermutation(12, components.epLex),\n      orientation: maskToOrientations(2, 12, components.eoMask),\n    },\n    CORNERS: {\n      pieces: lexToPermutation(8, components.cpLex),\n      orientation: maskToOrientations(3, 8, components.coMask),\n    },\n    CENTERS: {\n      pieces: identityPermutation(6),\n      orientation: maskToOrientations(4, 6, components.moMask),\n    },\n  });\n\n  if (!supportsPuzzleOrientation(components)) {\n    return normedState;\n  }\n\n  return reorientPuzzle(normedState, components.poIdxU, components.poIdxL);\n}\n\n// Returns a list of error string.\n// An empty list means validation success.\nfunction validateComponents(components: Binary3x3x3Components): string[] {\n  const errors = [];\n  if (components.epLex < 0 || components.epLex >= 479001600) {\n    errors.push(`epLex (${components.epLex}) out of range`);\n  }\n  if (components.cpLex < 0 || components.cpLex >= 40320) {\n    errors.push(`cpLex (${components.cpLex}) out of range`);\n  }\n  if (components.coMask < 0 || components.coMask >= 6561) {\n    errors.push(`coMask (${components.coMask}) out of range`);\n  }\n  if (components.poIdxU < 0 || components.poIdxU >= 6) {\n    // 0x111 (for idxU) means \"not supported\"\n    if (supportsPuzzleOrientation(components)) {\n      errors.push(`poIdxU (${components.poIdxU}) out of range`);\n    }\n  }\n  // The following cannot be (f decoded from binary properl) out of rangey.\n  if (components.eoMask < 0 || components.eoMask >= 4096) {\n    errors.push(`eoMask (${components.eoMask}) out of range`);\n  }\n  if (components.moMask < 0 || components.moMask >= 4096) {\n    errors.push(`moMask (${components.moMask}) out of range`);\n  }\n  if (components.poIdxL < 0 || components.poIdxL >= 4) {\n    errors.push(`poIdxL (${components.poIdxL}) out of range`);\n  }\n  if (components.moSupport < 0 || components.moSupport >= 2) {\n    errors.push(`moSupport (${components.moSupport}) out of range`);\n  }\n  return errors;\n}\n\n/** @category Binary 3x3x3 Format */\nexport function twizzleBinaryToReid3x3x3(buffy: ArrayBuffer): KState {\n  const components = twizzleBinaryToBinaryComponents(buffy);\n  const errors = validateComponents(components);\n  if (errors.length !== 0) {\n    throw new Error(`Invalid binary state components: ${errors.join(\", \")}`);\n  }\n  return binaryComponentsToReid3x3x3(components);\n}\n", "export function bufferToSpacedHex(buffer: ArrayBuffer): string {\n  // buffer is an ArrayBuffer\n  return (\n    Array.prototype.map.call(new Uint8Array(buffer), (x: number) =>\n      (\"00\" + x.toString(16)).slice(-2),\n    ) as string[]\n  ).join(\" \");\n}\n\nexport function spacedHexToBuffer(hex: string): Uint8Array {\n  return new Uint8Array(hex.split(\" \").map((c) => parseInt(c, 16)));\n}\n"],
  "mappings": "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",
  "names": []
}
